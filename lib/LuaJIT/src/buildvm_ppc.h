/*
** This file has been pre-processed with DynASM.
** http://luajit.org/dynasm.html
** DynASM version 1.3.0, DynASM ppc version 1.3.0
** DO NOT EDIT! The original file is in "buildvm_ppc.dasc".
*/

#if DASM_VERSION != 10300
#error "Version mismatch between DynASM and included encoding engine"
#endif

# 1 "buildvm_ppc.dasc"
//|// Low-level VM code for PowerPC CPUs.
//|// Bytecode interpreter, fast functions and helper functions.
//|// Copyright (C) 2005-2012 Mike Pall. See Copyright Notice in luajit.h
//|
//|.arch ppc
//|.section code_op, code_sub
#define DASM_SECTION_CODE_OP	0
#define DASM_SECTION_CODE_SUB	1
#define DASM_MAXSECTION		2
# 7 "buildvm_ppc.dasc"
//|
//|.actionlist build_actionlist
static const unsigned int build_actionlist[7762] = {
0x00010001,
0x00060014,
0x72000000,
0x00090200,
0x39000000,
0x00098200,
0x41820000,
0x00050815,
0x8209fff8,
0x7d2e4b78,
0x9514fff8,
0x00060016,
0x72000000,
0x00090200,
0x398c0008,
0x7d936378,
0x41820000,
0x00050817,
0x00060018,
0x2c000000,
0x00098200,
0x56090038,
0x38000000,
0x00098200,
0x7d297050,
0x40a20000,
0x00050814,
0x350cfff8,
0x91320000,
0x00098200,
0x8121002c,
0x39cefff8,
0x90110000,
0x00098200,
0x55291800,
0x000900a1,
0x41820000,
0x00050802,
0x0006000b,
0x3508fff8,
0xc8140000,
0x3a940008,
0xd80e0000,
0x39ce0008,
0x40a20000,
0x0005080b,
0x0006000c,
0x7c096000,
0x40820000,
0x00050806,
0x0006000d,
0x91d20000,
0x00098200,
0x00060019,
0x00000000,
0x80010028,
0x38600000,
0x90120000,
0x00098200,
0x0006001a,
0x80010114,
0x81810034,
0x81c10000,
0x00098200,
0xc9c10000,
0x00098200,
0x81e10000,
0x00098200,
0xc9e10000,
0x00098200,
0x82010000,
0x00098200,
0xca010000,
0x00098200,
0x82210000,
0x00098200,
0xca210000,
0x00098200,
0x82410000,
0x00098200,
0xca410000,
0x00098200,
0x82610000,
0x00098200,
0xca610000,
0x00098200,
0x7c0803a6,
0x7d838120,
0x82810000,
0x00098200,
0xca810000,
0x00098200,
0x82a10000,
0x00098200,
0xcaa10000,
0x00098200,
0x82c10000,
0x00098200,
0xcac10000,
0x00098200,
0x82e10000,
0x00098200,
0xcae10000,
0x00098200,
0x00000000,
0x83010000,
0x00098200,
0xcb010000,
0x00098200,
0x83210000,
0x00098200,
0xcb210000,
0x00098200,
0x83410000,
0x00098200,
0xcb410000,
0x00098200,
0x83610000,
0x00098200,
0xcb610000,
0x00098200,
0x83810000,
0x00098200,
0xcb810000,
0x00098200,
0x83a10000,
0x00098200,
0xcba10000,
0x00098200,
0x83c10000,
0x00098200,
0xcbc10000,
0x00098200,
0x83e10000,
0x00098200,
0xcbe10000,
0x00098200,
0x38210110,
0x4e800020,
0x00060010,
0x40810000,
0x00050807,
0x81120000,
0x00098200,
0x7c0e4040,
0x40800000,
0x00050808,
0x92ee0000,
0x398c0008,
0x39ce0008,
0x48000000,
0x0005000c,
0x00060011,
0x00000000,
0x20c90000,
0x7c096050,
0x7d084110,
0x7c004038,
0x7dc07050,
0x48000000,
0x0005000d,
0x00060012,
0x91d20000,
0x00098200,
0x7d956378,
0x7d244b78,
0x7e439378,
0x48000001,
0x00030000,
0x8121002c,
0x7eacab78,
0x55291800,
0x000900a1,
0x81d20000,
0x00098200,
0x48000000,
0x0005000c,
0x0006001b,
0x7c611b78,
0x7c832378,
0x0006001c,
0x82410024,
0x38000000,
0x00098200,
0x81120000,
0x00098200,
0x90080000,
0x00098200,
0x48000000,
0x0005001a,
0x0006001d,
0x5461003a,
0x0006001e,
0x82410024,
0x3ac00000,
0x00098200,
0x81d20000,
0x00098200,
0x3cc059c0,
0x82320000,
0x00098200,
0x3b000000,
0x90c10010,
0x39000000,
0x00098200,
0x60c60004,
0x3ae00000,
0x00098200,
0x38000000,
0x00098200,
0xc3c10010,
0x820efff8,
0x3a8efff8,
0x90c10010,
0x3a310000,
0x00098200,
0x00000000,
0x91140000,
0x39800010,
0x90110000,
0x00098200,
0xc3e10010,
0x48000000,
0x00050016,
0x0006001f,
0x38800000,
0x00098200,
0x48000000,
0x00050002,
0x00060020,
0x7d6e5a14,
0x7e8ea050,
0x91d20000,
0x00098200,
0x3a100004,
0x91720000,
0x00098200,
0x568400fe,
0x000900ab,
0x0006000c,
0x92010020,
0x7e439378,
0x48000001,
0x00030000,
0x81d20000,
0x00098200,
0x81720000,
0x00098200,
0x814efffc,
0x7d6e5850,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x00060021,
0x9421fef0,
0x91c10000,
0x00098200,
0xd9c10000,
0x00098200,
0x91e10000,
0x00098200,
0xd9e10000,
0x00098200,
0x92010000,
0x00098200,
0xda010000,
0x00098200,
0x7c0802a6,
0x92210000,
0x00098200,
0x00000000,
0xda210000,
0x00098200,
0x92410000,
0x00098200,
0xda410000,
0x00098200,
0x92610000,
0x00098200,
0xda610000,
0x00098200,
0x92810000,
0x00098200,
0xda810000,
0x00098200,
0x92a10000,
0x00098200,
0xdaa10000,
0x00098200,
0x92c10000,
0x00098200,
0xdac10000,
0x00098200,
0x90010114,
0x92e10000,
0x00098200,
0xdae10000,
0x00098200,
0x93010000,
0x00098200,
0xdb010000,
0x00098200,
0x93210000,
0x00098200,
0xdb210000,
0x00098200,
0x7c000026,
0x93410000,
0x00098200,
0xdb410000,
0x00098200,
0x93610000,
0x00098200,
0xdb610000,
0x00098200,
0x93810000,
0x00098200,
0x00000000,
0xdb810000,
0x00098200,
0x93a10000,
0x00098200,
0xdba10000,
0x00098200,
0x93c10000,
0x00098200,
0xdbc10000,
0x00098200,
0x93e10000,
0x00098200,
0xdbe10000,
0x00098200,
0x90010034,
0x7c721b78,
0x82320000,
0x00098200,
0x7c8e2378,
0x89120000,
0x00098200,
0x92410024,
0x3a000000,
0x00098200,
0x38010000,
0x00098200,
0x3a310000,
0x00098200,
0x90a1002c,
0x28080000,
0x90a10030,
0x90120000,
0x00098200,
0x90a10028,
0x90610020,
0x41820000,
0x00050803,
0x7dd47378,
0x81d20000,
0x00098200,
0x3ac00000,
0x00098200,
0x81120000,
0x00098200,
0x820efff8,
0x3cc059c0,
0x98b20000,
0x00098200,
0x90c10010,
0x60c60004,
0xc3c10010,
0x7d8e4050,
0x90c10010,
0x3c004338,
0x398c0008,
0x90010008,
0x38000000,
0x00098200,
0x3b000000,
0x90110000,
0x00098200,
0x72000000,
0x00090200,
0x7d936378,
0xc3e10010,
0x3ae00000,
0x00098200,
0x00000000,
0x41820000,
0x00050817,
0x48000000,
0x00050018,
0x00060022,
0x9421fef0,
0x91c10000,
0x00098200,
0xd9c10000,
0x00098200,
0x91e10000,
0x00098200,
0xd9e10000,
0x00098200,
0x92010000,
0x00098200,
0xda010000,
0x00098200,
0x7c0802a6,
0x92210000,
0x00098200,
0xda210000,
0x00098200,
0x92410000,
0x00098200,
0xda410000,
0x00098200,
0x92610000,
0x00098200,
0xda610000,
0x00098200,
0x92810000,
0x00098200,
0xda810000,
0x00098200,
0x92a10000,
0x00098200,
0xdaa10000,
0x00098200,
0x92c10000,
0x00098200,
0xdac10000,
0x00098200,
0x90010114,
0x92e10000,
0x00098200,
0x00000000,
0xdae10000,
0x00098200,
0x93010000,
0x00098200,
0xdb010000,
0x00098200,
0x93210000,
0x00098200,
0xdb210000,
0x00098200,
0x7c000026,
0x93410000,
0x00098200,
0xdb410000,
0x00098200,
0x93610000,
0x00098200,
0xdb610000,
0x00098200,
0x93810000,
0x00098200,
0xdb810000,
0x00098200,
0x93a10000,
0x00098200,
0xdba10000,
0x00098200,
0x93c10000,
0x00098200,
0xdbc10000,
0x00098200,
0x93e10000,
0x00098200,
0xdbe10000,
0x00098200,
0x90010034,
0x3a000000,
0x00098200,
0x90c10030,
0x48000000,
0x00050001,
0x00060023,
0x9421fef0,
0x91c10000,
0x00098200,
0xd9c10000,
0x00098200,
0x00000000,
0x91e10000,
0x00098200,
0xd9e10000,
0x00098200,
0x92010000,
0x00098200,
0xda010000,
0x00098200,
0x7c0802a6,
0x92210000,
0x00098200,
0xda210000,
0x00098200,
0x92410000,
0x00098200,
0xda410000,
0x00098200,
0x92610000,
0x00098200,
0xda610000,
0x00098200,
0x92810000,
0x00098200,
0xda810000,
0x00098200,
0x92a10000,
0x00098200,
0xdaa10000,
0x00098200,
0x92c10000,
0x00098200,
0xdac10000,
0x00098200,
0x90010114,
0x92e10000,
0x00098200,
0xdae10000,
0x00098200,
0x93010000,
0x00098200,
0xdb010000,
0x00098200,
0x93210000,
0x00098200,
0xdb210000,
0x00098200,
0x00000000,
0x7c000026,
0x93410000,
0x00098200,
0xdb410000,
0x00098200,
0x93610000,
0x00098200,
0xdb610000,
0x00098200,
0x93810000,
0x00098200,
0xdb810000,
0x00098200,
0x93a10000,
0x00098200,
0xdba10000,
0x00098200,
0x93c10000,
0x00098200,
0xdbc10000,
0x00098200,
0x93e10000,
0x00098200,
0xdbe10000,
0x00098200,
0x90010034,
0x3a000000,
0x00098200,
0x0006000b,
0x81030000,
0x00098200,
0x90a1002c,
0x7c721b78,
0x90610024,
0x7c8e2378,
0x90320000,
0x00098200,
0x82320000,
0x00098200,
0x90610020,
0x91010028,
0x3a310000,
0x00098200,
0x0006000d,
0x81320000,
0x00098200,
0x3ac00000,
0x00098200,
0x81120000,
0x00098200,
0x00000000,
0x3cc059c0,
0x7e107214,
0x90c10010,
0x3b000000,
0x60c60004,
0xc3c10010,
0x7e098050,
0x90c10010,
0x3c004338,
0x7d6e4050,
0x90010008,
0x38000000,
0x00098200,
0xc3e10010,
0x3ae00000,
0x00098200,
0x90110000,
0x00098200,
0x00060024,
0x800efff8,
0x814efffc,
0x2c000000,
0x00098200,
0x40820000,
0x00050825,
0x00060026,
0x920efff8,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x00060027,
0x9421fef0,
0x91c10000,
0x00098200,
0xd9c10000,
0x00098200,
0x91e10000,
0x00098200,
0xd9e10000,
0x00098200,
0x92010000,
0x00098200,
0xda010000,
0x00098200,
0x7c0802a6,
0x92210000,
0x00098200,
0xda210000,
0x00098200,
0x92410000,
0x00098200,
0xda410000,
0x00098200,
0x92610000,
0x00098200,
0xda610000,
0x00098200,
0x92810000,
0x00098200,
0x00000000,
0xda810000,
0x00098200,
0x92a10000,
0x00098200,
0xdaa10000,
0x00098200,
0x92c10000,
0x00098200,
0xdac10000,
0x00098200,
0x90010114,
0x92e10000,
0x00098200,
0xdae10000,
0x00098200,
0x93010000,
0x00098200,
0xdb010000,
0x00098200,
0x93210000,
0x00098200,
0xdb210000,
0x00098200,
0x7c000026,
0x93410000,
0x00098200,
0xdb410000,
0x00098200,
0x93610000,
0x00098200,
0xdb610000,
0x00098200,
0x93810000,
0x00098200,
0xdb810000,
0x00098200,
0x93a10000,
0x00098200,
0xdba10000,
0x00098200,
0x93c10000,
0x00098200,
0xdbc10000,
0x00098200,
0x93e10000,
0x00098200,
0x00000000,
0xdbe10000,
0x00098200,
0x90010034,
0x7c721b78,
0x80030000,
0x00098200,
0x90610024,
0x81120000,
0x00098200,
0x90610020,
0x7c080050,
0x81120000,
0x00098200,
0x90320000,
0x00098200,
0x39200000,
0x9001002c,
0x91210030,
0x91010028,
0x7cc903a6,
0x4e800421,
0x7c6e1b79,
0x82320000,
0x00098200,
0x3a000000,
0x00098200,
0x3a310000,
0x00098200,
0x40820000,
0x0005080d,
0x48000000,
0x00050019,
0x00060015,
0x800efff4,
0x7dca7378,
0x7d2e4b78,
0x8109fffc,
0x00000000,
0x28000001,
0x00000000,
0x820afff0,
0x392cfff8,
0x81080000,
0x00098200,
0x7ef4492e,
0x00000000,
0x40810000,
0x00050801,
0x00000000,
0x81e80000,
0x00098200,
0x7c0903a6,
0x4e800420,
0x00000000,
0x0006000b,
0x41820000,
0x00050828,
0x390afff0,
0x7d6e4050,
0x48000000,
0x00050029,
0x00000000,
0x0006002a,
0x80f0fffc,
0x388afff0,
0x54f55d78,
0xc8140000,
0x7d0eaa14,
0x91d20000,
0x00098200,
0x7c082040,
0x7ca82050,
0x54f4dd78,
0xd8040000,
0x40a20000,
0x0005082b,
0x7c0ea5ae,
0x48000000,
0x0005002c,
0x0006002d,
0x38b10000,
0x00098200,
0x38000000,
0x00098200,
0x54ea5d78,
0x91650004,
0x7c8e5214,
0x90050000,
0x48000000,
0x00050001,
0x0006002e,
0x38910000,
0x00098200,
0x38000000,
0x00098200,
0x91440004,
0x38b10000,
0x00098200,
0x90040000,
0x39000000,
0x00098200,
0x91650004,
0x91050000,
0x48000000,
0x00050001,
0x0006002f,
0x00000000,
0x9001000c,
0xc8010008,
0xfc00f028,
0x00000000,
0x54ea5d78,
0x38b10000,
0x00098200,
0x7c8e5214,
0x00000000,
0x92c50000,
0x90050004,
0x00000000,
0xd8050000,
0x00000000,
0x48000000,
0x00050001,
0x00060030,
0x54ea5d78,
0x54eb9d78,
0x7c8e5214,
0x7cae5a14,
0x0006000b,
0x91d20000,
0x00098200,
0x7e439378,
0x92010020,
0x48000001,
0x00030001,
0x28030000,
0x41820000,
0x00050803,
0xc8030000,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000d,
0x210e0000,
0x00098200,
0x81d20000,
0x00098200,
0x920efff0,
0x7e087214,
0x814efffc,
0x39600010,
0x48000000,
0x00050026,
0x00060031,
0x38b10000,
0x00098200,
0x38000000,
0x00098200,
0x54ea5d78,
0x91650004,
0x7c8e5214,
0x90050000,
0x48000000,
0x00050001,
0x00060032,
0x38910000,
0x00098200,
0x38000000,
0x00098200,
0x91440004,
0x38b10000,
0x00098200,
0x90040000,
0x39000000,
0x00098200,
0x91650004,
0x91050000,
0x48000000,
0x00050001,
0x00060033,
0x00000000,
0x9001000c,
0xc8010008,
0xfc00f028,
0x00000000,
0x54ea5d78,
0x38b10000,
0x00098200,
0x7c8e5214,
0x00000000,
0x92c50000,
0x90050004,
0x00000000,
0xd8050000,
0x00000000,
0x48000000,
0x00050001,
0x00060034,
0x54ea5d78,
0x54eb9d78,
0x7c8e5214,
0x7cae5a14,
0x0006000b,
0x91d20000,
0x00098200,
0x7e439378,
0x92010020,
0x48000001,
0x00030002,
0x28030000,
0x7c0ea4ae,
0x41820000,
0x00050803,
0x80f00000,
0x3a100004,
0xd8030000,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000d,
0x210e0000,
0x00098200,
0x81d20000,
0x00098200,
0x920efff0,
0x7e087214,
0x814efffc,
0x39600018,
0xd80e0010,
0x48000000,
0x00050026,
0x00060035,
0x7e439378,
0x3a10fffc,
0x00000000,
0x7e84a378,
0x00000000,
0x7c8ea214,
0x00000000,
0x92010020,
0x00000000,
0x7d856378,
0x00000000,
0x7cae6214,
0x00000000,
0x91d20000,
0x00098200,
0x54e6063e,
0x48000001,
0x00030003,
0x0006000d,
0x28030001,
0x41810000,
0x00050836,
0x20630000,
0x0006000e,
0x80f00000,
0x3a100004,
0x54e993ba,
0x3d290000,
0x00098200,
0x7d291838,
0x7e104a14,
0x0006002c,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00060037,
0x80f0fffc,
0xc8140000,
0x54e8dd78,
0x7c0e45ae,
0x48000000,
0x0005002c,
0x00060038,
0x80140000,
0x20000000,
0x00098200,
0x7c631910,
0x7c6318f8,
0x48000000,
0x0005000e,
0x00060039,
0x80140000,
0x20000000,
0x00098200,
0x7c631910,
0x48000000,
0x0005000e,
0x0006003a,
0x3a10fffc,
0x91d20000,
0x00098200,
0x7e439378,
0x92010020,
0x48000001,
0x00030004,
0x48000000,
0x0005000d,
0x0006003b,
0x00000000,
0x7ce43b78,
0x3a10fffc,
0x91d20000,
0x00098200,
0x7e439378,
0x92010020,
0x48000001,
0x00030005,
0x48000000,
0x0005000d,
0x00000000,
0x0006003c,
0x7caf5a14,
0x7cce5214,
0x48000000,
0x00050001,
0x0006003d,
0x00000000,
0x7d655b78,
0x7d465378,
0x48000000,
0x00050001,
0x00000000,
0x0006003e,
0x7d856378,
0x7d866378,
0x48000000,
0x00050001,
0x0006003f,
0x7cae5214,
0x7ccf5a14,
0x48000000,
0x00050001,
0x00060040,
0x7cae5214,
0x7cce5a14,
0x00000000,
0x48000000,
0x00050001,
0x00000000,
0x00060041,
0x00060042,
0x00000000,
0x7d455378,
0x7d665b78,
0x00000000,
0x0006000b,
0x7c8ea214,
0x91d20000,
0x00098200,
0x7e439378,
0x92010020,
0x54e7063e,
0x48000001,
0x00030006,
0x28030000,
0x41820000,
0x0005082c,
0x00060036,
0x7d0e1850,
0x9203fff0,
0x7dc97378,
0x3a080000,
0x00098200,
0x7c6e1b78,
0x39600010,
0x48000000,
0x00050024,
0x00060043,
0x00000000,
0x7c751b78,
0x00000000,
0x7d846378,
0x91d20000,
0x00098200,
0x7e439378,
0x92010020,
0x48000001,
0x00030007,
0x00000000,
0x28030000,
0x40820000,
0x00050836,
0x7ea3ab78,
0x48000000,
0x00050044,
0x00000000,
0x48000000,
0x00050036,
0x00000000,
0x00060025,
0x7e439378,
0x91320000,
0x00098200,
0x388efff8,
0x92010020,
0x7cae5a14,
0x7d755b78,
0x48000001,
0x00030008,
0x814efffc,
0x39750008,
0x920efff8,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x00060045,
0x7e439378,
0x91d20000,
0x00098200,
0x3894fff8,
0x92010020,
0x7cb45a14,
0x7d755b78,
0x48000001,
0x00030008,
0x810efff8,
0x39750008,
0x8154fffc,
0x48000000,
0x00050046,
0x00060047,
0x7e439378,
0x91d20000,
0x00098200,
0x7e84a378,
0x92010020,
0x7cf53b78,
0x48000001,
0x00030009,
0x00000000,
0x56a0063e,
0x00000000,
0x56b4dd78,
0x00000000,
0x2c000000,
0x00098200,
0x00000000,
0x56ac9b78,
0x00000000,
0x41a20000,
0x00070800,
0x00000000,
0x48000000,
0x00070000,
0x00060048,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x39000000,
0x00098200,
0x3a8efff8,
0x7c854040,
0x820efff8,
0x40840000,
0x00050849,
0x90b40000,
0x398b0008,
0x90740004,
0x41820000,
0x0005084a,
0x39000008,
0x396bfff8,
0x0006000b,
0x7c085840,
0x7c0e44ae,
0x7c1445ae,
0x39080008,
0x40a20000,
0x0005080b,
0x48000000,
0x0005004a,
0x0006004b,
0x280b0008,
0x806e0000,
0x41800000,
0x00050849,
0x7c161810,
0x7d231910,
0x7d280338,
0x39080000,
0x00098200,
0x55081800,
0x000900a1,
0x392a0000,
0x00098200,
0x7c2944ae,
0x48000000,
0x0005004c,
0x0006004d,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x40820000,
0x00050806,
0x0006000b,
0x80630000,
0x00098200,
0x0006000c,
0x00000000,
0x38a00000,
0x00098200,
0x28030000,
0x81710000,
0x00098200,
0x41820000,
0x0005084e,
0x80030000,
0x00098200,
0x38a00000,
0x00098200,
0x810b0000,
0x00098200,
0x81230000,
0x00098200,
0x7d080038,
0x55002800,
0x000900a1,
0x55081800,
0x000900a1,
0x7d080050,
0x7d294214,
0x0006000d,
0x80c90000,
0x00098200,
0x80090000,
0x00098200,
0x80890000,
0x00098200,
0x81090000,
0x00098200,
0x2c060000,
0x00098200,
0x40820000,
0x00050804,
0x7c005800,
0x41820000,
0x00050805,
0x0006000e,
0x81290000,
0x00098200,
0x28090000,
0x41820000,
0x0005084e,
0x48000000,
0x0005000d,
0x0006000f,
0x00000000,
0x2c040000,
0x00098200,
0x41820000,
0x0005084e,
0x7c852378,
0x7d034378,
0x48000000,
0x0005004e,
0x00060010,
0x2c050000,
0x00098200,
0x41820000,
0x0005080b,
0x7c162810,
0x7d252910,
0x7d280338,
0x39080000,
0x00098200,
0x55081000,
0x000900a1,
0x39310000,
0x00098200,
0x7c69402e,
0x48000000,
0x0005000c,
0x0006004f,
0x280b0010,
0x80ae0000,
0x80ce0008,
0x806e0004,
0x808e000c,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x40820000,
0x00050849,
0x81030000,
0x00098200,
0x2c060000,
0x00098200,
0x40820000,
0x00050849,
0x28080000,
0x88c30000,
0x00098200,
0x40820000,
0x00050849,
0x70c00000,
0x00090200,
0x90830000,
0x00098200,
0x41820000,
0x0005084e,
0x00000000,
0x80110000,
0x00098200,
0x54c607b8,
0x90710000,
0x00098200,
0x98c30000,
0x00098200,
0x90030000,
0x00098200,
0x48000000,
0x0005004e,
0x00060050,
0x280b0010,
0x80ce0000,
0x808e0004,
0x41800000,
0x00050849,
0x2c060000,
0x00098200,
0x40820000,
0x00050849,
0x38ae0008,
0x7e439378,
0x48000001,
0x0003000a,
0xc8230000,
0x48000000,
0x0005004c,
0x00060051,
0x280b0008,
0x806e0000,
0xc82e0000,
0x40820000,
0x00050849,
0x7c03b040,
0x41810000,
0x00050849,
0x48000000,
0x0005004c,
0x00060052,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x41820000,
0x0005084e,
0x80110000,
0x00098200,
0x7c05b040,
0x28800000,
0x91d20000,
0x00098200,
0x4c413342,
0x92010020,
0x41820000,
0x00050849,
0x00000000,
0x80110000,
0x00098200,
0x81110000,
0x00098200,
0x7c004040,
0x40800001,
0x00050853,
0x7e439378,
0x7dc47378,
0x00000000,
0x48000001,
0x0003000b,
0x00000000,
0x48000001,
0x0003000c,
0x00000000,
0x38a00000,
0x00098200,
0x48000000,
0x0005004e,
0x00060054,
0x280b0008,
0x806e0000,
0x808e0004,
0x41800000,
0x00050849,
0x7eee592e,
0x2c030000,
0x00098200,
0x820efff8,
0x40820000,
0x00050849,
0x91d20000,
0x00098200,
0x7e439378,
0x91d20000,
0x00098200,
0x38ae0008,
0x92010020,
0x48000001,
0x0003000d,
0x28030000,
0x38a00000,
0x00098200,
0x41820000,
0x0005084e,
0xc80e0008,
0x3a8efff8,
0xc82e0010,
0xd8140000,
0x39800000,
0x00098200,
0xd8340008,
0x48000000,
0x0005004a,
0x00060055,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x820efff8,
0x40820000,
0x00050849,
0x00000000,
0x81230000,
0x00098200,
0xc80a0000,
0x00098200,
0x28090000,
0x3a8efff8,
0x40820000,
0x00050849,
0x00000000,
0xc80a0000,
0x00098200,
0x3a8efff8,
0x00000000,
0x92ee0008,
0x39800000,
0x00098200,
0xd8140000,
0x48000000,
0x0005004a,
0x00060056,
0x280b0010,
0x80ae0000,
0x806e0004,
0x80ce0008,
0x00000000,
0x812e000c,
0x00000000,
0xc84e0008,
0x00000000,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x7c86b040,
0x820efff8,
0x00000000,
0x40820000,
0x00050849,
0x40860000,
0x00050849,
0x00000000,
0x3c003ff0,
0x93010014,
0x40820000,
0x00050849,
0x90010010,
0x40840000,
0x00050849,
0xc8210010,
0xfc00101e,
0xd8010010,
0x81210014,
0x00000000,
0x80030000,
0x00098200,
0x81030000,
0x00098200,
0x00000000,
0xfc42082a,
0x00000000,
0x39290001,
0x3a8efff8,
0x7c004840,
0x00000000,
0x92d40000,
0x55261800,
0x000900a1,
0x91340004,
0x00000000,
0x55261800,
0x000900a1,
0xd8540000,
0x00000000,
0x40810000,
0x00050802,
0x7d28302e,
0x7c0834ae,
0x0006000b,
0x2c090000,
0x00098200,
0x39800000,
0x00098200,
0x41820000,
0x0005084a,
0x39800000,
0x00098200,
0xd8140008,
0x48000000,
0x0005004a,
0x0006000c,
0x80030000,
0x00098200,
0x28000000,
0x39800000,
0x00098200,
0x41820000,
0x0005084a,
0x7d244b78,
0x48000001,
0x0003000e,
0x28030000,
0x39800000,
0x00098200,
0x41820000,
0x0005084a,
0x81230000,
0xc8030000,
0x48000000,
0x0005000b,
0x00060057,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x820efff8,
0x40820000,
0x00050849,
0x00000000,
0x81230000,
0x00098200,
0xc80a0000,
0x00098200,
0x28090000,
0x3a8efff8,
0x40820000,
0x00050849,
0x00000000,
0xc80a0000,
0x00098200,
0x3a8efff8,
0x00000000,
0x92ce0008,
0x00000000,
0x930e0008,
0x00000000,
0x930e000c,
0x39800000,
0x00098200,
0xd8140000,
0x48000000,
0x0005004a,
0x00060058,
0x280b0008,
0x88d10000,
0x00098200,
0x41800000,
0x00050849,
0x7dc97378,
0x39ce0008,
0x54c607fe,
0x000900ab,
0x396bfff8,
0x3a060000,
0x00098200,
0x48000000,
0x00050024,
0x00060059,
0x280b0010,
0x80ce0008,
0xc84e0008,
0xc82e0000,
0x41800000,
0x00050849,
0x89110000,
0x00098200,
0x7dc97378,
0x2c060000,
0x00098200,
0x40820000,
0x00050849,
0x39ce0010,
0x550807fe,
0x000900ab,
0xd8490000,
0x396bfff0,
0xd8290008,
0x3a080000,
0x00098200,
0x48000000,
0x00050024,
0x0006005a,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x40820000,
0x00050849,
0x88030000,
0x00098200,
0x81030000,
0x00098200,
0x00000000,
0x80830000,
0x00098200,
0x28000000,
0x00090200,
0x81230000,
0x00098200,
0x28880000,
0x80030000,
0x00098200,
0x7f844840,
0x820efff8,
0x4f013342,
0x7d245a14,
0x4f3e1102,
0x7c890040,
0x4f18cb82,
0x92010020,
0x4f182b82,
0x91d20000,
0x00098200,
0x41980000,
0x00050849,
0x0006000b,
0x39ce0008,
0x396bfff8,
0x3929fff8,
0x91230000,
0x00098200,
0x39000000,
0x91d20000,
0x00098200,
0x0006000c,
0x7c085800,
0x7c0e44ae,
0x41820000,
0x00050803,
0x7c0445ae,
0x39080008,
0x48000000,
0x0005000c,
0x0006000d,
0x38a00000,
0x7c751b78,
0x38c00000,
0x48000001,
0x00050021,
0x0006000e,
0x81350000,
0x00098200,
0x28030000,
0x00090200,
0x80d50000,
0x00098200,
0x38000000,
0x00098200,
0x81d20000,
0x00098200,
0x90110000,
0x00098200,
0x41810000,
0x00050808,
0x00000000,
0x7d893050,
0x80120000,
0x00098200,
0x280c0000,
0x7d0e6214,
0x41820000,
0x00050806,
0x7c080040,
0x39000000,
0x41810000,
0x00050809,
0x38ccfff8,
0x91350000,
0x00098200,
0x0006000f,
0x7c083040,
0x7c0944ae,
0x7c0e45ae,
0x39080008,
0x40820000,
0x0005080f,
0x00060010,
0x72000000,
0x00090200,
0x39000000,
0x00098200,
0x3a8efff8,
0x910efff8,
0x398c0010,
0x00060011,
0x92010020,
0x7d936378,
0x41820000,
0x00050817,
0x48000000,
0x00050018,
0x00060012,
0x72000000,
0x00090200,
0x38c6fff8,
0x39000000,
0x00098200,
0xc8060000,
0x90d50000,
0x00098200,
0x39800000,
0x00098200,
0x910efff8,
0x3a8efff8,
0xd80e0000,
0x48000000,
0x00050011,
0x00060013,
0x7e439378,
0x558400fe,
0x000900ab,
0x48000001,
0x00030000,
0x38600000,
0x48000000,
0x0005000e,
0x0006005b,
0x00000000,
0x806a0000,
0x00098200,
0x88030000,
0x00098200,
0x81030000,
0x00098200,
0x80830000,
0x00098200,
0x28000000,
0x00090200,
0x81230000,
0x00098200,
0x28880000,
0x80030000,
0x00098200,
0x7f844840,
0x820efff8,
0x4f013342,
0x7d245a14,
0x4f3e1102,
0x7c890040,
0x4f18cb82,
0x92010020,
0x4f182b82,
0x91d20000,
0x00098200,
0x41980000,
0x00050849,
0x0006000b,
0x91230000,
0x00098200,
0x39000000,
0x91d20000,
0x00098200,
0x0006000c,
0x7c085800,
0x7c0e44ae,
0x41820000,
0x00050803,
0x7c0445ae,
0x39080008,
0x48000000,
0x0005000c,
0x0006000d,
0x38a00000,
0x7c751b78,
0x38c00000,
0x48000001,
0x00050021,
0x0006000e,
0x81350000,
0x00098200,
0x28030000,
0x00090200,
0x80d50000,
0x00098200,
0x38000000,
0x00098200,
0x00000000,
0x81d20000,
0x00098200,
0x90110000,
0x00098200,
0x41810000,
0x00050808,
0x7d893050,
0x80120000,
0x00098200,
0x280c0000,
0x7d0e6214,
0x41820000,
0x00050806,
0x7c080040,
0x39000000,
0x41810000,
0x00050809,
0x38ccfff8,
0x91350000,
0x00098200,
0x0006000f,
0x7c083040,
0x7c0944ae,
0x7c0e45ae,
0x39080008,
0x40820000,
0x0005080f,
0x00060010,
0x72000000,
0x00090200,
0x7dd47378,
0x398c0008,
0x00060011,
0x92010020,
0x7d936378,
0x41820000,
0x00050817,
0x48000000,
0x00050018,
0x00060012,
0x7e439378,
0x7ea4ab78,
0x48000001,
0x0003000f,
0x00060013,
0x7e439378,
0x558400fe,
0x000900ab,
0x48000001,
0x00030000,
0x38600000,
0x48000000,
0x0005000e,
0x0006005c,
0x80120000,
0x00098200,
0x00000000,
0x7d0e5a14,
0x91d20000,
0x00098200,
0x70000000,
0x00090200,
0x91120000,
0x00098200,
0x38600000,
0x00098200,
0x41820000,
0x00050849,
0x93120000,
0x00098200,
0x98720000,
0x00098200,
0x48000000,
0x0005001a,
0x0006005d,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x00000000,
0x40820000,
0x00050802,
0x7c68fe70,
0x7d091a78,
0x7c684851,
0x41800000,
0x00050801,
0x0006005e,
0x820efff8,
0x3a8efff8,
0x92cefff8,
0x906efffc,
0x48000000,
0x0005005f,
0x0006000b,
0x3ca041e0,
0x38600000,
0x48000000,
0x0005004e,
0x0006000c,
0x00000000,
0x40800000,
0x00050849,
0x54a5007e,
0x0006004e,
0x820efff8,
0x90aefff8,
0x3a8efff8,
0x906efffc,
0x0006005f,
0x39800000,
0x00098200,
0x0006004a,
0x72000000,
0x00090200,
0x7d936378,
0x40a20000,
0x00050818,
0x80f0fffc,
0x54ea5d78,
0x0006000f,
0x7c0a6040,
0x54e0dd78,
0x41810000,
0x00050806,
0x80f00000,
0x3a100004,
0x7dc0a050,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00060010,
0x390cfff8,
0x398c0008,
0x7ef4412e,
0x48000000,
0x0005000f,
0x00000000,
0x00060060,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x41a20000,
0x0005084e,
0x54a9657e,
0x40800000,
0x00050849,
0x3529fc01,
0x2889001f,
0x2009001f,
0x41800000,
0x00050803,
0x54a85800,
0x000900a1,
0x5466057e,
0x000900ab,
0x65088000,
0x39290001,
0x7d083378,
0x54645800,
0x000900a1,
0x40840000,
0x00050804,
0x7d064830,
0x7d030430,
0x7cc62378,
0x7ca9fe70,
0x7cc84838,
0x3008ffff,
0x7d004110,
0x7c634214,
0x7c634a78,
0x7c691850,
0x48000000,
0x0005005e,
0x0006000d,
0x7d252a14,
0x7ca8fe70,
0x7c694b78,
0x7d284038,
0x21280000,
0x7c631910,
0x48000000,
0x0005005e,
0x0006000e,
0x6d088000,
0x7ca9fe70,
0x7d082378,
0x7d084b39,
0x4c423202,
0x3c608000,
0x41a20000,
0x0005085e,
0x0006000f,
0xc82e0000,
0x48000001,
0x00030010,
0x48000000,
0x0005004c,
0x00060061,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x41a20000,
0x0005084e,
0x54a9657e,
0x40800000,
0x00050849,
0x3529fc01,
0x2889001f,
0x2009001f,
0x41800000,
0x00050803,
0x00000000,
0x54a85800,
0x000900a1,
0x5466057e,
0x000900ab,
0x65088000,
0x39290001,
0x7d083378,
0x54645800,
0x000900a1,
0x40840000,
0x00050804,
0x7d064830,
0x7d030430,
0x7cc62378,
0x7ca9fe70,
0x7cc84878,
0x3008ffff,
0x7d004110,
0x7c634615,
0x7c634a78,
0x7c691850,
0x40830000,
0x0005085e,
0x7c000400,
0x40a10000,
0x0005085e,
0x3ca041e0,
0x38600000,
0x48000000,
0x0005004e,
0x0006000d,
0x7d252a14,
0x7ca8fe70,
0x7c694b78,
0x7d284078,
0x3128ffff,
0x7c694110,
0x48000000,
0x0005005e,
0x0006000e,
0x6d088000,
0x7ca9fe70,
0x7d084b39,
0x4c423202,
0x3c608000,
0x41a20000,
0x0005085e,
0x0006000f,
0xc82e0000,
0x48000001,
0x00030011,
0x48000000,
0x0005004c,
0x00000000,
0x00060060,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030010,
0x48000000,
0x0005004c,
0x00060061,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030011,
0x48000000,
0x0005004c,
0x00000000,
0x00060062,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030012,
0x48000000,
0x0005004c,
0x00060063,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030013,
0x48000000,
0x0005004c,
0x00060064,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030014,
0x48000000,
0x0005004c,
0x00060065,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030015,
0x48000000,
0x0005004c,
0x00060066,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x00000000,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030016,
0x48000000,
0x0005004c,
0x00060067,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030017,
0x48000000,
0x0005004c,
0x00060068,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030018,
0x48000000,
0x0005004c,
0x00060069,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x00030019,
0x48000000,
0x0005004c,
0x0006006a,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x0003001a,
0x00000000,
0x48000000,
0x0005004c,
0x0006006b,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x0003001b,
0x48000000,
0x0005004c,
0x0006006c,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x0003001c,
0x48000000,
0x0005004c,
0x0006006d,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x0003001d,
0x48000000,
0x0005004c,
0x0006006e,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x48000001,
0x0003001e,
0x48000000,
0x0005004c,
0x0006006f,
0x00000000,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0x48000001,
0x0003001f,
0x48000000,
0x0005004c,
0x00060070,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0x48000001,
0x00030020,
0x48000000,
0x0005004c,
0x00060071,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0x48000001,
0x00030021,
0x48000000,
0x0005004c,
0x00060072,
0x00060073,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xc84a0000,
0x00098200,
0x00000000,
0xfc2100b2,
0x48000000,
0x0005004c,
0x00000000,
0x00060074,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0x806e000c,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40820000,
0x00050849,
0x00000000,
0x00060074,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0xfc40101e,
0xd8410010,
0x80610014,
0x00000000,
0x48000001,
0x00030022,
0x48000000,
0x0005004c,
0x00060075,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x38710000,
0x00098200,
0x820efff8,
0x48000001,
0x00030023,
0x81110000,
0x00098200,
0x3a8efff8,
0x00000000,
0x6d088000,
0x9101000c,
0xc8410008,
0xfc42f828,
0x00000000,
0xd8340000,
0x39800000,
0x00098200,
0x00000000,
0x92d40008,
0x9114000c,
0x00000000,
0xd8540008,
0x00000000,
0x48000000,
0x0005004a,
0x00060076,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x386efff8,
0x820efff8,
0x48000001,
0x00030024,
0x3a8efff8,
0xd82e0000,
0x39800000,
0x00098200,
0x48000000,
0x0005004a,
0x00000000,
0x00060077,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x390e0008,
0x7d2e5a14,
0x40820000,
0x00050804,
0x0006000b,
0x80c80000,
0x7c884840,
0x80880004,
0x40840000,
0x0005085e,
0x7c06b040,
0x6c608000,
0x6c868000,
0x40820000,
0x00050803,
0x7cc60010,
0x7c000110,
0x7cc60038,
0x7c662214,
0x39080008,
0x48000000,
0x0005000b,
0x0006000d,
0x40800000,
0x00050849,
0x6c638000,
0x9061000c,
0xc8210008,
0xfc21f828,
0xc8480000,
0x48000000,
0x00050006,
0x0006000e,
0xc82e0000,
0x40800000,
0x00050849,
0x0006000f,
0x80c80000,
0x7c884840,
0xc8480000,
0x40840000,
0x0005084c,
0x7c06b040,
0x40800000,
0x00050807,
0x00060010,
0xfc011028,
0x39080008,
0xfc2008ae,
0x48000000,
0x0005000f,
0x00060011,
0x80880004,
0x40820000,
0x00050849,
0x6c848000,
0x9081000c,
0xc8410008,
0xfc42f828,
0x48000000,
0x00050010,
0x00000000,
0x00060077,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x39000008,
0x0006000b,
0x7c8e402e,
0x7c4e44ae,
0x7c885840,
0x7c04b040,
0x40840000,
0x0005084c,
0x40800000,
0x00050849,
0xfc011028,
0x39080008,
0xfc2008ae,
0x48000000,
0x0005000b,
0x00000000,
0x00060078,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x390e0008,
0x7d2e5a14,
0x40820000,
0x00050804,
0x0006000b,
0x80c80000,
0x7c884840,
0x80880004,
0x40840000,
0x0005085e,
0x7c06b040,
0x6c608000,
0x6c868000,
0x40820000,
0x00050803,
0x7cc60010,
0x7c000110,
0x7cc60078,
0x7c662214,
0x39080008,
0x48000000,
0x0005000b,
0x0006000d,
0x40800000,
0x00050849,
0x6c638000,
0x9061000c,
0xc8210008,
0xfc21f828,
0xc8480000,
0x48000000,
0x00050006,
0x0006000e,
0xc82e0000,
0x40800000,
0x00050849,
0x0006000f,
0x80c80000,
0x7c884840,
0xc8480000,
0x40840000,
0x0005084c,
0x7c06b040,
0x40800000,
0x00050807,
0x00060010,
0xfc011028,
0x39080008,
0xfc20106e,
0x48000000,
0x0005000f,
0x00060011,
0x80880004,
0x40820000,
0x00050849,
0x6c848000,
0x9081000c,
0xc8410008,
0xfc42f828,
0x48000000,
0x00050010,
0x00000000,
0x00060078,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x39000008,
0x0006000b,
0x7c8e402e,
0x7c4e44ae,
0x7c885840,
0x7c04b040,
0x40840000,
0x0005084c,
0x40800000,
0x00050849,
0xfc011028,
0x39080008,
0xfc20106e,
0x48000000,
0x0005000b,
0x00000000,
0x00060079,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x40820000,
0x00050849,
0x80630000,
0x00098200,
0x48000000,
0x0005005e,
0x0006007a,
0x280b0008,
0x80ae0000,
0x806e0004,
0x40820000,
0x00050849,
0x2c050000,
0x00098200,
0x40820000,
0x00050849,
0x80030000,
0x00098200,
0x00000000,
0x88630000,
0x00098200,
0x39800000,
0x00098200,
0x820efff8,
0x28000000,
0x3a8efff8,
0x41a20000,
0x0005084a,
0x48000000,
0x0005005e,
0x00000000,
0x89030000,
0x00098200,
0x30c0ffff,
0x7d860110,
0x9101000c,
0x398c0001,
0xc8010008,
0x3a8efff8,
0x820efff8,
0xfc00f028,
0x558c1800,
0x000900a1,
0xd8140000,
0x48000000,
0x0005004a,
0x00000000,
0x0006007b,
0x80110000,
0x00098200,
0x81110000,
0x00098200,
0x7c004040,
0x40800001,
0x00050853,
0x280b0008,
0x80ae0000,
0x00000000,
0x800e0004,
0x40820000,
0x00050849,
0x7c05b040,
0x40820000,
0x00050849,
0x388e0007,
0x00000000,
0xc82e0000,
0x40820000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xfc20081e,
0xd8210010,
0x80010014,
0x38810017,
0x00000000,
0x38a00001,
0x280000ff,
0x41810000,
0x00050849,
0x0006007c,
0x7e439378,
0x91d20000,
0x00098200,
0x92010020,
0x48000001,
0x00030025,
0x81d20000,
0x00098200,
0x38a00000,
0x00098200,
0x48000000,
0x0005004e,
0x0006007d,
0x80110000,
0x00098200,
0x81110000,
0x00098200,
0x7c004040,
0x40800001,
0x00050853,
0x280b0010,
0x80ae0010,
0x00000000,
0xc80e0010,
0x00000000,
0x800e0000,
0x806e0004,
0x41800000,
0x00050849,
0x808e0008,
0x00000000,
0x810e000c,
0x00000000,
0xc82e0008,
0x00000000,
0x3920ffff,
0x41820000,
0x00050801,
0x00000000,
0x7c05b040,
0x812e0014,
0x40820000,
0x00050849,
0x0006000b,
0x7c04b040,
0x40820000,
0x00050849,
0x00000000,
0x7c05b040,
0x40800000,
0x00050849,
0xfc00001e,
0xd8010010,
0x81210014,
0x0006000b,
0x7c04b040,
0x40800000,
0x00050849,
0x00000000,
0x2c000000,
0x00098200,
0x40820000,
0x00050849,
0x00000000,
0xfc20081e,
0xd8210010,
0x81010014,
0x00000000,
0x80030000,
0x00098200,
0x7c004840,
0x38c90001,
0x41800000,
0x00050805,
0x0006000c,
0x2c080000,
0x7cc80214,
0x40810000,
0x00050807,
0x0006000d,
0x7ca84850,
0x38830000,
0x00098200,
0x7ca0fe70,
0x38a50001,
0x7c844214,
0x7ca50078,
0x48000000,
0x0005007c,
0x0006000f,
0x7c890050,
0x7c84fe70,
0x7cc62078,
0x7d203214,
0x48000000,
0x0005000c,
0x00060011,
0x30a8ffff,
0x7ca52910,
0x7cc4fe70,
0x7cc62878,
0x7cc82078,
0x39080001,
0x48000000,
0x0005000d,
0x0006007e,
0x80110000,
0x00098200,
0x81110000,
0x00098200,
0x7c004040,
0x40800001,
0x00050853,
0x280b0010,
0x800e0000,
0x806e0004,
0x80ce0008,
0x00000000,
0x80ae000c,
0x00000000,
0xc84e0008,
0x00000000,
0x41800000,
0x00050849,
0x2c000000,
0x00098200,
0x40820000,
0x00050849,
0x00000000,
0x7c06b040,
0x40820000,
0x00050849,
0x00000000,
0x7c06b040,
0x40800000,
0x00050849,
0xfc40101e,
0xd8410010,
0x80a10014,
0x00000000,
0x80030000,
0x00098200,
0x2c050000,
0x81110000,
0x00098200,
0x40810000,
0x00050802,
0x28000001,
0x3925ffff,
0x41800000,
0x00050802,
0x7c882840,
0x40820000,
0x00050849,
0x88030000,
0x00098200,
0x80910000,
0x00098200,
0x41840000,
0x00050849,
0x0006000b,
0x28090000,
0x7c0449ae,
0x3929ffff,
0x40820000,
0x0005080b,
0x48000000,
0x0005007c,
0x0006000c,
0x38710000,
0x00098200,
0x38a00000,
0x00098200,
0x48000000,
0x0005004e,
0x0006007f,
0x80110000,
0x00098200,
0x81110000,
0x00098200,
0x7c004040,
0x40800001,
0x00050853,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x81110000,
0x00098200,
0x00000000,
0x40820000,
0x00050849,
0x80a30000,
0x00098200,
0x38630000,
0x00098200,
0x80910000,
0x00098200,
0x39200000,
0x7c082840,
0x38c5ffff,
0x41800000,
0x00050849,
0x0006000b,
0x2c060000,
0x7d0348ae,
0x41a00000,
0x0005087c,
0x7d0431ae,
0x38c6ffff,
0x39290001,
0x48000000,
0x0005000b,
0x00060080,
0x80110000,
0x00098200,
0x81110000,
0x00098200,
0x7c004040,
0x40800001,
0x00050853,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x81110000,
0x00098200,
0x40820000,
0x00050849,
0x80a30000,
0x00098200,
0x38630000,
0x00098200,
0x80910000,
0x00098200,
0x7c082840,
0x39200000,
0x41800000,
0x00050849,
0x0006000b,
0x7c092840,
0x7d0348ae,
0x40a00000,
0x0005087c,
0x00000000,
0x3808ffbf,
0x69060020,
0x3000ffe6,
0x7cc63110,
0x70c60020,
0x7d083278,
0x7d0449ae,
0x39290001,
0x48000000,
0x0005000b,
0x00060081,
0x80110000,
0x00098200,
0x81110000,
0x00098200,
0x7c004040,
0x40800001,
0x00050853,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x81110000,
0x00098200,
0x40820000,
0x00050849,
0x80a30000,
0x00098200,
0x38630000,
0x00098200,
0x80910000,
0x00098200,
0x7c082840,
0x39200000,
0x41800000,
0x00050849,
0x0006000b,
0x7c092840,
0x7d0348ae,
0x40a00000,
0x0005087c,
0x3808ff9f,
0x69060020,
0x3000ffe6,
0x7cc63110,
0x70c60020,
0x7d083278,
0x7d0449ae,
0x39290001,
0x48000000,
0x0005000b,
0x00060082,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x2c050000,
0x00098200,
0x40820000,
0x00050849,
0x48000001,
0x00030026,
0x48000000,
0x0005005e,
0x00000000,
0x00060083,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x00000000,
0x00060083,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80610014,
0x00000000,
0x390e0008,
0x7d2e5a14,
0x0006000b,
0x80c80000,
0x7c884840,
0x00000000,
0x80880004,
0x00000000,
0xc8280000,
0x00000000,
0x40a40000,
0x0005085e,
0x7c06b040,
0x00000000,
0x40820001,
0x00050885,
0x00000000,
0xfc21f02a,
0x40800000,
0x00050849,
0xd8210010,
0x80810014,
0x00000000,
0x7c632038,
0x39080008,
0x48000000,
0x0005000b,
0x00000000,
0x00060086,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x00000000,
0x00060086,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80610014,
0x00000000,
0x390e0008,
0x7d2e5a14,
0x0006000b,
0x80c80000,
0x7c884840,
0x00000000,
0x80880004,
0x00000000,
0xc8280000,
0x00000000,
0x40a40000,
0x0005085e,
0x7c06b040,
0x00000000,
0x40820001,
0x00050885,
0x00000000,
0xfc21f02a,
0x40800000,
0x00050849,
0xd8210010,
0x80810014,
0x00000000,
0x7c632378,
0x39080008,
0x48000000,
0x0005000b,
0x00000000,
0x00060087,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x00000000,
0x00060087,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80610014,
0x00000000,
0x390e0008,
0x7d2e5a14,
0x0006000b,
0x80c80000,
0x7c884840,
0x00000000,
0x80880004,
0x00000000,
0xc8280000,
0x00000000,
0x40a40000,
0x0005085e,
0x7c06b040,
0x00000000,
0x40820001,
0x00050885,
0x00000000,
0xfc21f02a,
0x40800000,
0x00050849,
0xd8210010,
0x80810014,
0x00000000,
0x7c632278,
0x39080008,
0x48000000,
0x0005000b,
0x00000000,
0x00060088,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x00000000,
0x00060088,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80610014,
0x00000000,
0x5460403e,
0x5060c00e,
0x5060c42e,
0x7c030378,
0x48000000,
0x0005005e,
0x00000000,
0x00060089,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x00000000,
0x00060089,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80610014,
0x00000000,
0x7c6318f8,
0x48000000,
0x0005005e,
0x00000000,
0x0006008a,
0x280b0010,
0x80ae0000,
0x80ce0008,
0x806e0004,
0x808e000c,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x7c06b040,
0x40820000,
0x00050849,
0x00000000,
0x0006008a,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xfc42f02a,
0xd8210010,
0x80610014,
0xd8410010,
0x80810014,
0x00000000,
0x548406fe,
0x7c632030,
0x48000000,
0x0005005e,
0x00000000,
0x0006008b,
0x280b0010,
0x80ae0000,
0x80ce0008,
0x806e0004,
0x808e000c,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x7c06b040,
0x40820000,
0x00050849,
0x00000000,
0x0006008b,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xfc42f02a,
0xd8210010,
0x80610014,
0xd8410010,
0x80810014,
0x00000000,
0x548406fe,
0x7c632430,
0x48000000,
0x0005005e,
0x00000000,
0x0006008c,
0x280b0010,
0x80ae0000,
0x80ce0008,
0x806e0004,
0x808e000c,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x7c06b040,
0x40820000,
0x00050849,
0x00000000,
0x0006008c,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xfc42f02a,
0xd8210010,
0x80610014,
0xd8410010,
0x80810014,
0x00000000,
0x548406fe,
0x7c632630,
0x48000000,
0x0005005e,
0x00000000,
0x0006008d,
0x280b0010,
0x80ae0000,
0x80ce0008,
0x806e0004,
0x808e000c,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x7c06b040,
0x40820000,
0x00050849,
0x00000000,
0x0006008d,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xfc42f02a,
0xd8210010,
0x80610014,
0xd8410010,
0x80810014,
0x00000000,
0x5c63203e,
0x48000000,
0x0005005e,
0x00000000,
0x0006008e,
0x280b0010,
0x80ae0000,
0x80ce0008,
0x806e0004,
0x808e000c,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x7c06b040,
0x40820000,
0x00050849,
0x00000000,
0x0006008e,
0x280b0010,
0x80ae0000,
0xc82e0000,
0x80ce0008,
0xc84e0008,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0x7c06b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xfc42f02a,
0xd8210010,
0x80610014,
0xd8410010,
0x80810014,
0x00000000,
0x7c8400d0,
0x5c63203e,
0x48000000,
0x0005005e,
0x00000000,
0x0006008f,
0x280b0008,
0x80ae0000,
0x806e0004,
0x41800000,
0x00050849,
0x7c05b040,
0x40820001,
0x00050884,
0x00000000,
0x0006008f,
0x280b0008,
0x80ae0000,
0xc82e0000,
0x41800000,
0x00050849,
0x7c05b040,
0x40800000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80610014,
0x00000000,
0x48000000,
0x0005005e,
0x00000000,
0x0006005e,
0x6c638000,
0x9061000c,
0xc8210008,
0xfc21f828,
0x00000000,
0x0006004c,
0x820efff8,
0x3a8efff8,
0xd82efff8,
0x48000000,
0x0005005f,
0x00060084,
0x00000000,
0xc82e0000,
0x41810000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80610014,
0x4e800020,
0x00000000,
0x00060085,
0x00000000,
0xc8280000,
0x41810000,
0x00050849,
0xfc21f02a,
0xd8210010,
0x80810014,
0x4e800020,
0x00000000,
0x00060049,
0x80ca0000,
0x00098200,
0x7d0e5a14,
0x820efff8,
0x38080000,
0x00098200,
0x81320000,
0x00098200,
0x92010020,
0x7c004840,
0x91d20000,
0x00098200,
0x91120000,
0x00098200,
0x7e439378,
0x41810000,
0x00050805,
0x7cc903a6,
0x4e800421,
0x81d20000,
0x00098200,
0x2c030000,
0x546c1800,
0x000900a1,
0x3a8efff8,
0x41810000,
0x0005084a,
0x0006000b,
0x80120000,
0x00098200,
0x814efffc,
0x7d6e0050,
0x40820000,
0x00050829,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x00060029,
0x72000000,
0x00090200,
0x56080038,
0x40820000,
0x00050803,
0x80f0fffc,
0x54e8dd78,
0x0006000d,
0x7d287050,
0x48000000,
0x00050024,
0x0006000f,
0x38800000,
0x00098200,
0x48000001,
0x00030000,
0x00000000,
0x81d20000,
0x00098200,
0x7c000000,
0x48000000,
0x0005000b,
0x00060053,
0x7ea802a6,
0x91d20000,
0x00098200,
0x7c0e5a14,
0x92010020,
0x90120000,
0x00098200,
0x7e439378,
0x48000001,
0x00030027,
0x81d20000,
0x00098200,
0x7ea803a6,
0x80120000,
0x00098200,
0x7d6e0050,
0x814efffc,
0x4e800020,
0x00060090,
0x00000000,
0x88d10000,
0x00098200,
0x70c00000,
0x00090200,
0x40820000,
0x00050805,
0x81310000,
0x00098200,
0x70c00000,
0x00090200,
0x40820000,
0x00050801,
0x3929ffff,
0x70c00000,
0x00090200,
0x41a20000,
0x00050801,
0x91310000,
0x00098200,
0x48000000,
0x00050001,
0x00000000,
0x00060091,
0x88d10000,
0x00098200,
0x70c00000,
0x00090200,
0x41820000,
0x00050801,
0x0006000f,
0x39080000,
0x00098200,
0x7c11402e,
0x7c0903a6,
0x4e800420,
0x00060092,
0x88d10000,
0x00098200,
0x81310000,
0x00098200,
0x70c00000,
0x00090200,
0x54c007c0,
0x000900ab,
0x40820000,
0x0005080f,
0x2c800000,
0x3529ffff,
0x41860000,
0x0005080f,
0x91310000,
0x00098200,
0x41820000,
0x00050801,
0x40840000,
0x0005080f,
0x0006000b,
0x7e439378,
0x9261001c,
0x7e048378,
0x91d20000,
0x00098200,
0x48000001,
0x00030028,
0x0006000d,
0x81d20000,
0x00098200,
0x0006000e,
0x00000000,
0x80f0fffc,
0x54e815ba,
0x54ea5d78,
0x39080000,
0x00098200,
0x54ec9b78,
0x7c11402e,
0x54f4dd78,
0x54eb9d78,
0x7c0903a6,
0x4e800420,
0x00060093,
0x3a100004,
0x826affec,
0x48000000,
0x0005000e,
0x00060094,
0x00000000,
0x810efffc,
0x38710000,
0x00098200,
0x92010020,
0x81080000,
0x00098200,
0x7e048378,
0x92510000,
0x00098200,
0x89080000,
0x00098200,
0x91d20000,
0x00098200,
0x55081800,
0x000900a1,
0x7d0e4214,
0x91120000,
0x00098200,
0x48000001,
0x00030029,
0x48000000,
0x0005000d,
0x00000000,
0x00060095,
0x7e048378,
0x00000000,
0x48000000,
0x00050001,
0x00000000,
0x00060096,
0x00000000,
0x62040001,
0x0006000b,
0x00000000,
0x7c0e5a14,
0x92010020,
0x7e439378,
0x91d20000,
0x00098200,
0x7e8ea050,
0x90120000,
0x00098200,
0x48000001,
0x0003002a,
0x81d20000,
0x00098200,
0x80120000,
0x00098200,
0x93010020,
0x7d6e0050,
0x7e8ea214,
0x814efffc,
0x80f0fffc,
0x7c6903a6,
0x4e800420,
0x00060097,
0x00000000,
0x38210000,
0x00098200,
0xbc410000,
0x00098200,
0x3a3f0000,
0x00098200,
0x38800000,
0x00098200,
0x80610000,
0x00098200,
0x90910000,
0x00098200,
0xd8010000,
0x00098200,
0xd8210000,
0x00098200,
0xd8410000,
0x00098200,
0xd8610000,
0x00098200,
0x90610000,
0x7c000400,
0xd8810000,
0x00098200,
0xd8a10000,
0x00098200,
0xd8c10000,
0x00098200,
0xd8e10000,
0x00098200,
0x38810000,
0x00098200,
0xd9010000,
0x00098200,
0xd9210000,
0x00098200,
0xd9410000,
0x00098200,
0xd9610000,
0x00098200,
0x90810000,
0x00098200,
0xd9810000,
0x00098200,
0xd9a10000,
0x00098200,
0x00000000,
0xd9c10000,
0x00098200,
0xd9e10000,
0x00098200,
0x7ca802a6,
0x39000000,
0xda010000,
0x00098200,
0xda210000,
0x00098200,
0xda410000,
0x00098200,
0xda610000,
0x00098200,
0x91010000,
0x00098200,
0xda810000,
0x00098200,
0xdaa10000,
0x00098200,
0xdac10000,
0x00098200,
0xdae10000,
0x00098200,
0xa0c50002,
0xdb010000,
0x00098200,
0xdb210000,
0x00098200,
0xdb410000,
0x00098200,
0xdb610000,
0x00098200,
0x82510000,
0x00098200,
0xdb810000,
0x00098200,
0xdba10000,
0x00098200,
0xdbc10000,
0x00098200,
0xdbe10000,
0x00098200,
0x7ca50050,
0x81d10000,
0x00098200,
0x54a500be,
0x000900ab,
0x00000000,
0x92510000,
0x00098200,
0x38a5fffe,
0x91110000,
0x00098200,
0x90d10000,
0x00098200,
0x91d20000,
0x00098200,
0x38710000,
0x00098200,
0x90b10000,
0x00098200,
0x38810010,
0x48000001,
0x0003002b,
0x81120000,
0x00098200,
0x81210000,
0x81d20000,
0x00098200,
0x5501003a,
0x82010020,
0x91210000,
0x92410024,
0x48000000,
0x00050001,
0x00000000,
0x00060098,
0x00000000,
0x82410024,
0x3a3f0000,
0x00098200,
0x0006000b,
0x2c030000,
0x41800000,
0x00050803,
0x810efffc,
0x54731800,
0x000900a1,
0x39200000,
0x9261001c,
0x81080000,
0x00098200,
0x91310000,
0x00098200,
0x81e80000,
0x00098200,
0x3ac00000,
0x00098200,
0x3cc059c0,
0x90c10010,
0x3b000000,
0x60c60004,
0xc3c10010,
0x90c10010,
0x3c004338,
0x3ae00000,
0x00098200,
0x90010008,
0xc3e10010,
0x80f00000,
0x3a100004,
0x92f10000,
0x00098200,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7c0903a6,
0x28080000,
0x00090200,
0x40800000,
0x00050802,
0x54ea5d78,
0x54ec9b78,
0x54eb9d78,
0x4e800420,
0x0006000c,
0x3973fff8,
0x7e947214,
0x4e800420,
0x0006000d,
0x7c8300d0,
0x7e439378,
0x48000001,
0x0003002c,
0x00000000,
0x00060099,
0x48000000,
0x00030010,
0x0006009a,
0x48000000,
0x00030011,
0x0006009b,
0x00000000,
0x48000000,
0x0003002d,
0x00000000,
0x0006009c,
0x7c0327d7,
0x41830000,
0x00050801,
0x7c652279,
0x7c0021d6,
0x7c601850,
0x4c800020,
0x2c030000,
0x4d820020,
0x7c632214,
0x4e800020,
0x0006000b,
0x2c040000,
0x38600000,
0x4d820020,
0x7c000400,
0x4e800020,
0x0006009d,
0x28030001,
0x41820000,
0x00050801,
0x41810000,
0x00050802,
0xfc21102a,
0x4e800020,
0x0006000b,
0xfc211028,
0x4e800020,
0x0006000c,
0x28030003,
0x41820000,
0x00050801,
0x41810000,
0x00050802,
0xfc2100b2,
0x4e800020,
0x0006000b,
0xfc211024,
0x4e800020,
0x0006000c,
0x28030005,
0x41820000,
0x00050801,
0x41810000,
0x00050802,
0x9421ffe0,
0xd9c10010,
0xd9e10018,
0x7c0802a6,
0xfdc00890,
0xfc211024,
0x90010024,
0xfde01090,
0x48000001,
0x00030010,
0x80010024,
0xfc2103f2,
0x7c0803a6,
0xfc2e0828,
0xc9c10010,
0xc9e10018,
0x38210020,
0x4e800020,
0x0006000b,
0x48000000,
0x0003001f,
0x0006000c,
0x28030007,
0x41820000,
0x00050801,
0x41810000,
0x00050802,
0xfc200850,
0x4e800020,
0x0006000b,
0xfc200a10,
0x4e800020,
0x0006000c,
0x00000000,
0x28030009,
0x41820000,
0x00050809,
0x41810000,
0x00050802,
0x48000000,
0x00030020,
0x0006000c,
0x2803000b,
0x41810000,
0x00050809,
0xfc011028,
0x41820000,
0x00050801,
0xfc2008ae,
0x4e800020,
0x0006000b,
0xfc20106e,
0x4e800020,
0x00060013,
0x7c810808,
0x00000000,
0x7c810808,
0x00000000,
0x0006009e,
0x54630034,
0x7c832050,
0x3884001f,
0x5484d97f,
0x4d820020,
0x7c8903a6,
0x7c651b78,
0x0006000b,
0x7c00186c,
0x38630020,
0x42000000,
0x0005080b,
0x7c0004ac,
0x7c8903a6,
0x0006000b,
0x7c002fac,
0x38a50020,
0x42000000,
0x0005080b,
0x4c00012c,
0x4e800020,
0x0006009f,
0x00000000,
0x9421fef0,
0x91c10000,
0x00098200,
0xd9c10000,
0x00098200,
0x91e10000,
0x00098200,
0xd9e10000,
0x00098200,
0x92010000,
0x00098200,
0xda010000,
0x00098200,
0x7c0802a6,
0x92210000,
0x00098200,
0xda210000,
0x00098200,
0x92410000,
0x00098200,
0xda410000,
0x00098200,
0x92610000,
0x00098200,
0xda610000,
0x00098200,
0x92810000,
0x00098200,
0xda810000,
0x00098200,
0x92a10000,
0x00098200,
0xdaa10000,
0x00098200,
0x92c10000,
0x00098200,
0xdac10000,
0x00098200,
0x90010114,
0x92e10000,
0x00098200,
0xdae10000,
0x00098200,
0x93010000,
0x00098200,
0xdb010000,
0x00098200,
0x00000000,
0x93210000,
0x00098200,
0xdb210000,
0x00098200,
0x7c000026,
0x93410000,
0x00098200,
0xdb410000,
0x00098200,
0x93610000,
0x00098200,
0xdb610000,
0x00098200,
0x93810000,
0x00098200,
0xdb810000,
0x00098200,
0x93a10000,
0x00098200,
0xdba10000,
0x00098200,
0x93c10000,
0x00098200,
0xdbc10000,
0x00098200,
0x93e10000,
0x00098200,
0xdbe10000,
0x00098200,
0x90010034,
0x820c0000,
0x00098200,
0x3a2c0000,
0x00098200,
0x91700000,
0x00098200,
0x90700000,
0x00098200,
0xd8300000,
0x00098200,
0x90900000,
0x00098200,
0xd8500000,
0x00098200,
0x90b00000,
0x00098200,
0x00000000,
0xd8700000,
0x00098200,
0x90d00000,
0x00098200,
0xd8900000,
0x00098200,
0x90f00000,
0x00098200,
0xd8b00000,
0x00098200,
0x91100000,
0x00098200,
0xd8d00000,
0x00098200,
0x91300000,
0x00098200,
0xd8f00000,
0x00098200,
0x91500000,
0x00098200,
0xd9100000,
0x00098200,
0x38010000,
0x00098200,
0x90100000,
0x00098200,
0x7e038378,
0x92010020,
0x7c240b78,
0x48000001,
0x0003002e,
0x81c30000,
0x00098200,
0x3ac00000,
0x00098200,
0x81630000,
0x00098200,
0x3cc059c0,
0x3b000000,
0x7c721b78,
0x90c10010,
0x814efffc,
0x60c60004,
0x3ae00000,
0x00098200,
0x38000000,
0x00098200,
0xc3c10010,
0x90c10010,
0x7d6e5850,
0x90110000,
0x00098200,
0xc3e10010,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x00000000,
0x00060028,
0x00000000,
0x82110000,
0x00098200,
0x91d20000,
0x00098200,
0x91520000,
0x00098200,
0x92500000,
0x00098200,
0x7e038378,
0x7e84a378,
0x48000001,
0x0003002f,
0x80700000,
0x00098200,
0xc8300000,
0x00098200,
0x80900000,
0x00098200,
0x48000000,
0x0005001a,
0x00000000,
0x000600a0,
0x00000000,
0x81030000,
0x00098200,
0x7c0802a6,
0x88830000,
0x00098200,
0x88a30000,
0x00098200,
0x7d0800d0,
0x90010004,
0x2c850000,
0x7c290b78,
0x3484ffff,
0x7c21416e,
0x4cc63042,
0x91c9fffc,
0x9069fff8,
0x7d2e4b78,
0x39030000,
0x00098200,
0x54841000,
0x000900a1,
0x41a00000,
0x00050802,
0x39210008,
0x0006000b,
0x7c08202e,
0x7c09212e,
0x3484fffc,
0x40800000,
0x0005080b,
0x0006000c,
0x40a60000,
0x00050803,
0xc8230000,
0x00098200,
0xc8430000,
0x00098200,
0xc8630000,
0x00098200,
0xc8830000,
0x00098200,
0xc8a30000,
0x00098200,
0xc8c30000,
0x00098200,
0xc8e30000,
0x00098200,
0xc9030000,
0x00098200,
0x0006000d,
0x80030000,
0x00098200,
0x80830000,
0x00098200,
0x80a30000,
0x00098200,
0x00000000,
0x80c30000,
0x00098200,
0x80e30000,
0x00098200,
0x7c0903a6,
0x81030000,
0x00098200,
0x81230000,
0x00098200,
0x81430000,
0x00098200,
0x80630000,
0x00098200,
0x4e800421,
0x810efff8,
0x812efffc,
0x800e0004,
0x90680000,
0x00098200,
0xd8280000,
0x00098200,
0x90880000,
0x00098200,
0x7c0803a6,
0x90a80000,
0x00098200,
0x7dc17378,
0x90c80000,
0x00098200,
0x7d2e4b78,
0x4e800020,
0x00000000,
0x00080000,
0x00000000,
0x7c14706e,
0x3a100004,
0x80940004,
0x7d0c706e,
0x8130fffc,
0x7c00b040,
0x80ac0004,
0x552993ba,
0x7c88b040,
0x3d290000,
0x00098200,
0x40820000,
0x00050807,
0x40860000,
0x00050808,
0x7c042800,
0x00000000,
0x40800000,
0x00050802,
0x00000000,
0x41800000,
0x00050802,
0x00000000,
0x41810000,
0x00050802,
0x00000000,
0x40810000,
0x00050802,
0x00000000,
0x0006000b,
0x7e104a14,
0x0006000c,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00060011,
0x41810000,
0x00050835,
0xc8140000,
0x41850000,
0x00050835,
0x41840000,
0x00050804,
0x6ca58000,
0x90a1000c,
0xc8210008,
0xfc21f828,
0x48000000,
0x00050005,
0x00060012,
0x41850000,
0x00050835,
0x6c848000,
0x9081000c,
0xc8010008,
0xfc00f828,
0x0006000e,
0xc82c0000,
0x0006000f,
0xfc000800,
0x00000000,
0x40800000,
0x0005080c,
0x00000000,
0x41800000,
0x0005080c,
0x00000000,
0x4c001382,
0x40800000,
0x0005080c,
0x00000000,
0x4c001382,
0x41800000,
0x0005080c,
0x00000000,
0x48000000,
0x0005000b,
0x00000000,
0x7c0ea02e,
0x3a100004,
0x7c0ea4ae,
0x7d0e602e,
0x7c00b040,
0x8130fffc,
0x7c2e64ae,
0x7c88b040,
0x552993ba,
0x40800000,
0x00050835,
0x3d290000,
0x00098200,
0x40840000,
0x00050835,
0xfc000800,
0x00000000,
0x40800000,
0x00050801,
0x00000000,
0x41800000,
0x00050801,
0x00000000,
0x4c001382,
0x40800000,
0x00050801,
0x00000000,
0x4c001382,
0x41800000,
0x00050801,
0x00000000,
0x7e104a14,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7c14706e,
0x3a100004,
0x80940004,
0x7d0c706e,
0x7c00b040,
0x8130fffc,
0x7c88b040,
0x552993ba,
0x80ac0004,
0x4fa12b82,
0x3d290000,
0x00098200,
0x00000000,
0x409d0000,
0x000508a1,
0x00000000,
0x409d0000,
0x000508a2,
0x00000000,
0x7c14706e,
0x81300000,
0xc8140000,
0x3a100004,
0x7d0c706e,
0x7c00b040,
0x552993ba,
0xc82c0000,
0x7c88b040,
0x3d290000,
0x00098200,
0x40800000,
0x00050805,
0x40840000,
0x00050805,
0xfc000800,
0x00000000,
0x40820000,
0x00050801,
0x7e104a14,
0x00000000,
0x41820000,
0x00050801,
0x7e104a14,
0x00000000,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x0006000f,
0x00000000,
0x80940004,
0x80ac0004,
0x00000000,
0x2f800000,
0x00098200,
0x2e880000,
0x00098200,
0x00000000,
0x7c0600f8,
0x7c004040,
0x28860000,
0x00090200,
0x00000000,
0x4fdeb382,
0x00000000,
0x2b060000,
0x00090200,
0x00000000,
0x419e0000,
0x0005083b,
0x00000000,
0x7e842840,
0x4c222902,
0x4c161342,
0x4c42b202,
0x7e158378,
0x4c420b82,
0x4c000b82,
0x00000000,
0x40820000,
0x00050806,
0x7e104a14,
0x00060010,
0x00000000,
0x41820000,
0x00050806,
0x7e104a14,
0x00060010,
0x00000000,
0x40800000,
0x00050802,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000c,
0x00000000,
0x41800000,
0x0005080b,
0x00000000,
0x41980000,
0x0005080b,
0x81240000,
0x00098200,
0x38c00000,
0x00098200,
0x28090000,
0x41820000,
0x0005080b,
0x89290000,
0x00098200,
0x71290000,
0x00090200,
0x40820000,
0x0005080b,
0x7eb0ab78,
0x48000000,
0x0005003a,
0x00000000,
0x7c14706e,
0x558c007e,
0x000900ab,
0x80d40004,
0x81300000,
0x218cfffc,
0x3a100004,
0x00000000,
0x2c000000,
0x00098200,
0x00000000,
0x7d0f602e,
0x20000000,
0x00098200,
0x00000000,
0x41820000,
0x0005083b,
0x00000000,
0x7d064050,
0x7c004378,
0x552993ba,
0x20000000,
0x3d290000,
0x00098200,
0x7d084110,
0x00000000,
0x7d294078,
0x00000000,
0x7d294038,
0x00000000,
0x7e104a14,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7c14706e,
0x3a100004,
0x80940004,
0x7d0c786e,
0x7c00b040,
0x8130fffc,
0x7c88b040,
0x552993ba,
0x80ac0004,
0x3d290000,
0x00098200,
0x00000000,
0x000600a1,
0x00000000,
0x000600a2,
0x00000000,
0x40820000,
0x00050807,
0x40860000,
0x00050808,
0x7c042800,
0x0006000e,
0x00000000,
0x000600a1,
0x00000000,
0x000600a2,
0x00000000,
0x7c0ea02e,
0x3a100004,
0x7c0ea4ae,
0x8130fffc,
0x7c2f64ae,
0x552993ba,
0x7c00b040,
0x3d290000,
0x00098200,
0x40800000,
0x00050803,
0xfc000800,
0x00000000,
0x40820000,
0x00050801,
0x7e104a14,
0x0006000b,
0x00000000,
0x0006000d,
0x00000000,
0x41820000,
0x00050802,
0x0006000b,
0x00000000,
0x0006000d,
0x00000000,
0x7e104a14,
0x0006000c,
0x00000000,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x0006000d,
0x2c000000,
0x00098200,
0x41820000,
0x0005083b,
0x48000000,
0x0005000b,
0x00000000,
0x00060011,
0x40800000,
0x0005080d,
0xc8140000,
0x41840000,
0x00050801,
0x6ca58000,
0x90a1000c,
0xc8210008,
0xfc21f828,
0x48000000,
0x00050002,
0x00060012,
0x6c848000,
0x9081000c,
0xc8010008,
0xfc00f828,
0x0006000b,
0xc82c0000,
0x0006000c,
0xfc000800,
0x48000000,
0x0005000e,
0x00000000,
0x7c0ea02e,
0x558800fe,
0x000900ab,
0x81300000,
0x7d0840f8,
0x3a100004,
0x00000000,
0x2c000000,
0x00098200,
0x00000000,
0x7c080050,
0x00000000,
0x41820000,
0x0005083b,
0x00000000,
0x552993ba,
0x3000ffff,
0x3d290000,
0x00098200,
0x7d084110,
0x00000000,
0x7d294038,
0x00000000,
0x7d294078,
0x00000000,
0x7e104a14,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7c0e602e,
0x80f00000,
0x3a100004,
0x00000000,
0x20000000,
0x00098200,
0x54e993ba,
0x7d084110,
0x3d290000,
0x00098200,
0x00000000,
0x7d294078,
0x00000000,
0x7d294038,
0x00000000,
0x7e104a14,
0x00000000,
0x39000000,
0x00098200,
0x7c0e64ae,
0x7c004040,
0x00000000,
0x40800000,
0x00050801,
0x00000000,
0x41800000,
0x00050801,
0x00000000,
0x3e100000,
0x00098200,
0x54e993ba,
0x7c0ea5ae,
0x7e104a14,
0x0006000b,
0x00000000,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x80f00000,
0x3a100004,
0x7c0e64ae,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x80f00000,
0x3a100004,
0x7c0e602e,
0x21000000,
0x00098200,
0x7c004114,
0x7c0ea12e,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7d0c706e,
0x800c0004,
0x7c08b040,
0x00000000,
0x40820000,
0x00050805,
0x7c0004d1,
0x41830000,
0x00050804,
0x0006000b,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x90140004,
0x0006000d,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x7c000400,
0x40a10000,
0x0005080b,
0x3d0041e0,
0x38000000,
0x48000000,
0x00050007,
0x00000000,
0x0006000f,
0x40800000,
0x0005083e,
0x6d088000,
0x00060011,
0x80f00000,
0x3a100004,
0x7d14716e,
0x90140004,
0x00000000,
0x48000000,
0x0005000d,
0x00000000,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7c0c706e,
0x806c0004,
0x2c000000,
0x00098200,
0x40820000,
0x00050802,
0x80630000,
0x00098200,
0x0006000b,
0x00000000,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x90740004,
0x00000000,
0x9061000c,
0xc8010008,
0xfc00f028,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x00000000,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000c,
0x2c000000,
0x00098200,
0x40820000,
0x00050843,
0x00000000,
0x81230000,
0x00098200,
0x28090000,
0x40820000,
0x00050809,
0x0006000d,
0x00000000,
0x00060044,
0x48000001,
0x00030026,
0x48000000,
0x0005000b,
0x00000000,
0x00060013,
0x88090000,
0x00098200,
0x70000000,
0x00090200,
0x40820000,
0x0005080d,
0x48000000,
0x00050043,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x808a0004,
0x7c08b040,
0x806b0004,
0x00000000,
0x7d0a706e,
0x7d2b706e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7c89b040,
0x40820000,
0x00050805,
0x40860000,
0x00050805,
0x7c632615,
0x41830000,
0x00050804,
0x0006000b,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x90740004,
0x0006000c,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x7c000400,
0x40a10000,
0x0005080b,
0x00000000,
0x48000000,
0x00050041,
0x00000000,
0x48000000,
0x0005003d,
0x00000000,
0x48000000,
0x00050042,
0x00000000,
0x0006000f,
0x00000000,
0xc9ea0000,
0x4c002202,
0xc9cb0000,
0x00000000,
0xc9ca0000,
0x4c002202,
0xc9eb0000,
0x00000000,
0x40800000,
0x00050841,
0x00000000,
0x40800000,
0x0005083d,
0x00000000,
0x40800000,
0x00050842,
0x00000000,
0xfc0e782a,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x48000000,
0x0005000c,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dce54ae,
0x7def5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083f,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083f,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dee54ae,
0x7dcf5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083c,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083c,
0x00000000,
0x7d0e502e,
0x7d2e582e,
0x7dce54ae,
0x7dee5cae,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x00050840,
0x00000000,
0xfc0e782a,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x808a0004,
0x7c08b040,
0x806b0004,
0x00000000,
0x7d0a706e,
0x7d2b706e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7c89b040,
0x40820000,
0x00050805,
0x40860000,
0x00050805,
0x7c641c51,
0x41830000,
0x00050804,
0x0006000b,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x90740004,
0x0006000c,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x7c000400,
0x40a10000,
0x0005080b,
0x00000000,
0x48000000,
0x00050041,
0x00000000,
0x48000000,
0x0005003d,
0x00000000,
0x48000000,
0x00050042,
0x00000000,
0x0006000f,
0x00000000,
0xc9ea0000,
0x4c002202,
0xc9cb0000,
0x00000000,
0xc9ca0000,
0x4c002202,
0xc9eb0000,
0x00000000,
0x40800000,
0x00050841,
0x00000000,
0x40800000,
0x0005083d,
0x00000000,
0x40800000,
0x00050842,
0x00000000,
0xfc0e7828,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x48000000,
0x0005000c,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dce54ae,
0x7def5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083f,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083f,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dee54ae,
0x7dcf5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083c,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083c,
0x00000000,
0x7d0e502e,
0x7d2e582e,
0x7dce54ae,
0x7dee5cae,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x00050840,
0x00000000,
0xfc0e7828,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x808a0004,
0x7c08b040,
0x806b0004,
0x00000000,
0x7d0a706e,
0x7d2b706e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7c89b040,
0x40820000,
0x00050805,
0x40860000,
0x00050805,
0x7c6325d7,
0x41830000,
0x00050804,
0x0006000b,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x90740004,
0x0006000c,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x7c000400,
0x40a10000,
0x0005080b,
0x00000000,
0x48000000,
0x00050041,
0x00000000,
0x48000000,
0x0005003d,
0x00000000,
0x48000000,
0x00050042,
0x00000000,
0x0006000f,
0x00000000,
0xc9ea0000,
0x4c002202,
0xc9cb0000,
0x00000000,
0xc9ca0000,
0x4c002202,
0xc9eb0000,
0x00000000,
0x40800000,
0x00050841,
0x00000000,
0x40800000,
0x0005083d,
0x00000000,
0x40800000,
0x00050842,
0x00000000,
0xfc0e03f2,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x48000000,
0x0005000c,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dce54ae,
0x7def5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083f,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083f,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dee54ae,
0x7dcf5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083c,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083c,
0x00000000,
0x7d0e502e,
0x7d2e582e,
0x7dce54ae,
0x7dee5cae,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x00050840,
0x00000000,
0xfc0e03f2,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dce54ae,
0x7def5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083f,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083f,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dee54ae,
0x7dcf5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083c,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083c,
0x00000000,
0x7d0e502e,
0x7d2e582e,
0x7dce54ae,
0x7dee5cae,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x00050840,
0x00000000,
0xfc0e7824,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x808a0004,
0x7c08b040,
0x806b0004,
0x00000000,
0x7d0a706e,
0x7d2b706e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7c89b040,
0x40820000,
0x00050805,
0x40860000,
0x00050805,
0x48000001,
0x0005009c,
0x41830000,
0x00050804,
0x0006000b,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x90740004,
0x0006000c,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x7c000400,
0x40a10000,
0x0005080b,
0x00000000,
0x48000000,
0x00050041,
0x00000000,
0x48000000,
0x0005003d,
0x00000000,
0x48000000,
0x00050042,
0x00000000,
0x0006000f,
0x00000000,
0xc9ea0000,
0x4c002202,
0xc9cb0000,
0x00000000,
0xc9ca0000,
0x4c002202,
0xc9eb0000,
0x00000000,
0x40800000,
0x00050841,
0x00000000,
0x40800000,
0x0005083d,
0x00000000,
0x40800000,
0x00050842,
0x00000000,
0x000600a3,
0xfc2e7824,
0x48000001,
0x00030010,
0xfc0103f2,
0xfc0e0028,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x48000000,
0x0005000c,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dce54ae,
0x7def5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083f,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083f,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dee54ae,
0x7dcf5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083c,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083c,
0x00000000,
0x7d0e502e,
0x7d2e582e,
0x7dce54ae,
0x7dee5cae,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x00050840,
0x00000000,
0x000600a3,
0xfc2e7824,
0x48000001,
0x00030010,
0xfc0103f2,
0xfc0e0028,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7d0a706e,
0x7d2b786e,
0x808a0004,
0x7c08b040,
0x806b0004,
0x00000000,
0x7d0a706e,
0x7d2b706e,
0x806a0004,
0x7c08b040,
0x808b0004,
0x00000000,
0x7c89b040,
0x40820000,
0x00050805,
0x40860000,
0x00050805,
0x48000001,
0x0005009c,
0x41830000,
0x00050804,
0x0006000b,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x90740004,
0x0006000c,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x7c000400,
0x40a10000,
0x0005080b,
0x00000000,
0x48000000,
0x00050041,
0x00000000,
0x48000000,
0x0005003d,
0x00000000,
0x48000000,
0x00050042,
0x00000000,
0x0006000f,
0x00000000,
0xc9ea0000,
0x4c002202,
0xc9cb0000,
0x00000000,
0xc9ca0000,
0x4c002202,
0xc9eb0000,
0x00000000,
0x40800000,
0x00050841,
0x00000000,
0x40800000,
0x0005083d,
0x00000000,
0x40800000,
0x00050842,
0x00000000,
0x48000000,
0x000500a3,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dce54ae,
0x7def5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083f,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083f,
0x00000000,
0x7d0e502e,
0x00000000,
0x7d2f582e,
0x00000000,
0x7dee54ae,
0x7dcf5cae,
0x00000000,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x0005083c,
0x00000000,
0x7c08b040,
0x40800000,
0x0005083c,
0x00000000,
0x7d0e502e,
0x7d2e582e,
0x7dce54ae,
0x7dee5cae,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x00050840,
0x00000000,
0x48000000,
0x000500a3,
0x00000000,
0x7d0e502e,
0x7c2e54ae,
0x7d2e582e,
0x7c4e5cae,
0x7c08b040,
0x7c89b040,
0x4c002202,
0x40800000,
0x00050840,
0x48000001,
0x0003001f,
0x80f00000,
0x3a100004,
0x7c2ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7caa5850,
0x91d20000,
0x00098200,
0x7c8e5a14,
0x7d555378,
0x0006002b,
0x92010020,
0x7e439378,
0x54a500fe,
0x000900ab,
0x48000001,
0x00030030,
0x28030000,
0x81d20000,
0x00098200,
0x40820000,
0x00050836,
0x80f00000,
0x3a100004,
0x7c0eacae,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x5588007e,
0x000900ab,
0x2108fffc,
0x80f00000,
0x3a100004,
0x7c0f402e,
0x39200000,
0x00098200,
0x7d34716e,
0x90140004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x5588007e,
0x000900ab,
0x2108fffc,
0x80f00000,
0x3a100004,
0x7c0f402e,
0x39200000,
0x00098200,
0x7d34716e,
0x90140004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x558c6800,
0x000900a1,
0x7d8c8670,
0x80f00000,
0x3a100004,
0x7ed4716e,
0x91940004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x558c6800,
0x000900a1,
0x7d88fe70,
0x7d096278,
0x7d284850,
0x7d260034,
0x2106040d,
0x7d293030,
0x20cc0000,
0x5508a000,
0x000900a1,
0x512ca87e,
0x7c000110,
0x7d8c4214,
0x7d8c0038,
0x80f00000,
0x3a100004,
0x7d94716e,
0x93140004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x80f00000,
0x3a100004,
0x7c0f64ae,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x558800fe,
0x000900ab,
0x7d0040f8,
0x80f00000,
0x3a100004,
0x7c0ea12e,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x7eeea12e,
0x3a940008,
0x0006000b,
0x7eeea12e,
0x7c146000,
0x3a940008,
0x41800000,
0x0005080b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x814efffc,
0x558c007e,
0x000900ab,
0x398c0000,
0x00098200,
0x7d4a602e,
0x80f00000,
0x3a100004,
0x810a0000,
0x00098200,
0xc8080000,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x814efffc,
0x5694007e,
0x000900ab,
0x3a940000,
0x00098200,
0x7c0c74ee,
0x7d4aa02e,
0x88ca0000,
0x00098200,
0x808a0000,
0x00098200,
0x70c60000,
0x00090200,
0x880a0000,
0x00098200,
0x812c0000,
0xd8040000,
0x28800000,
0x810c0004,
0x4c423382,
0x39290000,
0x00098200,
0x40820000,
0x00050802,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000c,
0x28090000,
0x00090200,
0x40800000,
0x0005080b,
0x88c80000,
0x00098200,
0x70c60000,
0x00090200,
0x38710000,
0x00098200,
0x41820000,
0x0005080b,
0x48000001,
0x00030031,
0x48000000,
0x0005000b,
0x00000000,
0x814efffc,
0x5588007e,
0x000900ab,
0x5694007e,
0x000900ab,
0x2108fffc,
0x3a940000,
0x00098200,
0x7d0f402e,
0x7d4aa02e,
0x88ca0000,
0x00098200,
0x808a0000,
0x00098200,
0x70c60000,
0x00090200,
0x88c80000,
0x00098200,
0x892a0000,
0x00098200,
0x38000000,
0x00098200,
0x91040004,
0x90040000,
0x40820000,
0x00050802,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000c,
0x70c60000,
0x00090200,
0x28890000,
0x4c423382,
0x38710000,
0x00098200,
0x41820000,
0x0005080b,
0x48000001,
0x00030031,
0x48000000,
0x0005000b,
0x00000000,
0x814efffc,
0x5694007e,
0x000900ab,
0x3a940000,
0x00098200,
0x7c0f64ae,
0x7d4aa02e,
0x80f00000,
0x3a100004,
0x810a0000,
0x00098200,
0xd8080000,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x814efffc,
0x5694007e,
0x000900ab,
0x558000fe,
0x000900ab,
0x3a940000,
0x00098200,
0x7c0000f8,
0x7d4aa02e,
0x80f00000,
0x3a100004,
0x810a0000,
0x00098200,
0x90080000,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x81120000,
0x00098200,
0x5580007e,
0x000900ab,
0x3e100000,
0x00098200,
0x7e100214,
0x91d20000,
0x00098200,
0x28080000,
0x7e439378,
0x41820000,
0x00050801,
0x7c8ea214,
0x48000001,
0x00030032,
0x81d20000,
0x00098200,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x5588007e,
0x000900ab,
0x91d20000,
0x00098200,
0x2108fffc,
0x92010020,
0x7c8f402e,
0x7e439378,
0x80aefffc,
0x48000001,
0x00030033,
0x81d20000,
0x00098200,
0x38000000,
0x00098200,
0x7c14716e,
0x90740004,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x80110000,
0x00098200,
0x7e439378,
0x81110000,
0x00098200,
0x91d20000,
0x00098200,
0x7c004040,
0x92010020,
0x40800000,
0x00050805,
0x0006000b,
0x00000000,
0x5584ed7e,
0x558596fe,
0x2c0407ff,
0x41820000,
0x00050803,
0x0006000c,
0x48000001,
0x00030034,
0x00000000,
0x5588007e,
0x000900ab,
0x2108fffc,
0x7c8f402e,
0x48000001,
0x00030035,
0x00000000,
0x81d20000,
0x00098200,
0x38000000,
0x00098200,
0x7c14716e,
0x90740004,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x0006000d,
0x38800801,
0x48000000,
0x0005000c,
0x00000000,
0x0006000f,
0x7d956378,
0x48000001,
0x00030036,
0x7eacab78,
0x7e439378,
0x48000000,
0x0005000b,
0x00000000,
0x812efffc,
0x5588007e,
0x000900ab,
0x81490000,
0x00098200,
0x2108fffc,
0x7d6f402e,
0x00000000,
0x48000000,
0x000500a4,
0x00000000,
0x48000000,
0x000500a5,
0x00000000,
0x7c6a706e,
0x7c8b706e,
0x814a0004,
0x00000000,
0x816b0004,
0x00000000,
0xc80b0000,
0x00000000,
0x2c030000,
0x00098200,
0x7c84b040,
0x40820000,
0x00050830,
0x00000000,
0x800a0000,
0x00098200,
0x40860000,
0x00050805,
0x810a0000,
0x00098200,
0x7c005840,
0x55691800,
0x000900a1,
0x00000000,
0x40840000,
0x00050805,
0xfc20001e,
0xfc40f02a,
0xd8210010,
0x800a0000,
0x00098200,
0xfc42f028,
0x81210014,
0x810a0000,
0x00098200,
0xfc801000,
0x7c004840,
0x4c213202,
0x55291800,
0x000900a1,
0x00000000,
0x40810000,
0x00050830,
0x7c08482e,
0x7dc84cae,
0x2c000000,
0x00098200,
0x41820000,
0x00050802,
0x0006000b,
0x80f00000,
0x3a100004,
0x7dcea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000c,
0x812a0000,
0x00098200,
0x28090000,
0x41820000,
0x0005080b,
0x88090000,
0x00098200,
0x70000000,
0x00090200,
0x40820000,
0x0005080b,
0x48000000,
0x00050030,
0x0006000f,
0x2c040000,
0x00098200,
0x40820000,
0x00050830,
0x00000000,
0x816b0004,
0x00000000,
0x48000000,
0x000500a4,
0x00000000,
0x7c6a706e,
0x5568007e,
0x000900ab,
0x814a0004,
0x2108fffc,
0x2c030000,
0x00098200,
0x7d6f402e,
0x40820000,
0x0005082d,
0x000600a4,
0x800a0000,
0x00098200,
0x810b0000,
0x00098200,
0x812a0000,
0x00098200,
0x7d080038,
0x55002800,
0x000900a1,
0x55081800,
0x000900a1,
0x7d080050,
0x7d294214,
0x0006000b,
0x80690000,
0x00098200,
0x80090000,
0x00098200,
0x80890000,
0x00098200,
0x81090000,
0x00098200,
0x2c030000,
0x00098200,
0x40820000,
0x00050804,
0x7c005800,
0x40820000,
0x00050804,
0x2c040000,
0x00098200,
0x41820000,
0x00050805,
0x0006000d,
0x7c94716e,
0x91140004,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x81290000,
0x00098200,
0x00000000,
0x28090000,
0x40820000,
0x0005080b,
0x38800000,
0x00098200,
0x0006000f,
0x812a0000,
0x00098200,
0x28090000,
0x41820000,
0x0005080d,
0x88090000,
0x00098200,
0x70000000,
0x00090200,
0x40820000,
0x0005080d,
0x48000000,
0x0005002e,
0x00000000,
0x7c6a706e,
0x556000fe,
0x000900ab,
0x814a0004,
0x2c030000,
0x00098200,
0x40820000,
0x0005082f,
0x810a0000,
0x00098200,
0x812a0000,
0x00098200,
0x7c004040,
0x40800000,
0x0005082f,
0x7d09582e,
0x7c095cae,
0x2c080000,
0x00098200,
0x41820000,
0x00050805,
0x0006000b,
0x80f00000,
0x3a100004,
0x7c0ea5ae,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000f,
0x812a0000,
0x00098200,
0x28090000,
0x41820000,
0x0005080b,
0x89290000,
0x00098200,
0x71290000,
0x00090200,
0x40820000,
0x0005080b,
0x48000000,
0x0005002f,
0x00000000,
0x7c6a706e,
0x7c8b706e,
0x814a0004,
0x00000000,
0x816b0004,
0x00000000,
0xc80b0000,
0x00000000,
0x2c030000,
0x00098200,
0x7c84b040,
0x40820000,
0x00050834,
0x00000000,
0x800a0000,
0x00098200,
0x40860000,
0x00050805,
0x810a0000,
0x00098200,
0x7c005840,
0x55601800,
0x000900a1,
0x00000000,
0x40840000,
0x00050805,
0xfc20001e,
0xfc40f02a,
0xd8210010,
0x800a0000,
0x00098200,
0xfc42f028,
0x81210014,
0x810a0000,
0x00098200,
0xfc801000,
0x7c004840,
0x4c213202,
0x55201800,
0x000900a1,
0x00000000,
0x40810000,
0x00050834,
0x7d28002e,
0x88ca0000,
0x00098200,
0x7dcea4ae,
0x2c090000,
0x00098200,
0x41820000,
0x00050803,
0x0006000b,
0x70c90000,
0x00090200,
0x7dc805ae,
0x40820000,
0x00050807,
0x0006000c,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000d,
0x812a0000,
0x00098200,
0x28090000,
0x41820000,
0x0005080b,
0x89290000,
0x00098200,
0x71290000,
0x00090200,
0x40820000,
0x0005080b,
0x48000000,
0x00050034,
0x0006000f,
0x2c040000,
0x00098200,
0x40820000,
0x00050834,
0x00000000,
0x816b0004,
0x00000000,
0x48000000,
0x000500a5,
0x00060011,
0x80110000,
0x00098200,
0x54c607b8,
0x91510000,
0x00098200,
0x98ca0000,
0x00098200,
0x900a0000,
0x00098200,
0x48000000,
0x0005000c,
0x00000000,
0x7c6a706e,
0x5568007e,
0x000900ab,
0x814a0004,
0x2108fffc,
0x2c030000,
0x00098200,
0x7d6f402e,
0x40820000,
0x00050831,
0x000600a5,
0x800a0000,
0x00098200,
0x810b0000,
0x00098200,
0x812a0000,
0x00098200,
0x9b0a0000,
0x00098200,
0x7d080038,
0x7dcea4ae,
0x55002800,
0x000900a1,
0x55081800,
0x000900a1,
0x7d080050,
0x88ca0000,
0x00098200,
0x7d294214,
0x0006000b,
0x80690000,
0x00098200,
0x80090000,
0x00098200,
0x80890000,
0x00098200,
0x81090000,
0x00098200,
0x2c030000,
0x00098200,
0x40820000,
0x00050805,
0x7c005800,
0x40820000,
0x00050805,
0x2c040000,
0x00098200,
0x41820000,
0x00050804,
0x0006000c,
0x00000000,
0x70c00000,
0x00090200,
0xd9c90000,
0x00098200,
0x40820000,
0x00050807,
0x0006000d,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x810a0000,
0x00098200,
0x28080000,
0x41820000,
0x0005080c,
0x88080000,
0x00098200,
0x70000000,
0x00090200,
0x40820000,
0x0005080c,
0x48000000,
0x00050032,
0x0006000f,
0x28080000,
0x7d094378,
0x40820000,
0x0005080b,
0x810a0000,
0x00098200,
0x38b10000,
0x00098200,
0x92010020,
0x7e439378,
0x28080000,
0x91d20000,
0x00098200,
0x41820000,
0x00050806,
0x88080000,
0x00098200,
0x70000000,
0x00090200,
0x41820000,
0x00050832,
0x00060010,
0x38000000,
0x00098200,
0x00000000,
0x91650004,
0x7d445378,
0x90050000,
0x48000001,
0x00030037,
0x81d20000,
0x00098200,
0xd9c30000,
0x48000000,
0x0005000d,
0x00060011,
0x80110000,
0x00098200,
0x54c607b8,
0x91510000,
0x00098200,
0x98ca0000,
0x00098200,
0x900a0000,
0x00098200,
0x48000000,
0x0005000d,
0x00000000,
0x7c6a706e,
0x556000fe,
0x000900ab,
0x814a0004,
0x2c030000,
0x00098200,
0x40820000,
0x00050833,
0x810a0000,
0x00098200,
0x812a0000,
0x00098200,
0x88ca0000,
0x00098200,
0x7c004040,
0x7dcea4ae,
0x40800000,
0x00050833,
0x7d09582e,
0x2c080000,
0x00098200,
0x41820000,
0x00050805,
0x0006000b,
0x70c00000,
0x00090200,
0x7dc95dae,
0x40820000,
0x00050807,
0x0006000c,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000f,
0x810a0000,
0x00098200,
0x28080000,
0x41820000,
0x0005080b,
0x89080000,
0x00098200,
0x71080000,
0x00090200,
0x40820000,
0x0005080b,
0x48000000,
0x00050033,
0x00060011,
0x80110000,
0x00098200,
0x00000000,
0x54c607b8,
0x91510000,
0x00098200,
0x98ca0000,
0x00098200,
0x900a0000,
0x00098200,
0x48000000,
0x0005000c,
0x00000000,
0x7e8ea214,
0x0006000b,
0x7ccf6214,
0x8094fffc,
0x3413fff8,
0x80c60004,
0x540500fe,
0x000900ab,
0x41820000,
0x00050804,
0x7ca53214,
0x81240000,
0x00098200,
0x54c81800,
0x000900a1,
0x88c40000,
0x00098200,
0x7c054840,
0x7d340214,
0x80040000,
0x00098200,
0x41810000,
0x00050805,
0x7d080214,
0x70c00000,
0x00090200,
0x0006000d,
0xc8140000,
0x3a940008,
0x7c944800,
0xd8080000,
0x39080008,
0x41840000,
0x0005080d,
0x40820000,
0x00050807,
0x0006000e,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000f,
0x91d20000,
0x00098200,
0x7e439378,
0x92010020,
0x7d956378,
0x48000001,
0x00030038,
0x7eacab78,
0x48000000,
0x0005000b,
0x00060011,
0x80110000,
0x00098200,
0x54c607b8,
0x90910000,
0x00098200,
0x98c40000,
0x00098200,
0x90040000,
0x00098200,
0x00000000,
0x48000000,
0x0005000e,
0x00000000,
0x7d6b9a14,
0x00000000,
0x7dc97378,
0x7c0ea06e,
0x814e0004,
0x396bfff8,
0x39ce0008,
0x2c000000,
0x00098200,
0x40820000,
0x00050825,
0x920efff8,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x00000000,
0x7d6b9a14,
0x00000000,
0x7c14706e,
0x81540004,
0x396bfff8,
0x810efff8,
0x2c000000,
0x00098200,
0x3a940008,
0x40820000,
0x00050845,
0x00060046,
0x71000000,
0x00090200,
0x88ca0000,
0x00098200,
0x69090000,
0x00090200,
0x288b0000,
0x40820000,
0x00050807,
0x0006000b,
0x914efffc,
0x39200000,
0x2b860001,
0x41860000,
0x00050803,
0x0006000c,
0x38c90008,
0x7c144cae,
0x7c865840,
0x7c0e4dae,
0x7cc93378,
0x40860000,
0x0005080c,
0x0006000d,
0x4c42ea02,
0x41820000,
0x00050805,
0x0006000e,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x0006000f,
0x80e8fffc,
0x54f4dd78,
0x7d147050,
0x81080000,
0x00098200,
0x81080000,
0x00098200,
0x81e80000,
0x00098200,
0x48000000,
0x0005000e,
0x00060011,
0x71200000,
0x00090200,
0x00000000,
0x40820000,
0x0005080b,
0x7dc97050,
0x810efff8,
0x71000000,
0x00090200,
0x48000000,
0x0005000b,
0x00000000,
0x7dc97378,
0x7dcea214,
0x810effe8,
0x814effec,
0xc82efff8,
0xc80efff0,
0x910e0000,
0x914e0004,
0x2c080000,
0x00098200,
0xd82e0010,
0x39600010,
0xdc0e0008,
0x40820000,
0x00050825,
0x920efff8,
0x820a0000,
0x00098200,
0x80f00000,
0x3a100004,
0x54e815ba,
0x54f4dd78,
0x7c11402e,
0x7e947214,
0x7c0903a6,
0x4e800420,
0x00000000,
0x7e8ea214,
0x8154fff4,
0x8174fffc,
0x800a0000,
0x00098200,
0x810a0000,
0x00098200,
0x3a100004,
0x0006000b,
0x7c0b0040,
0x55661800,
0x000900a1,
0x40800000,
0x00050805,
0x7d28302e,
0x7c0834ae,
0x2c090000,
0x00098200,
0x80f0fffc,
0x41820000,
0x00050804,
0x00000000,
0x91740004,
0x92d40000,
0x00000000,
0x9161000c,
0xc8210008,
0xfc21f028,
0x00000000,
0x396b0001,
0x3cd00000,
0x00098200,
0xd8140008,
0x54e893ba,
0x9174fffc,
0x7e083214,
0x00000000,
0xd8340000,
0x00000000,
0x0006000d,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x396b0001,
0x48000000,
0x0005000b,
0x0006000f,
0x810a0000,
0x00098200,
0x7d605850,
0x812a0000,
0x00098200,
0x00060010,
0x7c0b4040,
0x55662800,
0x000900a1,
0x41a10000,
0x0005080d,
0x556a1800,
0x000900a1,
0x7cca3050,
0x7d49302e,
0x7c0934ae,
0x7cc93214,
0x2c0a0000,
0x00098200,
0x80f0fffc,
0x41820000,
0x00050807,
0xc8260000,
0x00098200,
0x3d300000,
0x00098200,
0xd8140008,
0x7d6b0214,
0x54e893ba,
0xd8340000,
0x396b0001,
0x7e084a14,
0x9174fffc,
0x48000000,
0x0005000d,
0x00060011,
0x396b0001,
0x48000000,
0x00050010,
0x00000000,
0x7e8ea214,
0x8014ffe8,
0x8114ffec,
0x8134fff0,
0x80d4fff8,
0x2c090000,
0x00098200,
0x2c800000,
0x00098200,
0x2f060000,
0x00098200,
0x40860000,
0x00050805,
0x89080000,
0x00098200,
0x4c42d202,
0x2f880000,
0x00098200,
0x5580007e,
0x000900ab,
0x4c42f202,
0x7cd00214,
0x40820000,
0x00050805,
0x9314fffc,
0x3e060000,
0x00098200,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000f,
0x38000000,
0x00098200,
0x39000000,
0x00098200,
0x9810ffff,
0x3e060000,
0x00098200,
0x99100003,
0x48000000,
0x0005000b,
0x00000000,
0x800efff8,
0x7d6e5a14,
0x7e8ea214,
0x396b0000,
0x00098200,
0x7d345214,
0x38cefff8,
0x7d605850,
0x288a0000,
0x7d0b3051,
0x41860000,
0x00050805,
0x3929fff0,
0x40810000,
0x00050802,
0x0006000b,
0xc80b0000,
0x396b0008,
0xd8140000,
0x7c144840,
0x7c8b3040,
0x40800000,
0x00050803,
0x3a940008,
0x41840000,
0x0005080b,
0x0006000c,
0x92f40000,
0x7c144840,
0x3a940008,
0x41800000,
0x0005080c,
0x0006000d,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000f,
0x80120000,
0x00098200,
0x3a600008,
0x40a10000,
0x0005080d,
0x7d344214,
0x7c090040,
0x3a680008,
0x41810000,
0x00050807,
0x00060010,
0xc80b0000,
0x396b0008,
0xd8140000,
0x7c0b3040,
0x3a940008,
0x41800000,
0x00050810,
0x48000000,
0x0005000d,
0x00060011,
0x7e439378,
0x92920000,
0x00098200,
0x7eae5850,
0x91d20000,
0x00098200,
0x7e8ea050,
0x92010020,
0x550400fe,
0x000900ab,
0x48000001,
0x00030000,
0x81d20000,
0x00098200,
0x00000000,
0x7e8ea214,
0x7d6eaa14,
0x38cefff8,
0x48000000,
0x00050010,
0x00000000,
0x7d8c9a14,
0x00000000,
0x820efff8,
0x7e8ea214,
0x7d936378,
0x0006000b,
0x72000000,
0x00090200,
0x6a080000,
0x00090200,
0x40820000,
0x000508a6,
0x00060017,
0x80f0fffc,
0x2c0c0008,
0x392efff8,
0x396cfff8,
0x54ea5d78,
0x41820000,
0x00050803,
0x39000000,
0x0006000c,
0x38c80008,
0x7c1444ae,
0x7c065800,
0x7c0945ae,
0x41820000,
0x00050803,
0x39060008,
0x7c3434ae,
0x7c085800,
0x7c2935ae,
0x40820000,
0x0005080c,
0x0006000d,
0x0006000f,
0x7c0a6040,
0x54f4dd78,
0x41810000,
0x00050806,
0x7dd44850,
0x810efffc,
0x80f00000,
0x3a100004,
0x81080000,
0x00098200,
0x81e80000,
0x00098200,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00060010,
0x390cfff8,
0x398c0008,
0x7ee9412e,
0x48000000,
0x0005000f,
0x000600a6,
0x71090000,
0x00090200,
0x40820000,
0x00050818,
0x7dc87050,
0x820efff8,
0x48000000,
0x0005000b,
0x00000000,
0x820efff8,
0x7e8ea214,
0x7d936378,
0x72000000,
0x00090200,
0x6a080000,
0x00090200,
0x40a20000,
0x000508a6,
0x80f0fffc,
0x392efff8,
0x54ea5d78,
0x00000000,
0xc8140000,
0xd8090000,
0x00000000,
0x0006000f,
0x7c0a6040,
0x54f4dd78,
0x41810000,
0x00050806,
0x7dd44850,
0x810efffc,
0x80f00000,
0x3a100004,
0x81080000,
0x00098200,
0x81e80000,
0x00098200,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00060010,
0x390cfff8,
0x398c0008,
0x7ee9412e,
0x48000000,
0x0005000f,
0x00000000,
0x5608fe7c,
0x39080000,
0x00098200,
0x7d31422e,
0x35290000,
0x00098200,
0x7d31432e,
0x41800000,
0x00050894,
0x00000000,
0x7d14706e,
0x80740000,
0x00098200,
0x7c08b040,
0x00000000,
0x80b40000,
0x00098200,
0x40820000,
0x00050809,
0x7c632e15,
0x2f050000,
0x80940000,
0x00098200,
0x41830000,
0x00050806,
0x0006000e,
0x90740000,
0x00098200,
0x00000000,
0x80d40000,
0x00098200,
0x80b40000,
0x00098200,
0x81340000,
0x00098200,
0x80940000,
0x00098200,
0x7f86b040,
0x7c89b040,
0x4c42f202,
0x4c423202,
0x2f050000,
0x40820000,
0x00050809,
0x00000000,
0x41980000,
0x00050805,
0x7c032000,
0x0006000b,
0x92d40000,
0x00098200,
0x00000000,
0x558c007e,
0x000900ab,
0x00000000,
0x90740000,
0x00098200,
0x00000000,
0x7d906214,
0x00000000,
0x41810000,
0x00050803,
0x00000000,
0x3e0c0000,
0x00098200,
0x40a10000,
0x00050807,
0x00000000,
0x41810000,
0x00050802,
0x3e0c0000,
0x00098200,
0x00000000,
0x40a10000,
0x00070800,
0x00000000,
0x0006000c,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000f,
0x7c041800,
0x48000000,
0x0005000b,
0x00000000,
0x00060010,
0x7c000400,
0x40a10000,
0x0005080e,
0x48000000,
0x0005000c,
0x00000000,
0x00060013,
0xc8340000,
0x00098200,
0x00000000,
0x7c3474ee,
0x00000000,
0xc8740000,
0x00098200,
0xc8540000,
0x00098200,
0x80d40000,
0x00098200,
0xfc21182a,
0xd8340000,
0x00098200,
0x00000000,
0x00060013,
0x00000000,
0x7d14706e,
0x80d40000,
0x00098200,
0x81340000,
0x00098200,
0x7c08b040,
0x7f86b040,
0x7c89b040,
0x00000000,
0xc8340000,
0x00098200,
0x4c00e202,
0x4c002202,
0xc8540000,
0x00098200,
0x40800000,
0x00050847,
0x00000000,
0x2f060000,
0x00000000,
0x558c007e,
0x000900ab,
0x00000000,
0xd8340000,
0x00098200,
0x00000000,
0x7d906214,
0x00000000,
0xfc011000,
0x00000000,
0x3e0c0000,
0x00098200,
0x00000000,
0x41980000,
0x00050805,
0x00000000,
0x41810000,
0x00050803,
0x00000000,
0x41a10000,
0x0005080c,
0x00000000,
0x41810000,
0x00050802,
0x00000000,
0x0006000b,
0x3e0c0000,
0x00098200,
0x00000000,
0x40a10000,
0x00050807,
0x00000000,
0x40a10000,
0x00070800,
0x00000000,
0x48000000,
0x0005000c,
0x00000000,
0x0006000c,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x0006000f,
0x00000000,
0x40800000,
0x0005080c,
0x0006000d,
0x3e0c0000,
0x00098200,
0x00000000,
0x40a00000,
0x0005080b,
0x00000000,
0x40a00000,
0x00050807,
0x00000000,
0x40a00000,
0x00070800,
0x00000000,
0x48000000,
0x0005000c,
0x00000000,
0x00060011,
0x80f0fffc,
0x54ec9b78,
0x48000000,
0x00070000,
0x00000000,
0x5608fe7c,
0x39080000,
0x00098200,
0x7d31422e,
0x35290000,
0x00098200,
0x7d31432e,
0x41800000,
0x00050894,
0x00000000,
0x7d14706e,
0x81340004,
0x2c080000,
0x00098200,
0x41820000,
0x00050801,
0x00000000,
0x9114fff8,
0x9134fffc,
0x48000000,
0x00070000,
0x00000000,
0x5580007e,
0x000900ab,
0x3e100000,
0x00098200,
0x7e100214,
0x9114fff8,
0x9134fffc,
0x00000000,
0x0006000b,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x5608fe7c,
0x39080000,
0x00098200,
0x7d31422e,
0x35290000,
0x00098200,
0x7d31432e,
0x41800000,
0x00050894,
0x00000000,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x81110000,
0x00098200,
0x558c007e,
0x000900ab,
0x93110000,
0x00098200,
0x7d28602e,
0x7c000400,
0x81290000,
0x00098200,
0x91d10000,
0x00098200,
0x7d2903a6,
0x92510000,
0x00098200,
0x3bf10000,
0x00098200,
0x4e800420,
0x00000000,
0x5580007e,
0x000900ab,
0x3e100000,
0x00098200,
0x7e100214,
0x80f00000,
0x3a100004,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x5608fe7c,
0x39080000,
0x00098200,
0x7d31422e,
0x35290000,
0x00098200,
0x7d31432e,
0x41800000,
0x00050896,
0x00000000,
0x81320000,
0x00098200,
0x89100000,
0x00098200,
0x81f00000,
0x00098200,
0x7c144840,
0x55081800,
0x000900a1,
0x41810000,
0x00050820,
0x00000000,
0x80f00000,
0x3a100004,
0x00000000,
0x0006000c,
0x7c0b4040,
0x41800000,
0x00050803,
0x00000000,
0x54ec9b78,
0x48000000,
0x00070000,
0x00000000,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x00000000,
0x0006000d,
0x7eee592e,
0x396b0008,
0x48000000,
0x0005000c,
0x00000000,
0x7c810808,
0x00000000,
0x81320000,
0x00098200,
0x7d0e5a14,
0x7c145a14,
0x91480004,
0x38cb0000,
0x00098200,
0x81f00000,
0x00098200,
0x7c004840,
0x90c80000,
0x40800000,
0x00050820,
0x89300000,
0x00098200,
0x7dd47378,
0x7d0b4378,
0x80f00000,
0x3a100004,
0x2c090000,
0x39c80008,
0x41820000,
0x00050803,
0x0006000b,
0x7c145840,
0x80140000,
0x80d40004,
0x40800000,
0x00050804,
0x92f40000,
0x3a940008,
0x0006000c,
0x3529ffff,
0x90080008,
0x90c8000c,
0x39080008,
0x40820000,
0x0005080b,
0x0006000d,
0x54e815ba,
0x7c11402e,
0x7c0903a6,
0x54ea5d78,
0x54ec9b78,
0x54f4dd78,
0x54eb9d78,
0x4e800420,
0x0006000e,
0x38000000,
0x00098200,
0x48000000,
0x0005000c,
0x00000000,
0x80ca0000,
0x00098200,
0x00000000,
0x80d10000,
0x00098200,
0x00000000,
0x7d145a14,
0x81320000,
0x00098200,
0x7d6e5a14,
0x91d20000,
0x00098200,
0x7c084840,
0x91720000,
0x00098200,
0x38000000,
0x00098200,
0x7cc903a6,
0x00000000,
0x808a0000,
0x00098200,
0x00000000,
0x7e439378,
0x41810000,
0x0005081f,
0x90110000,
0x00098200,
0x4e800421,
0x81d20000,
0x00098200,
0x546c1800,
0x000900a1,
0x81120000,
0x00098200,
0x38000000,
0x00098200,
0x820efff8,
0x7e8c4050,
0x90110000,
0x00098200,
0x48000000,
0x00050016,
0x00000000,
0x00010000
};

# 9 "buildvm_ppc.dasc"
//|.globals GLOB_
enum {
  GLOB_vm_returnp,
  GLOB_cont_dispatch,
  GLOB_vm_returnc,
  GLOB_BC_RET_Z,
  GLOB_vm_return,
  GLOB_vm_leave_cp,
  GLOB_vm_leave_unw,
  GLOB_vm_unwind_c,
  GLOB_vm_unwind_c_eh,
  GLOB_vm_unwind_ff,
  GLOB_vm_unwind_ff_eh,
  GLOB_vm_growstack_c,
  GLOB_vm_growstack_l,
  GLOB_vm_resume,
  GLOB_vm_pcall,
  GLOB_vm_call,
  GLOB_vm_call_dispatch,
  GLOB_vmeta_call,
  GLOB_vm_call_dispatch_f,
  GLOB_vm_cpcall,
  GLOB_cont_ffi_callback,
  GLOB_vm_call_tail,
  GLOB_cont_cat,
  GLOB_BC_CAT_Z,
  GLOB_cont_nop,
  GLOB_vmeta_tgets1,
  GLOB_vmeta_tgets,
  GLOB_vmeta_tgetb,
  GLOB_vmeta_tgetv,
  GLOB_vmeta_tsets1,
  GLOB_vmeta_tsets,
  GLOB_vmeta_tsetb,
  GLOB_vmeta_tsetv,
  GLOB_vmeta_comp,
  GLOB_vmeta_binop,
  GLOB_cont_ra,
  GLOB_cont_condt,
  GLOB_cont_condf,
  GLOB_vmeta_equal,
  GLOB_vmeta_equal_cd,
  GLOB_vmeta_arith_nv,
  GLOB_vmeta_arith_nv2,
  GLOB_vmeta_unm,
  GLOB_vmeta_arith_vn,
  GLOB_vmeta_arith_vv,
  GLOB_vmeta_arith_vn2,
  GLOB_vmeta_arith_vv2,
  GLOB_vmeta_len,
  GLOB_BC_LEN_Z,
  GLOB_vmeta_callt,
  GLOB_BC_CALLT_Z,
  GLOB_vmeta_for,
  GLOB_ff_assert,
  GLOB_fff_fallback,
  GLOB_fff_res,
  GLOB_ff_type,
  GLOB_fff_resn,
  GLOB_ff_getmetatable,
  GLOB_fff_restv,
  GLOB_ff_setmetatable,
  GLOB_ff_rawget,
  GLOB_ff_tonumber,
  GLOB_ff_tostring,
  GLOB_fff_gcstep,
  GLOB_ff_next,
  GLOB_ff_pairs,
  GLOB_ff_ipairs_aux,
  GLOB_ff_ipairs,
  GLOB_ff_pcall,
  GLOB_ff_xpcall,
  GLOB_ff_coroutine_resume,
  GLOB_ff_coroutine_wrap_aux,
  GLOB_ff_coroutine_yield,
  GLOB_ff_math_abs,
  GLOB_fff_resi,
  GLOB_fff_res1,
  GLOB_ff_math_floor,
  GLOB_ff_math_ceil,
  GLOB_ff_math_sqrt,
  GLOB_ff_math_log,
  GLOB_ff_math_log10,
  GLOB_ff_math_exp,
  GLOB_ff_math_sin,
  GLOB_ff_math_cos,
  GLOB_ff_math_tan,
  GLOB_ff_math_asin,
  GLOB_ff_math_acos,
  GLOB_ff_math_atan,
  GLOB_ff_math_sinh,
  GLOB_ff_math_cosh,
  GLOB_ff_math_tanh,
  GLOB_ff_math_pow,
  GLOB_ff_math_atan2,
  GLOB_ff_math_fmod,
  GLOB_ff_math_deg,
  GLOB_ff_math_rad,
  GLOB_ff_math_ldexp,
  GLOB_ff_math_frexp,
  GLOB_ff_math_modf,
  GLOB_ff_math_min,
  GLOB_ff_math_max,
  GLOB_ff_string_len,
  GLOB_ff_string_byte,
  GLOB_ff_string_char,
  GLOB_fff_newstr,
  GLOB_ff_string_sub,
  GLOB_ff_string_rep,
  GLOB_ff_string_reverse,
  GLOB_ff_string_lower,
  GLOB_ff_string_upper,
  GLOB_ff_table_getn,
  GLOB_ff_bit_band,
  GLOB_fff_tobit_fb,
  GLOB_fff_bitop_fb,
  GLOB_ff_bit_bor,
  GLOB_ff_bit_bxor,
  GLOB_ff_bit_bswap,
  GLOB_ff_bit_bnot,
  GLOB_ff_bit_lshift,
  GLOB_ff_bit_rshift,
  GLOB_ff_bit_arshift,
  GLOB_ff_bit_rol,
  GLOB_ff_bit_ror,
  GLOB_ff_bit_tobit,
  GLOB_vm_record,
  GLOB_vm_rethook,
  GLOB_vm_inshook,
  GLOB_cont_hook,
  GLOB_vm_hotloop,
  GLOB_vm_callhook,
  GLOB_vm_hotcall,
  GLOB_vm_exit_handler,
  GLOB_vm_exit_interp,
  GLOB_vm_floor,
  GLOB_vm_ceil,
  GLOB_vm_trunc,
  GLOB_vm_modi,
  GLOB_vm_foldarith,
  GLOB_vm_cachesync,
  GLOB_vm_ffi_callback,
  GLOB_vm_ffi_call,
  GLOB_BC_ISEQN_Z,
  GLOB_BC_ISNEN_Z,
  GLOB_BC_MODVN_Z,
  GLOB_BC_TGETS_Z,
  GLOB_BC_TSETS_Z,
  GLOB_BC_RETV_Z,
  GLOB__MAX
};
# 10 "buildvm_ppc.dasc"
//|.globalnames globnames
static const char *const globnames[] = {
  "vm_returnp",
  "cont_dispatch",
  "vm_returnc",
  "BC_RET_Z",
  "vm_return",
  "vm_leave_cp",
  "vm_leave_unw",
  "vm_unwind_c",
  "vm_unwind_c_eh",
  "vm_unwind_ff",
  "vm_unwind_ff_eh",
  "vm_growstack_c",
  "vm_growstack_l",
  "vm_resume",
  "vm_pcall",
  "vm_call",
  "vm_call_dispatch",
  "vmeta_call",
  "vm_call_dispatch_f",
  "vm_cpcall",
  "cont_ffi_callback",
  "vm_call_tail",
  "cont_cat",
  "BC_CAT_Z",
  "cont_nop",
  "vmeta_tgets1",
  "vmeta_tgets",
  "vmeta_tgetb",
  "vmeta_tgetv",
  "vmeta_tsets1",
  "vmeta_tsets",
  "vmeta_tsetb",
  "vmeta_tsetv",
  "vmeta_comp",
  "vmeta_binop",
  "cont_ra",
  "cont_condt",
  "cont_condf",
  "vmeta_equal",
  "vmeta_equal_cd",
  "vmeta_arith_nv",
  "vmeta_arith_nv2",
  "vmeta_unm",
  "vmeta_arith_vn",
  "vmeta_arith_vv",
  "vmeta_arith_vn2",
  "vmeta_arith_vv2",
  "vmeta_len",
  "BC_LEN_Z",
  "vmeta_callt",
  "BC_CALLT_Z",
  "vmeta_for",
  "ff_assert",
  "fff_fallback",
  "fff_res",
  "ff_type",
  "fff_resn",
  "ff_getmetatable",
  "fff_restv",
  "ff_setmetatable",
  "ff_rawget",
  "ff_tonumber",
  "ff_tostring",
  "fff_gcstep",
  "ff_next",
  "ff_pairs",
  "ff_ipairs_aux",
  "ff_ipairs",
  "ff_pcall",
  "ff_xpcall",
  "ff_coroutine_resume",
  "ff_coroutine_wrap_aux",
  "ff_coroutine_yield",
  "ff_math_abs",
  "fff_resi",
  "fff_res1",
  "ff_math_floor",
  "ff_math_ceil",
  "ff_math_sqrt",
  "ff_math_log",
  "ff_math_log10",
  "ff_math_exp",
  "ff_math_sin",
  "ff_math_cos",
  "ff_math_tan",
  "ff_math_asin",
  "ff_math_acos",
  "ff_math_atan",
  "ff_math_sinh",
  "ff_math_cosh",
  "ff_math_tanh",
  "ff_math_pow",
  "ff_math_atan2",
  "ff_math_fmod",
  "ff_math_deg",
  "ff_math_rad",
  "ff_math_ldexp",
  "ff_math_frexp",
  "ff_math_modf",
  "ff_math_min",
  "ff_math_max",
  "ff_string_len",
  "ff_string_byte",
  "ff_string_char",
  "fff_newstr",
  "ff_string_sub",
  "ff_string_rep",
  "ff_string_reverse",
  "ff_string_lower",
  "ff_string_upper",
  "ff_table_getn",
  "ff_bit_band",
  "fff_tobit_fb",
  "fff_bitop_fb",
  "ff_bit_bor",
  "ff_bit_bxor",
  "ff_bit_bswap",
  "ff_bit_bnot",
  "ff_bit_lshift",
  "ff_bit_rshift",
  "ff_bit_arshift",
  "ff_bit_rol",
  "ff_bit_ror",
  "ff_bit_tobit",
  "vm_record",
  "vm_rethook",
  "vm_inshook",
  "cont_hook",
  "vm_hotloop",
  "vm_callhook",
  "vm_hotcall",
  "vm_exit_handler",
  "vm_exit_interp",
  "vm_floor",
  "vm_ceil",
  "vm_trunc",
  "vm_modi",
  "vm_foldarith",
  "vm_cachesync",
  "vm_ffi_callback",
  "vm_ffi_call",
  "BC_ISEQN_Z",
  "BC_ISNEN_Z",
  "BC_MODVN_Z",
  "BC_TGETS_Z",
  "BC_TSETS_Z",
  "BC_RETV_Z",
  (const char *)0
};
# 11 "buildvm_ppc.dasc"
//|.externnames extnames
static const char *const extnames[] = {
  "lj_state_growstack",
  "lj_meta_tget",
  "lj_meta_tset",
  "lj_meta_comp",
  "lj_meta_equal",
  "lj_meta_equal_cd",
  "lj_meta_arith",
  "lj_meta_len",
  "lj_meta_call",
  "lj_meta_for",
  "lj_tab_get",
  "lj_str_fromnumber",
  "lj_str_fromnum",
  "lj_tab_next",
  "lj_tab_getinth",
  "lj_ffh_coroutine_wrap_err",
  "floor",
  "ceil",
  "sqrt",
  "log",
  "log10",
  "exp",
  "sin",
  "cos",
  "tan",
  "asin",
  "acos",
  "atan",
  "sinh",
  "cosh",
  "tanh",
  "pow",
  "atan2",
  "fmod",
  "ldexp",
  "frexp",
  "modf",
  "lj_str_new",
  "lj_tab_len",
  "lj_gc_step",
  "lj_dispatch_ins",
  "lj_trace_hot",
  "lj_dispatch_call",
  "lj_trace_exit",
  "lj_err_throw",
  "trunc",
  "lj_ccallback_enter",
  "lj_ccallback_leave",
  "lj_meta_cat",
  "lj_gc_barrieruv",
  "lj_func_closeuv",
  "lj_func_newL_gc",
  "lj_tab_new",
  "lj_tab_dup",
  "lj_gc_step_fixtop",
  "lj_tab_newkey",
  "lj_tab_reasize",
  (const char *)0
};
# 12 "buildvm_ppc.dasc"
//|
//|// Note: The ragged indentation of the instructions is intentional.
//|//       The starting columns indicate data dependencies.
//|
//|//-----------------------------------------------------------------------
//|
//|// Fixed register assignments for the interpreter.
//|// Don't use: r1 = sp, r2 and r13 = reserved (TOC, TLS or SDATA)
//|
//|// The following must be C callee-save (but BASE is often refetched).
//|.define BASE,		r14	// Base of current Lua stack frame.
//|.define KBASE,		r15	// Constants of current Lua function.
//|.define PC,		r16	// Next PC.
//|.define DISPATCH,	r17	// Opcode dispatch table.
//|.define LREG,		r18	// Register holding lua_State (also in SAVE_L).
//|.define MULTRES,	r19	// Size of multi-result: (nresults+1)*8.
//|.define JGL,		r31	// On-trace: global_State + 32768.
//|
//|// Constants for type-comparisons, stores and conversions. C callee-save.
//|.define TISNUM,	r22
//|.define TISNIL,	r23
//|.define ZERO,		r24
//|.define TOBIT,		f30	// 2^52 + 2^51.
//|.define TONUM,		f31	// 2^52 + 2^51 + 2^31.
//|
//|// The following temporaries are not saved across C calls, except for RA.
//|.define RA,		r20	// Callee-save.
//|.define RB,		r10
//|.define RC,		r11
//|.define RD,		r12
//|.define INS,		r7	// Overlaps CARG5.
//|
//|.define TMP0,		r0
//|.define TMP1,		r8
//|.define TMP2,		r9
//|.define TMP3,		r6	// Overlaps CARG4.
//|
//|// Saved temporaries.
//|.define SAVE0,		r21
//|
//|// Calling conventions.
//|.define CARG1,		r3
//|.define CARG2,		r4
//|.define CARG3,		r5
//|.define CARG4,		r6	// Overlaps TMP3.
//|.define CARG5,		r7	// Overlaps INS.
//|
//|.define FARG1,		f1
//|.define FARG2,		f2
//|
//|.define CRET1,		r3
//|.define CRET2,		r4
//|
//|// Stack layout while in interpreter. Must match with lj_frame.h.
//|.define SAVE_LR,	276(sp)
//|.define CFRAME_SPACE,	272	// Delta for sp.
//|// Back chain for sp:	272(sp)	<-- sp entering interpreter
//|.define SAVE_FPR_,	128	// .. 128+18*8: 64 bit FPR saves.
//|.define SAVE_GPR_,	56	// .. 56+18*4: 32 bit GPR saves.
//|.define SAVE_CR,	52(sp)	// 32 bit CR save.
//|.define SAVE_ERRF,	48(sp)	// 32 bit C frame info.
//|.define SAVE_NRES,	44(sp)
//|.define SAVE_CFRAME,	40(sp)
//|.define SAVE_L,	36(sp)
//|.define SAVE_PC,	32(sp)
//|.define SAVE_MULTRES,	28(sp)
//|.define UNUSED1,	24(sp)
//|.define TMPD_LO,	20(sp)
//|.define TMPD_HI,	16(sp)
//|.define TONUM_LO,	12(sp)
//|.define TONUM_HI,	8(sp)
//|// Next frame lr:	4(sp)
//|// Back chain for sp:	0(sp)	<-- sp while in interpreter
//|
//|.define TMPD_BLO,	23(sp)
//|.define TMPD,		TMPD_HI
//|.define TONUM_D,	TONUM_HI
//|
//|.macro save_, reg
//|  stw r..reg, SAVE_GPR_+(reg-14)*4(sp)
//|  stfd f..reg, SAVE_FPR_+(reg-14)*8(sp)
//|.endmacro
//|.macro rest_, reg
//|  lwz r..reg, SAVE_GPR_+(reg-14)*4(sp)
//|  lfd f..reg, SAVE_FPR_+(reg-14)*8(sp)
//|.endmacro
//|
//|.macro saveregs
//|  stwu sp, -CFRAME_SPACE(sp)
//|  save_ 14; save_ 15; save_ 16
//|  mflr r0
//|  save_ 17; save_ 18; save_ 19; save_ 20; save_ 21; save_ 22
//|  stw  r0, SAVE_LR
//|  save_ 23; save_ 24; save_ 25
//|  mfcr r0
//|  save_ 26; save_ 27; save_ 28; save_ 29; save_ 30; save_ 31
//|  stw r0, SAVE_CR
//|.endmacro
//|
//|.macro restoreregs
//|  lwz r0, SAVE_LR; lwz r12, SAVE_CR
//|  rest_ 14; rest_ 15; rest_ 16; rest_ 17; rest_ 18; rest_ 19
//|  mtlr r0; mtcrf 0x38, r12
//|  rest_ 20; rest_ 21; rest_ 22; rest_ 23; rest_ 24; rest_ 25
//|  rest_ 26; rest_ 27; rest_ 28; rest_ 29; rest_ 30; rest_ 31
//|  addi sp, sp, CFRAME_SPACE
//|.endmacro
//|
//|// Type definitions. Some of these are only used for documentation.
//|.type L,		lua_State,	LREG
#define Dt1(_V) (int)(ptrdiff_t)&(((lua_State *)0)_V)
# 122 "buildvm_ppc.dasc"
//|.type GL,		global_State
#define Dt2(_V) (int)(ptrdiff_t)&(((global_State *)0)_V)
# 123 "buildvm_ppc.dasc"
//|.type TVALUE,		TValue
#define Dt3(_V) (int)(ptrdiff_t)&(((TValue *)0)_V)
# 124 "buildvm_ppc.dasc"
//|.type GCOBJ,		GCobj
#define Dt4(_V) (int)(ptrdiff_t)&(((GCobj *)0)_V)
# 125 "buildvm_ppc.dasc"
//|.type STR,		GCstr
#define Dt5(_V) (int)(ptrdiff_t)&(((GCstr *)0)_V)
# 126 "buildvm_ppc.dasc"
//|.type TAB,		GCtab
#define Dt6(_V) (int)(ptrdiff_t)&(((GCtab *)0)_V)
# 127 "buildvm_ppc.dasc"
//|.type LFUNC,		GCfuncL
#define Dt7(_V) (int)(ptrdiff_t)&(((GCfuncL *)0)_V)
# 128 "buildvm_ppc.dasc"
//|.type CFUNC,		GCfuncC
#define Dt8(_V) (int)(ptrdiff_t)&(((GCfuncC *)0)_V)
# 129 "buildvm_ppc.dasc"
//|.type PROTO,		GCproto
#define Dt9(_V) (int)(ptrdiff_t)&(((GCproto *)0)_V)
# 130 "buildvm_ppc.dasc"
//|.type UPVAL,		GCupval
#define DtA(_V) (int)(ptrdiff_t)&(((GCupval *)0)_V)
# 131 "buildvm_ppc.dasc"
//|.type NODE,		Node
#define DtB(_V) (int)(ptrdiff_t)&(((Node *)0)_V)
# 132 "buildvm_ppc.dasc"
//|.type NARGS8,		int
#define DtC(_V) (int)(ptrdiff_t)&(((int *)0)_V)
# 133 "buildvm_ppc.dasc"
//|.type TRACE,		GCtrace
#define DtD(_V) (int)(ptrdiff_t)&(((GCtrace *)0)_V)
# 134 "buildvm_ppc.dasc"
//|
//|//-----------------------------------------------------------------------
//|
//|// These basic macros should really be part of DynASM.
//|.macro srwi, rx, ry, n; rlwinm rx, ry, 32-n, n, 31; .endmacro
//|.macro slwi, rx, ry, n; rlwinm rx, ry, n, 0, 31-n; .endmacro
//|.macro rotlwi, rx, ry, n; rlwinm rx, ry, n, 0, 31; .endmacro
//|.macro rotlw, rx, ry, rn; rlwnm rx, ry, rn, 0, 31; .endmacro
//|.macro subi, rx, ry, i; addi rx, ry, -i; .endmacro
//|
//|// Trap for not-yet-implemented parts.
//|.macro NYI; tw 4, sp, sp; .endmacro
//|
//|// int/FP conversions.
//|.macro tonum_i, freg, reg
//|  xoris reg, reg, 0x8000
//|  stw reg, TONUM_LO
//|  lfd freg, TONUM_D
//|  fsub freg, freg, TONUM
//|.endmacro
//|
//|.macro tonum_u, freg, reg
//|  stw reg, TONUM_LO
//|  lfd freg, TONUM_D
//|  fsub freg, freg, TOBIT
//|.endmacro
//|
//|.macro toint, reg, freg, tmpfreg
//|  fctiwz tmpfreg, freg
//|  stfd tmpfreg, TMPD
//|  lwz reg, TMPD_LO
//|.endmacro
//|
//|.macro toint, reg, freg
//|  toint reg, freg, freg
//|.endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Access to frame relative to BASE.
//|.define FRAME_PC,	-8
//|.define FRAME_FUNC,	-4
//|
//|// Instruction decode.
//|.macro decode_OP4, dst, ins; rlwinm dst, ins, 2, 22, 29; .endmacro
//|.macro decode_RA8, dst, ins; rlwinm dst, ins, 27, 21, 28; .endmacro
//|.macro decode_RB8, dst, ins; rlwinm dst, ins, 11, 21, 28; .endmacro
//|.macro decode_RC8, dst, ins; rlwinm dst, ins, 19, 21, 28; .endmacro
//|.macro decode_RD8, dst, ins; rlwinm dst, ins, 19, 13, 28; .endmacro
//|
//|.macro decode_OP1, dst, ins; rlwinm dst, ins, 0, 24, 31; .endmacro
//|.macro decode_RD4, dst, ins; rlwinm dst, ins, 18, 14, 29; .endmacro
//|
//|// Instruction fetch.
//|.macro ins_NEXT1
//|  lwz INS, 0(PC)
//|   addi PC, PC, 4
//|.endmacro
//|// Instruction decode+dispatch. Note: optimized for e300!
//|.macro ins_NEXT2
//|  decode_OP4 TMP1, INS
//|  lwzx TMP0, DISPATCH, TMP1
//|  mtctr TMP0
//|   decode_RB8 RB, INS
//|   decode_RD8 RD, INS
//|   decode_RA8 RA, INS
//|   decode_RC8 RC, INS
//|  bctr
//|.endmacro
//|.macro ins_NEXT
//|  ins_NEXT1
//|  ins_NEXT2
//|.endmacro
//|
//|// Instruction footer.
//|.if 1
//|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
//|  .define ins_next, ins_NEXT
//|  .define ins_next_, ins_NEXT
//|  .define ins_next1, ins_NEXT1
//|  .define ins_next2, ins_NEXT2
//|.else
//|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
//|  // Affects only certain kinds of benchmarks (and only with -j off).
//|  .macro ins_next
//|    b ->ins_next
//|  .endmacro
//|  .macro ins_next1
//|  .endmacro
//|  .macro ins_next2
//|    b ->ins_next
//|  .endmacro
//|  .macro ins_next_
//|  ->ins_next:
//|    ins_NEXT
//|  .endmacro
//|.endif
//|
//|// Call decode and dispatch.
//|.macro ins_callt
//|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
//|  lwz PC, LFUNC:RB->pc
//|  lwz INS, 0(PC)
//|   addi PC, PC, 4
//|  decode_OP4 TMP1, INS
//|   decode_RA8 RA, INS
//|  lwzx TMP0, DISPATCH, TMP1
//|   add RA, RA, BASE
//|  mtctr TMP0
//|  bctr
//|.endmacro
//|
//|.macro ins_call
//|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
//|  stw PC, FRAME_PC(BASE)
//|  ins_callt
//|.endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Macros to test operand types.
//|.macro checknum, reg; cmplw reg, TISNUM; .endmacro
//|.macro checknum, cr, reg; cmplw cr, reg, TISNUM; .endmacro
//|.macro checkstr, reg; cmpwi reg, LJ_TSTR; .endmacro
//|.macro checktab, reg; cmpwi reg, LJ_TTAB; .endmacro
//|.macro checkfunc, reg; cmpwi reg, LJ_TFUNC; .endmacro
//|.macro checknil, reg; cmpwi reg, LJ_TNIL; .endmacro
//|
//|.macro branch_RD
//|  srwi TMP0, RD, 1
//|  addis PC, PC, -(BCBIAS_J*4 >> 16)
//|  add PC, PC, TMP0
//|.endmacro
//|
//|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
//|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
//|
//|.macro hotcheck, delta, target
//|  rlwinm TMP1, PC, 31, 25, 30
//|  addi TMP1, TMP1, GG_DISP2HOT
//|  lhzx TMP2, DISPATCH, TMP1
//|  addic. TMP2, TMP2, -delta
//|  sthx TMP2, DISPATCH, TMP1
//|  blt target
//|.endmacro
//|
//|.macro hotloop
//|  hotcheck HOTCOUNT_LOOP, ->vm_hotloop
//|.endmacro
//|
//|.macro hotcall
//|  hotcheck HOTCOUNT_CALL, ->vm_hotcall
//|.endmacro
//|
//|// Set current VM state. Uses TMP0.
//|.macro li_vmstate, st; li TMP0, ~LJ_VMST_..st; .endmacro
//|.macro st_vmstate; stw TMP0, DISPATCH_GL(vmstate)(DISPATCH); .endmacro
//|
//|// Move table write barrier back. Overwrites mark and tmp.
//|.macro barrierback, tab, mark, tmp
//|  lwz tmp, DISPATCH_GL(gc.grayagain)(DISPATCH)
//|  // Assumes LJ_GC_BLACK is 0x04.
//|   rlwinm mark, mark, 0, 30, 28		// black2gray(tab)
//|  stw tab, DISPATCH_GL(gc.grayagain)(DISPATCH)
//|   stb mark, tab->marked
//|  stw tmp, tab->gclist
//|.endmacro
//|
//|//-----------------------------------------------------------------------

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  //|.code_sub
  dasm_put(Dst, 0);
# 312 "buildvm_ppc.dasc"
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Return handling ----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_returnp:
  //|  // See vm_return. Also: TMP2 = previous base.
  //|  andi. TMP0, PC, FRAME_P
  //|   li TMP1, LJ_TTRUE
  //|  beq ->cont_dispatch
  //|
  //|  // Return from pcall or xpcall fast func.
  //|  lwz PC, FRAME_PC(TMP2)		// Fetch PC of previous frame.
  //|  mr BASE, TMP2			// Restore caller base.
  //|  // Prepending may overwrite the pcall frame, so do it at the end.
  //|   stwu TMP1, FRAME_PC(RA)		// Prepend true to results.
  //|
  //|->vm_returnc:
  //|  andi. TMP0, PC, FRAME_TYPE
  //|   addi RD, RD, 8			// RD = (nresults+1)*8.
  //|   mr MULTRES, RD
  //|  beq ->BC_RET_Z			// Handle regular return to Lua.
  //|
  //|->vm_return:
  //|  // BASE = base, RA = resultptr, RD/MULTRES = (nresults+1)*8, PC = return
  //|  // TMP0 = PC & FRAME_TYPE
  //|  cmpwi TMP0, FRAME_C
  //|   rlwinm TMP2, PC, 0, 0, 28
  //|    li_vmstate C
  //|   sub TMP2, BASE, TMP2		// TMP2 = previous base.
  //|  bney ->vm_returnp
  //|
  //|  addic. TMP1, RD, -8
  //|   stw TMP2, L->base
  //|   lwz TMP2, SAVE_NRES
  //|    subi BASE, BASE, 8
  //|    st_vmstate
  //|   slwi TMP2, TMP2, 3
  //|  beq >2
  //|1:
  //|  addic. TMP1, TMP1, -8
  //|   lfd f0, 0(RA)
  //|    addi RA, RA, 8
  //|   stfd f0, 0(BASE)
  //|    addi BASE, BASE, 8
  //|  bney <1
  //|
  //|2:
  //|  cmpw TMP2, RD			// More/less results wanted?
  //|  bne >6
  //|3:
  //|  stw BASE, L->top			// Store new top.
  //|
  //|->vm_leave_cp:
  //|  lwz TMP0, SAVE_CFRAME		// Restore previous C frame.
  dasm_put(Dst, 1, FRAME_P, LJ_TTRUE, FRAME_TYPE, FRAME_C, ~LJ_VMST_C, Dt1(->base), DISPATCH_GL(vmstate), 31-3, Dt1(->top));
# 367 "buildvm_ppc.dasc"
  //|   li CRET1, 0			// Ok return status for vm_pcall.
  //|  stw TMP0, L->cframe
  //|
  //|->vm_leave_unw:
  //|  restoreregs
  dasm_put(Dst, 55, Dt1(->cframe), 56+(14-14)*4, 128+(14-14)*8, 56+(15-14)*4, 128+(15-14)*8, 56+(16-14)*4, 128+(16-14)*8, 56+(17-14)*4, 128+(17-14)*8, 56+(18-14)*4, 128+(18-14)*8, 56+(19-14)*4, 128+(19-14)*8, 56+(20-14)*4, 128+(20-14)*8, 56+(21-14)*4, 128+(21-14)*8, 56+(22-14)*4, 128+(22-14)*8, 56+(23-14)*4, 128+(23-14)*8);
# 372 "buildvm_ppc.dasc"
  //|  blr
  //|
  //|6:
  //|  ble >7				// Less results wanted?
  //|  // More results wanted. Check stack size and fill up results with nil.
  //|  lwz TMP1, L->maxstack
  //|  cmplw BASE, TMP1
  //|  bge >8
  //|  stw TISNIL, 0(BASE)
  //|  addi RD, RD, 8
  //|  addi BASE, BASE, 8
  //|  b <2
  //|
  //|7:  // Less results wanted.
  //|  subfic TMP3, TMP2, 0		// LUA_MULTRET+1 case?
  dasm_put(Dst, 105, 56+(24-14)*4, 128+(24-14)*8, 56+(25-14)*4, 128+(25-14)*8, 56+(26-14)*4, 128+(26-14)*8, 56+(27-14)*4, 128+(27-14)*8, 56+(28-14)*4, 128+(28-14)*8, 56+(29-14)*4, 128+(29-14)*8, 56+(30-14)*4, 128+(30-14)*8, 56+(31-14)*4, 128+(31-14)*8, Dt1(->maxstack));
# 387 "buildvm_ppc.dasc"
  //|   sub TMP0, RD, TMP2
  //|  subfe TMP1, TMP1, TMP1		// TMP1 = TMP2 == 0 ? 0 : -1
  //|   and TMP0, TMP0, TMP1
  //|  sub BASE, BASE, TMP0		// Either keep top or shrink it.
  //|  b <3
  //|
  //|8:  // Corner case: need to grow stack for filling up results.
  //|  // This can happen if:
  //|  // - A C function grows the stack (a lot).
  //|  // - The GC shrinks the stack in between.
  //|  // - A return back from a lua_call() with (high) nresults adjustment.
  //|  stw BASE, L->top			// Save current top held in BASE (yes).
  //|   mr SAVE0, RD
  //|  mr CARG2, TMP2
  //|  mr CARG1, L
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|    lwz TMP2, SAVE_NRES
  //|   mr RD, SAVE0
  //|    slwi TMP2, TMP2, 3
  //|  lwz BASE, L->top			// Need the (realloced) L->top in BASE.
  //|  b <2
  //|
  //|->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  //|  // (void *cframe, int errcode)
  //|  mr sp, CARG1
  //|  mr CRET1, CARG2
  //|->vm_unwind_c_eh:			// Landing pad for external unwinder.
  //|  lwz L, SAVE_L
  //|   li TMP0, ~LJ_VMST_C
  //|  lwz GL:TMP1, L->glref
  //|   stw TMP0, GL:TMP1->vmstate
  //|  b ->vm_leave_unw
  //|
  //|->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  //|  // (void *cframe)
  //|  rlwinm sp, CARG1, 0, 0, 29
  //|->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  //|  lwz L, SAVE_L
  //|     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
  //|  lwz BASE, L->base
  //|     lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
  //|   lwz DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|     li ZERO, 0
  //|     stw TMP3, TMPD
  //|  li TMP1, LJ_TFALSE
  //|     ori TMP3, TMP3, 0x0004		// TONUM = 2^52 + 2^51 + 2^31 (float).
  //|     li TISNIL, LJ_TNIL
  //|    li_vmstate INTERP
  //|     lfs TOBIT, TMPD
  //|  lwz PC, FRAME_PC(BASE)		// Fetch PC of previous frame.
  //|  la RA, -8(BASE)			// Results start at BASE-8.
  //|     stw TMP3, TMPD
  //|   addi DISPATCH, DISPATCH, GG_G2DISP
  //|  stw TMP1, 0(RA)			// Prepend false to error message.
  dasm_put(Dst, 154, Dt1(->top), 31-3, Dt1(->top), ~LJ_VMST_C, Dt1(->glref), Dt2(->vmstate), LJ_TISNUM, Dt1(->base), Dt1(->glref), LJ_TFALSE, LJ_TNIL, ~LJ_VMST_INTERP, GG_G2DISP);
# 441 "buildvm_ppc.dasc"
  //|  li RD, 16				// 2 results: false + error message.
  //|    st_vmstate
  //|     lfs TONUM, TMPD
  //|  b ->vm_returnc
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Grow stack for calls -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_growstack_c:			// Grow stack for C function.
  //|  li CARG2, LUA_MINSTACK
  //|  b >2
  //|
  //|->vm_growstack_l:			// Grow stack for Lua function.
  //|  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  //|  add RC, BASE, RC
  //|   sub RA, RA, BASE
  //|  stw BASE, L->base
  //|   addi PC, PC, 4			// Must point after first instruction.
  //|  stw RC, L->top
  //|   srwi CARG2, RA, 3
  //|2:
  //|  // L->base = new base, L->top = top
  //|   stw PC, SAVE_PC
  //|  mr CARG1, L
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  lwz BASE, L->base
  //|  lwz RC, L->top
  //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
  //|  sub RC, RC, BASE
  //|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  //|  ins_callt				// Just retry the call.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Entry points into the assembler VM ---------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_resume:				// Setup C frame and resume thread.
  //|  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  //|  saveregs
  dasm_put(Dst, 217, DISPATCH_GL(vmstate), LUA_MINSTACK, Dt1(->base), Dt1(->top), 32-3, Dt1(->base), Dt1(->top), Dt7(->pc), 56+(14-14)*4, 128+(14-14)*8, 56+(15-14)*4, 128+(15-14)*8, 56+(16-14)*4, 128+(16-14)*8, 56+(17-14)*4);
  dasm_put(Dst, 278, 128+(17-14)*8, 56+(18-14)*4, 128+(18-14)*8, 56+(19-14)*4, 128+(19-14)*8, 56+(20-14)*4, 128+(20-14)*8, 56+(21-14)*4, 128+(21-14)*8, 56+(22-14)*4, 128+(22-14)*8, 56+(23-14)*4, 128+(23-14)*8, 56+(24-14)*4, 128+(24-14)*8, 56+(25-14)*4, 128+(25-14)*8, 56+(26-14)*4, 128+(26-14)*8, 56+(27-14)*4, 128+(27-14)*8, 56+(28-14)*4);
# 481 "buildvm_ppc.dasc"
  //|  mr L, CARG1
  //|    lwz DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|  mr BASE, CARG2
  //|    lbz TMP1, L->status
  //|   stw L, SAVE_L
  //|  li PC, FRAME_CP
  //|  addi TMP0, sp, CFRAME_RESUME
  //|    addi DISPATCH, DISPATCH, GG_G2DISP
  //|   stw CARG3, SAVE_NRES
  //|    cmplwi TMP1, 0
  //|   stw CARG3, SAVE_ERRF
  //|  stw TMP0, L->cframe
  //|   stw CARG3, SAVE_CFRAME
  //|   stw CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  //|    beq >3
  //|
  //|  // Resume after yield (like a return).
  //|  mr RA, BASE
  //|   lwz BASE, L->base
  //|     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
  //|   lwz TMP1, L->top
  //|  lwz PC, FRAME_PC(BASE)
  //|     lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
  //|    stb CARG3, L->status
  //|     stw TMP3, TMPD
  //|     ori TMP3, TMP3, 0x0004		// TONUM = 2^52 + 2^51 + 2^31 (float).
  //|     lfs TOBIT, TMPD
  //|   sub RD, TMP1, BASE
  //|     stw TMP3, TMPD
  //|     lus TMP0, 0x4338		// Hiword of 2^52 + 2^51 (double)
  //|   addi RD, RD, 8
  //|     stw TMP0, TONUM_HI
  //|    li_vmstate INTERP
  //|     li ZERO, 0
  //|    st_vmstate
  //|  andi. TMP0, PC, FRAME_TYPE
  //|   mr MULTRES, RD
  //|     lfs TONUM, TMPD
  //|     li TISNIL, LJ_TNIL
  //|  beq ->BC_RET_Z
  dasm_put(Dst, 325, 128+(28-14)*8, 56+(29-14)*4, 128+(29-14)*8, 56+(30-14)*4, 128+(30-14)*8, 56+(31-14)*4, 128+(31-14)*8, Dt1(->glref), Dt1(->status), FRAME_CP, CFRAME_RESUME, GG_G2DISP, Dt1(->cframe), Dt1(->base), LJ_TISNUM, Dt1(->top), Dt1(->status), ~LJ_VMST_INTERP, DISPATCH_GL(vmstate), FRAME_TYPE, LJ_TNIL);
# 521 "buildvm_ppc.dasc"
  //|  b ->vm_return
  //|
  //|->vm_pcall:				// Setup protected C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  //|  saveregs
  dasm_put(Dst, 393, 56+(14-14)*4, 128+(14-14)*8, 56+(15-14)*4, 128+(15-14)*8, 56+(16-14)*4, 128+(16-14)*8, 56+(17-14)*4, 128+(17-14)*8, 56+(18-14)*4, 128+(18-14)*8, 56+(19-14)*4, 128+(19-14)*8, 56+(20-14)*4, 128+(20-14)*8, 56+(21-14)*4, 128+(21-14)*8, 56+(22-14)*4, 128+(22-14)*8, 56+(23-14)*4);
# 526 "buildvm_ppc.dasc"
  //|  li PC, FRAME_CP
  //|  stw CARG4, SAVE_ERRF
  //|  b >1
  //|
  //|->vm_call:				// Setup C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1)
  //|  saveregs
  dasm_put(Dst, 440, 128+(23-14)*8, 56+(24-14)*4, 128+(24-14)*8, 56+(25-14)*4, 128+(25-14)*8, 56+(26-14)*4, 128+(26-14)*8, 56+(27-14)*4, 128+(27-14)*8, 56+(28-14)*4, 128+(28-14)*8, 56+(29-14)*4, 128+(29-14)*8, 56+(30-14)*4, 128+(30-14)*8, 56+(31-14)*4, 128+(31-14)*8, FRAME_CP, 56+(14-14)*4, 128+(14-14)*8);
  dasm_put(Dst, 488, 56+(15-14)*4, 128+(15-14)*8, 56+(16-14)*4, 128+(16-14)*8, 56+(17-14)*4, 128+(17-14)*8, 56+(18-14)*4, 128+(18-14)*8, 56+(19-14)*4, 128+(19-14)*8, 56+(20-14)*4, 128+(20-14)*8, 56+(21-14)*4, 128+(21-14)*8, 56+(22-14)*4, 128+(22-14)*8, 56+(23-14)*4, 128+(23-14)*8, 56+(24-14)*4, 128+(24-14)*8, 56+(25-14)*4, 128+(25-14)*8);
# 533 "buildvm_ppc.dasc"
  //|  li PC, FRAME_C
  //|
  //|1:  // Entry point for vm_pcall above (PC = ftype).
  //|  lwz TMP1, L:CARG1->cframe
  //|   stw CARG3, SAVE_NRES
  //|    mr L, CARG1
  //|   stw CARG1, SAVE_L
  //|    mr BASE, CARG2
  //|  stw sp, L->cframe			// Add our C frame to cframe chain.
  //|    lwz DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|   stw CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  //|  stw TMP1, SAVE_CFRAME
  //|    addi DISPATCH, DISPATCH, GG_G2DISP
  //|
  //|3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  //|  lwz TMP2, L->base			// TMP2 = old base (used in vmeta_call).
  //|     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
  //|   lwz TMP1, L->top
  //|     lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
  dasm_put(Dst, 535, 56+(26-14)*4, 128+(26-14)*8, 56+(27-14)*4, 128+(27-14)*8, 56+(28-14)*4, 128+(28-14)*8, 56+(29-14)*4, 128+(29-14)*8, 56+(30-14)*4, 128+(30-14)*8, 56+(31-14)*4, 128+(31-14)*8, FRAME_C, Dt1(->cframe), Dt1(->cframe), Dt1(->glref), GG_G2DISP, Dt1(->base), LJ_TISNUM, Dt1(->top));
# 552 "buildvm_ppc.dasc"
  //|  add PC, PC, BASE
  //|     stw TMP3, TMPD
  //|     li ZERO, 0
  //|     ori TMP3, TMP3, 0x0004		// TONUM = 2^52 + 2^51 + 2^31 (float).
  //|     lfs TOBIT, TMPD
  //|  sub PC, PC, TMP2			// PC = frame delta + frame type
  //|     stw TMP3, TMPD
  //|     lus TMP0, 0x4338		// Hiword of 2^52 + 2^51 (double)
  //|   sub NARGS8:RC, TMP1, BASE
  //|     stw TMP0, TONUM_HI
  //|    li_vmstate INTERP
  //|     lfs TONUM, TMPD
  //|     li TISNIL, LJ_TNIL
  //|    st_vmstate
  //|
  //|->vm_call_dispatch:
  //|  // TMP2 = old base, BASE = new base, RC = nargs*8, PC = caller PC
  //|  lwz TMP0, FRAME_PC(BASE)
  //|   lwz LFUNC:RB, FRAME_FUNC(BASE)
  //|  checkfunc TMP0; bne ->vmeta_call
  //|
  //|->vm_call_dispatch_f:
  //|  ins_call
  //|  // BASE = new base, RB = func, RC = nargs*8, PC = caller PC
  //|
  //|->vm_cpcall:				// Setup protected C frame, call C.
  //|  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  //|  saveregs
  dasm_put(Dst, 586, ~LJ_VMST_INTERP, LJ_TNIL, DISPATCH_GL(vmstate), LJ_TFUNC, Dt7(->pc), 56+(14-14)*4, 128+(14-14)*8, 56+(15-14)*4, 128+(15-14)*8, 56+(16-14)*4, 128+(16-14)*8, 56+(17-14)*4, 128+(17-14)*8, 56+(18-14)*4, 128+(18-14)*8, 56+(19-14)*4, 128+(19-14)*8, 56+(20-14)*4);
  dasm_put(Dst, 653, 128+(20-14)*8, 56+(21-14)*4, 128+(21-14)*8, 56+(22-14)*4, 128+(22-14)*8, 56+(23-14)*4, 128+(23-14)*8, 56+(24-14)*4, 128+(24-14)*8, 56+(25-14)*4, 128+(25-14)*8, 56+(26-14)*4, 128+(26-14)*8, 56+(27-14)*4, 128+(27-14)*8, 56+(28-14)*4, 128+(28-14)*8, 56+(29-14)*4, 128+(29-14)*8, 56+(30-14)*4, 128+(30-14)*8, 56+(31-14)*4);
# 580 "buildvm_ppc.dasc"
  //|  mr L, CARG1
  //|   lwz TMP0, L:CARG1->stack
  //|  stw CARG1, SAVE_L
  //|   lwz TMP1, L->top
  //|  stw CARG1, SAVE_PC			// Any value outside of bytecode is ok.
  //|   sub TMP0, TMP0, TMP1		// Compute -savestack(L, L->top).
  //|    lwz TMP1, L->cframe
  //|    stw sp, L->cframe		// Add our C frame to cframe chain.
  //|  li TMP2, 0
  //|   stw TMP0, SAVE_NRES		// Neg. delta means cframe w/o frame.
  //|  stw TMP2, SAVE_ERRF		// No error function.
  //|    stw TMP1, SAVE_CFRAME
  //|  mtctr CARG4
  //|  bctrl			// (lua_State *L, lua_CFunction func, void *ud)
  //|  mr. BASE, CRET1
  //|   lwz DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|    li PC, FRAME_CP
  //|   addi DISPATCH, DISPATCH, GG_G2DISP
  //|  bne <3				// Else continue with the call.
  //|  b ->vm_leave_cp			// No base? Just remove C frame.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Metamethod handling ------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|// The lj_meta_* functions (except for lj_meta_cat) don't reallocate the
  //|// stack, so BASE doesn't need to be reloaded across these calls.
  //|
  //|//-- Continuation dispatch ----------------------------------------------
  //|
  //|->cont_dispatch:
  //|  // BASE = meta base, RA = resultptr, RD = (nresults+1)*8
  //|  lwz TMP0, -12(BASE)		// Continuation.
  //|   mr RB, BASE
  //|   mr BASE, TMP2			// Restore caller BASE.
  //|    lwz LFUNC:TMP1, FRAME_FUNC(TMP2)
  dasm_put(Dst, 700, 128+(31-14)*8, Dt1(->stack), Dt1(->top), Dt1(->cframe), Dt1(->cframe), Dt1(->glref), FRAME_CP, GG_G2DISP);
# 616 "buildvm_ppc.dasc"
#if LJ_HASFFI
  //|  cmplwi TMP0, 1
  dasm_put(Dst, 738);
# 618 "buildvm_ppc.dasc"
#endif
  //|     lwz PC, -16(RB)			// Restore PC from [cont|PC].
  //|   subi TMP2, RD, 8
  //|    lwz TMP1, LFUNC:TMP1->pc
  //|   stwx TISNIL, RA, TMP2		// Ensure one valid arg.
  dasm_put(Dst, 740, Dt7(->pc));
# 623 "buildvm_ppc.dasc"
#if LJ_HASFFI
  //|  ble >1
  dasm_put(Dst, 746);
# 625 "buildvm_ppc.dasc"
#endif
  //|    lwz KBASE, PC2PROTO(k)(TMP1)
  //|  // BASE = base, RA = resultptr, RB = meta base
  //|  mtctr TMP0
  //|  bctr				// Jump to continuation.
  //|
  dasm_put(Dst, 749, PC2PROTO(k));
# 631 "buildvm_ppc.dasc"
#if LJ_HASFFI
  //|1:
  //|  beq ->cont_ffi_callback		// cont = 1: return from FFI callback.
  //|  // cont = 0: tailcall from C function.
  //|  subi TMP1, RB, 16
  //|  sub RC, TMP1, BASE
  //|  b ->vm_call_tail
  dasm_put(Dst, 754);
# 638 "buildvm_ppc.dasc"
#endif
  //|
  //|->cont_cat:				// RA = resultptr, RB = meta base
  //|  lwz INS, -4(PC)
  //|   subi CARG2, RB, 16
  //|  decode_RB8 SAVE0, INS
  //|   lfd f0, 0(RA)
  //|  add TMP1, BASE, SAVE0
  //|   stw BASE, L->base
  //|  cmplw TMP1, CARG2
  //|   sub CARG3, CARG2, TMP1
  //|  decode_RA8 RA, INS
  //|   stfd f0, 0(CARG2)
  //|  bney ->BC_CAT_Z
  //|   stfdx f0, BASE, RA
  //|  b ->cont_nop
  //|
  //|//-- Table indexing metamethods -----------------------------------------
  //|
  //|->vmeta_tgets1:
  //|  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
  //|  li TMP0, LJ_TSTR
  //|   decode_RB8 RB, INS
  //|  stw STR:RC, 4(CARG3)
  //|   add CARG2, BASE, RB
  //|  stw TMP0, 0(CARG3)
  //|  b >1
  //|
  //|->vmeta_tgets:
  //|  la CARG2, DISPATCH_GL(tmptv)(DISPATCH)
  //|  li TMP0, LJ_TTAB
  //|  stw TAB:RB, 4(CARG2)
  //|   la CARG3, DISPATCH_GL(tmptv2)(DISPATCH)
  //|  stw TMP0, 0(CARG2)
  //|   li TMP1, LJ_TSTR
  //|   stw STR:RC, 4(CARG3)
  //|   stw TMP1, 0(CARG3)
  //|  b >1
  //|
  //|->vmeta_tgetb:			// TMP0 = index
  dasm_put(Dst, 762, Dt1(->base), DISPATCH_GL(tmptv), LJ_TSTR, DISPATCH_GL(tmptv), LJ_TTAB, DISPATCH_GL(tmptv2), LJ_TSTR);
# 678 "buildvm_ppc.dasc"
  if (!LJ_DUALNUM) {
    //|  tonum_u f0, TMP0
    dasm_put(Dst, 807);
# 680 "buildvm_ppc.dasc"
  }
  //|   decode_RB8 RB, INS
  //|  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
  //|   add CARG2, BASE, RB
  dasm_put(Dst, 811, DISPATCH_GL(tmptv));
# 684 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  stw TISNUM, 0(CARG3)
    //|  stw TMP0, 4(CARG3)
    dasm_put(Dst, 816);
# 687 "buildvm_ppc.dasc"
  } else {
    //|  stfd f0, 0(CARG3)
    dasm_put(Dst, 819);
# 689 "buildvm_ppc.dasc"
  }
  //|  b >1
  //|
  //|->vmeta_tgetv:
  //|  decode_RB8 RB, INS
  //|   decode_RC8 RC, INS
  //|  add CARG2, BASE, RB
  //|   add CARG3, BASE, RC
  //|1:
  //|  stw BASE, L->base
  //|  mr CARG1, L
  //|  stw PC, SAVE_PC
  //|  bl extern lj_meta_tget		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|  cmplwi CRET1, 0
  //|  beq >3
  //|   lfd f0, 0(CRET1)
  //|  ins_next1
  //|   stfdx f0, BASE, RA
  //|  ins_next2
  //|
  //|3:  // Call __index metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k
  //|  subfic TMP1, BASE, FRAME_CONT
  //|  lwz BASE, L->top
  //|  stw PC, -16(BASE)			// [cont|PC]
  //|   add PC, TMP1, BASE
  //|  lwz LFUNC:RB, FRAME_FUNC(BASE)	// Guaranteed to be a function here.
  //|   li NARGS8:RC, 16			// 2 args for func(t, k).
  //|  b ->vm_call_dispatch_f
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->vmeta_tsets1:
  //|  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
  //|  li TMP0, LJ_TSTR
  //|   decode_RB8 RB, INS
  //|  stw STR:RC, 4(CARG3)
  //|   add CARG2, BASE, RB
  //|  stw TMP0, 0(CARG3)
  //|  b >1
  //|
  //|->vmeta_tsets:
  //|  la CARG2, DISPATCH_GL(tmptv)(DISPATCH)
  //|  li TMP0, LJ_TTAB
  //|  stw TAB:RB, 4(CARG2)
  //|   la CARG3, DISPATCH_GL(tmptv2)(DISPATCH)
  //|  stw TMP0, 0(CARG2)
  //|   li TMP1, LJ_TSTR
  //|   stw STR:RC, 4(CARG3)
  //|   stw TMP1, 0(CARG3)
  //|  b >1
  //|
  //|->vmeta_tsetb:			// TMP0 = index
  dasm_put(Dst, 821, Dt1(->base), FRAME_CONT, Dt1(->top), DISPATCH_GL(tmptv), LJ_TSTR, DISPATCH_GL(tmptv), LJ_TTAB, DISPATCH_GL(tmptv2), LJ_TSTR);
# 743 "buildvm_ppc.dasc"
  if (!LJ_DUALNUM) {
    //|  tonum_u f0, TMP0
    dasm_put(Dst, 889);
# 745 "buildvm_ppc.dasc"
  }
  //|   decode_RB8 RB, INS
  //|  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
  //|   add CARG2, BASE, RB
  dasm_put(Dst, 893, DISPATCH_GL(tmptv));
# 749 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  stw TISNUM, 0(CARG3)
    //|  stw TMP0, 4(CARG3)
    dasm_put(Dst, 898);
# 752 "buildvm_ppc.dasc"
  } else {
    //|  stfd f0, 0(CARG3)
    dasm_put(Dst, 901);
# 754 "buildvm_ppc.dasc"
  }
  //|  b >1
  //|
  //|->vmeta_tsetv:
  //|  decode_RB8 RB, INS
  //|   decode_RC8 RC, INS
  //|  add CARG2, BASE, RB
  //|   add CARG3, BASE, RC
  //|1:
  //|  stw BASE, L->base
  //|  mr CARG1, L
  //|  stw PC, SAVE_PC
  //|  bl extern lj_meta_tset		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|  cmplwi CRET1, 0
  //|   lfdx f0, BASE, RA
  //|  beq >3
  //|  // NOBARRIER: lj_meta_tset ensures the table is not black.
  //|  ins_next1
  //|   stfd f0, 0(CRET1)
  //|  ins_next2
  //|
  //|3:  // Call __newindex metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
  //|  subfic TMP1, BASE, FRAME_CONT
  //|  lwz BASE, L->top
  //|  stw PC, -16(BASE)			// [cont|PC]
  //|   add PC, TMP1, BASE
  //|  lwz LFUNC:RB, FRAME_FUNC(BASE)	// Guaranteed to be a function here.
  //|   li NARGS8:RC, 24			// 3 args for func(t, k, v)
  //|  stfd f0, 16(BASE)			// Copy value to third argument.
  //|  b ->vm_call_dispatch_f
  //|
  //|//-- Comparison metamethods ---------------------------------------------
  //|
  //|->vmeta_comp:
  //|  mr CARG1, L
  //|   subi PC, PC, 4
  dasm_put(Dst, 903, Dt1(->base), FRAME_CONT, Dt1(->top));
# 792 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  mr CARG2, RA
    dasm_put(Dst, 948);
# 794 "buildvm_ppc.dasc"
  } else {
    //|  add CARG2, BASE, RA
    dasm_put(Dst, 950);
# 796 "buildvm_ppc.dasc"
  }
  //|   stw PC, SAVE_PC
  dasm_put(Dst, 952);
# 798 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  mr CARG3, RD
    dasm_put(Dst, 954);
# 800 "buildvm_ppc.dasc"
  } else {
    //|  add CARG3, BASE, RD
    dasm_put(Dst, 956);
# 802 "buildvm_ppc.dasc"
  }
  //|   stw BASE, L->base
  //|  decode_OP1 CARG4, INS
  //|  bl extern lj_meta_comp  // (lua_State *L, TValue *o1, *o2, int op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|3:
  //|  cmplwi CRET1, 1
  //|  bgt ->vmeta_binop
  //|  subfic CRET1, CRET1, 0
  //|4:
  //|  lwz INS, 0(PC)
  //|   addi PC, PC, 4
  //|  decode_RD4 TMP2, INS
  //|  addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
  //|  and TMP2, TMP2, CRET1
  //|  add PC, PC, TMP2
  //|->cont_nop:
  //|  ins_next
  //|
  //|->cont_ra:				// RA = resultptr
  //|  lwz INS, -4(PC)
  //|   lfd f0, 0(RA)
  //|  decode_RA8 TMP1, INS
  //|   stfdx f0, BASE, TMP1
  //|  b ->cont_nop
  //|
  //|->cont_condt:			// RA = resultptr
  //|  lwz TMP0, 0(RA)
  //|  subfic TMP0, TMP0, LJ_TTRUE	// Branch if result is true.
  //|  subfe CRET1, CRET1, CRET1
  //|  not CRET1, CRET1
  //|  b <4
  //|
  //|->cont_condf:			// RA = resultptr
  //|  lwz TMP0, 0(RA)
  //|  subfic TMP0, TMP0, LJ_TTRUE	// Branch if result is false.
  //|  subfe CRET1, CRET1, CRET1
  //|  b <4
  //|
  //|->vmeta_equal:
  //|  // CARG2, CARG3, CARG4 are already set by BC_ISEQV/BC_ISNEV.
  //|  subi PC, PC, 4
  //|   stw BASE, L->base
  //|  mr CARG1, L
  //|   stw PC, SAVE_PC
  //|  bl extern lj_meta_equal  // (lua_State *L, GCobj *o1, *o2, int ne)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  //|
  //|->vmeta_equal_cd:
  dasm_put(Dst, 958, Dt1(->base), -(BCBIAS_J*4 >> 16), LJ_TTRUE, LJ_TTRUE, Dt1(->base));
# 852 "buildvm_ppc.dasc"
#if LJ_HASFFI
  //|  mr CARG2, INS
  //|  subi PC, PC, 4
  //|   stw BASE, L->base
  //|  mr CARG1, L
  //|   stw PC, SAVE_PC
  //|  bl extern lj_meta_equal_cd		// (lua_State *L, BCIns op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  dasm_put(Dst, 1021, Dt1(->base));
# 861 "buildvm_ppc.dasc"
#endif
  //|
  //|//-- Arithmetic metamethods ---------------------------------------------
  //|
  //|->vmeta_arith_nv:
  //|  add CARG3, KBASE, RC
  //|  add CARG4, BASE, RB
  //|  b >1
  //|->vmeta_arith_nv2:
  dasm_put(Dst, 1032);
# 870 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  mr CARG3, RC
    //|  mr CARG4, RB
    //|  b >1
    dasm_put(Dst, 1039);
# 874 "buildvm_ppc.dasc"
  }
  //|
  //|->vmeta_unm:
  //|  mr CARG3, RD
  //|  mr CARG4, RD
  //|  b >1
  //|
  //|->vmeta_arith_vn:
  //|  add CARG3, BASE, RB
  //|  add CARG4, KBASE, RC
  //|  b >1
  //|
  //|->vmeta_arith_vv:
  //|  add CARG3, BASE, RB
  //|  add CARG4, BASE, RC
  dasm_put(Dst, 1044);
# 889 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  b >1
    dasm_put(Dst, 1058);
# 891 "buildvm_ppc.dasc"
  }
  //|->vmeta_arith_vn2:
  //|->vmeta_arith_vv2:
  dasm_put(Dst, 1061);
# 894 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  mr CARG3, RB
    //|  mr CARG4, RC
    dasm_put(Dst, 1064);
# 897 "buildvm_ppc.dasc"
  }
  //|1:
  //|  add CARG2, BASE, RA
  //|   stw BASE, L->base
  //|  mr CARG1, L
  //|   stw PC, SAVE_PC
  //|  decode_OP1 CARG5, INS		// Caveat: CARG5 overlaps INS.
  //|  bl extern lj_meta_arith  // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
  //|  // Returns NULL (finished) or TValue * (metamethod).
  //|  cmplwi CRET1, 0
  //|  beq ->cont_nop
  //|
  //|  // Call metamethod for binary op.
  //|->vmeta_binop:
  //|  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
  //|  sub TMP1, CRET1, BASE
  //|   stw PC, -16(CRET1)		// [cont|PC]
  //|   mr TMP2, BASE
  //|  addi PC, TMP1, FRAME_CONT
  //|   mr BASE, CRET1
  //|  li NARGS8:RC, 16			// 2 args for func(o1, o2).
  //|  b ->vm_call_dispatch
  //|
  //|->vmeta_len:
  dasm_put(Dst, 1067, Dt1(->base), FRAME_CONT);
# 921 "buildvm_ppc.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|  mr SAVE0, CARG1
  dasm_put(Dst, 1091);
# 923 "buildvm_ppc.dasc"
#endif
  //|  mr CARG2, RD
  //|   stw BASE, L->base
  //|  mr CARG1, L
  //|   stw PC, SAVE_PC
  //|  bl extern lj_meta_len		// (lua_State *L, TValue *o)
  //|  // Returns NULL (retry) or TValue * (metamethod base).
  dasm_put(Dst, 1093, Dt1(->base));
# 930 "buildvm_ppc.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|  cmplwi CRET1, 0
  //|  bne ->vmeta_binop			// Binop call for compatibility.
  //|  mr CARG1, SAVE0
  //|  b ->BC_LEN_Z
  dasm_put(Dst, 1101);
# 935 "buildvm_ppc.dasc"
#else
  //|  b ->vmeta_binop			// Binop call for compatibility.
  dasm_put(Dst, 1108);
# 937 "buildvm_ppc.dasc"
#endif
  //|
  //|//-- Call metamethod ----------------------------------------------------
  //|
  //|->vmeta_call:			// Resolve and call __call metamethod.
  //|  // TMP2 = old base, BASE = new base, RC = nargs*8
  //|  mr CARG1, L
  //|   stw TMP2, L->base			// This is the callers base!
  //|  subi CARG2, BASE, 8
  //|   stw PC, SAVE_PC
  //|  add CARG3, BASE, RC
  //|   mr SAVE0, NARGS8:RC
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  lwz LFUNC:RB, FRAME_FUNC(BASE)	// Guaranteed to be a function here.
  //|   addi NARGS8:RC, SAVE0, 8		// Got one more argument now.
  //|  ins_call
  //|
  //|->vmeta_callt:			// Resolve __call for BC_CALLT.
  //|  // BASE = old base, RA = new base, RC = nargs*8
  //|  mr CARG1, L
  //|   stw BASE, L->base
  //|  subi CARG2, RA, 8
  //|   stw PC, SAVE_PC
  //|  add CARG3, RA, RC
  //|   mr SAVE0, NARGS8:RC
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  lwz TMP1, FRAME_PC(BASE)
  //|   addi NARGS8:RC, SAVE0, 8		// Got one more argument now.
  //|   lwz LFUNC:RB, FRAME_FUNC(RA)	// Guaranteed to be a function here.
  //|  b ->BC_CALLT_Z
  //|
  //|//-- Argument coercion for 'for' statement ------------------------------
  //|
  //|->vmeta_for:
  //|  mr CARG1, L
  //|   stw BASE, L->base
  //|  mr CARG2, RA
  //|   stw PC, SAVE_PC
  //|  mr SAVE0, INS
  //|  bl extern lj_meta_for	// (lua_State *L, TValue *base)
  dasm_put(Dst, 1111, Dt1(->base), Dt7(->pc), Dt1(->base), Dt1(->base));
# 977 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|   decode_OP1 TMP0, SAVE0
  dasm_put(Dst, 1159);
# 979 "buildvm_ppc.dasc"
#endif
  //|  decode_RA8 RA, SAVE0
  dasm_put(Dst, 1161);
# 981 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|   cmpwi TMP0, BC_JFORI
  dasm_put(Dst, 1163, BC_JFORI);
# 983 "buildvm_ppc.dasc"
#endif
  //|  decode_RD8 RD, SAVE0
  dasm_put(Dst, 1166);
# 985 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|   beqy =>BC_JFORI
  dasm_put(Dst, 1168, BC_JFORI);
# 987 "buildvm_ppc.dasc"
#endif
  //|  b =>BC_FORI
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Fast functions -----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|.macro .ffunc, name
  //|->ff_ .. name:
  //|.endmacro
  //|
  //|.macro .ffunc_1, name
  //|->ff_ .. name:
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG3, 0(BASE)
  //|    lwz CARG1, 4(BASE)
  //|  blt ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_2, name
  //|->ff_ .. name:
  //|  cmplwi NARGS8:RC, 16
  //|   lwz CARG3, 0(BASE)
  //|    lwz CARG4, 8(BASE)
  //|   lwz CARG1, 4(BASE)
  //|    lwz CARG2, 12(BASE)
  //|  blt ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_n, name
  //|->ff_ .. name:
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG3, 0(BASE)
  //|    lfd FARG1, 0(BASE)
  //|  blt ->fff_fallback
  //|  checknum CARG3; bge ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_nn, name
  //|->ff_ .. name:
  //|  cmplwi NARGS8:RC, 16
  //|   lwz CARG3, 0(BASE)
  //|    lfd FARG1, 0(BASE)
  //|   lwz CARG4, 8(BASE)
  //|    lfd FARG2, 8(BASE)
  //|  blt ->fff_fallback
  //|  checknum CARG3; bge ->fff_fallback
  //|  checknum CARG4; bge ->fff_fallback
  //|.endmacro
  //|
  //|// Inlined GC threshold check. Caveat: uses TMP0 and TMP1.
  //|.macro ffgccheck
  //|  lwz TMP0, DISPATCH_GL(gc.total)(DISPATCH)
  //|  lwz TMP1, DISPATCH_GL(gc.threshold)(DISPATCH)
  //|  cmplw TMP0, TMP1
  //|  bgel ->fff_gcstep
  //|.endmacro
  //|
  //|//-- Base library: checks -----------------------------------------------
  //|
  //|.ffunc_1 assert
  //|  li TMP1, LJ_TFALSE
  //|   la RA, -8(BASE)
  //|  cmplw cr1, CARG3, TMP1
  //|    lwz PC, FRAME_PC(BASE)
  //|  bge cr1, ->fff_fallback
  //|   stw CARG3, 0(RA)
  //|  addi RD, NARGS8:RC, 8		// Compute (nresults+1)*8.
  //|   stw CARG1, 4(RA)
  //|  beq ->fff_res			// Done if exactly 1 argument.
  //|  li TMP1, 8
  //|  subi RC, RC, 8
  //|1:
  //|  cmplw TMP1, RC
  //|   lfdx f0, BASE, TMP1
  //|   stfdx f0, RA, TMP1
  //|    addi TMP1, TMP1, 8
  //|  bney <1
  //|  b ->fff_res
  //|
  //|.ffunc type
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG1, 0(BASE)
  //|  blt ->fff_fallback
  //|  subfc TMP0, TISNUM, CARG1
  //|  subfe TMP2, CARG1, CARG1
  //|  orc TMP1, TMP2, TMP0
  //|  addi TMP1, TMP1, ~LJ_TISNUM+1
  //|  slwi TMP1, TMP1, 3
  //|   la TMP2, CFUNC:RB->upvalue
  //|  lfdx FARG1, TMP2, TMP1
  //|  b ->fff_resn
  //|
  //|//-- Base library: getters and setters ---------------------------------
  //|
  //|.ffunc_1 getmetatable
  //|  checktab CARG3; bne >6
  //|1:  // Field metatable must be at same offset for GCtab and GCudata!
  //|  lwz TAB:CARG1, TAB:CARG1->metatable
  //|2:
  //|  li CARG3, LJ_TNIL
  dasm_put(Dst, 1171, BC_FORI, LJ_TFALSE, ~LJ_TISNUM+1, 31-3, Dt8(->upvalue), LJ_TTAB, Dt6(->metatable));
# 1088 "buildvm_ppc.dasc"
  //|   cmplwi TAB:CARG1, 0
  //|  lwz STR:RC, DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable])(DISPATCH)
  //|   beq ->fff_restv
  //|  lwz TMP0, TAB:CARG1->hmask
  //|   li CARG3, LJ_TTAB			// Use metatable as default result.
  //|  lwz TMP1, STR:RC->hash
  //|  lwz NODE:TMP2, TAB:CARG1->node
  //|  and TMP1, TMP1, TMP0		// idx = str->hash & tab->hmask
  //|  slwi TMP0, TMP1, 5
  //|  slwi TMP1, TMP1, 3
  //|  sub TMP1, TMP0, TMP1
  //|  add NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
  //|3:  // Rearranged logic, because we expect _not_ to find the key.
  //|  lwz CARG4, NODE:TMP2->key
  //|   lwz TMP0, 4+offsetof(Node, key)(NODE:TMP2)
  //|    lwz CARG2, NODE:TMP2->val
  //|     lwz TMP1, 4+offsetof(Node, val)(NODE:TMP2)
  //|  checkstr CARG4; bne >4
  //|   cmpw TMP0, STR:RC; beq >5
  //|4:
  //|  lwz NODE:TMP2, NODE:TMP2->next
  //|  cmplwi NODE:TMP2, 0
  //|  beq ->fff_restv			// Not found, keep default result.
  //|  b <3
  //|5:
  //|  checknil CARG2
  dasm_put(Dst, 1234, LJ_TNIL, DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable]), Dt6(->hmask), LJ_TTAB, Dt5(->hash), Dt6(->node), 31-5, 31-3, DtB(->key), 4+offsetof(Node, key), DtB(->val), 4+offsetof(Node, val), LJ_TSTR, DtB(->next));
# 1114 "buildvm_ppc.dasc"
  //|  beq ->fff_restv			// Ditto for nil value.
  //|  mr CARG3, CARG2			// Return value of mt.__metatable.
  //|  mr CARG1, TMP1
  //|  b ->fff_restv
  //|
  //|6:
  //|  cmpwi CARG3, LJ_TUDATA; beq <1
  //|  subfc TMP0, TISNUM, CARG3
  //|  subfe TMP2, CARG3, CARG3
  //|  orc TMP1, TMP2, TMP0
  //|  addi TMP1, TMP1, ~LJ_TISNUM+1
  //|  slwi TMP1, TMP1, 2
  //|   la TMP2, DISPATCH_GL(gcroot[GCROOT_BASEMT])(DISPATCH)
  //|  lwzx TAB:CARG1, TMP2, TMP1
  //|  b <2
  //|
  //|.ffunc_2 setmetatable
  //|  // Fast path: no mt for table yet and not clearing the mt.
  //|   checktab CARG3; bne ->fff_fallback
  //|  lwz TAB:TMP1, TAB:CARG1->metatable
  //|   checktab CARG4; bne ->fff_fallback
  //|  cmplwi TAB:TMP1, 0
  //|   lbz TMP3, TAB:CARG1->marked
  //|  bne ->fff_fallback
  //|   andi. TMP0, TMP3, LJ_GC_BLACK	// isblack(table)
  //|    stw TAB:CARG2, TAB:CARG1->metatable
  //|   beq ->fff_restv
  //|  barrierback TAB:CARG1, TMP3, TMP0
  dasm_put(Dst, 1282, LJ_TNIL, LJ_TUDATA, ~LJ_TISNUM+1, 31-2, DISPATCH_GL(gcroot[GCROOT_BASEMT]), LJ_TTAB, Dt6(->metatable), LJ_TTAB, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable));
# 1142 "buildvm_ppc.dasc"
  //|  b ->fff_restv
  //|
  //|.ffunc rawget
  //|  cmplwi NARGS8:RC, 16
  //|   lwz CARG4, 0(BASE)
  //|    lwz TAB:CARG2, 4(BASE)
  //|  blt ->fff_fallback
  //|  checktab CARG4; bne ->fff_fallback
  //|   la CARG3, 8(BASE)
  //|   mr CARG1, L
  //|  bl extern lj_tab_get  // (lua_State *L, GCtab *t, cTValue *key)
  //|  // Returns cTValue *.
  //|  lfd FARG1, 0(CRET1)
  //|  b ->fff_resn
  //|
  //|//-- Base library: conversions ------------------------------------------
  //|
  //|.ffunc tonumber
  //|  // Only handles the number case inline (without a base argument).
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG1, 0(BASE)
  //|    lfd FARG1, 0(BASE)
  //|  bne ->fff_fallback			// Exactly one argument.
  //|   checknum CARG1; bgt ->fff_fallback
  //|  b ->fff_resn
  //|
  //|.ffunc_1 tostring
  //|  // Only handles the string or number case inline.
  //|  checkstr CARG3
  //|  // A __tostring method in the string base metatable is ignored.
  //|  beq ->fff_restv			// String key?
  //|  // Handle numbers inline, unless a number base metatable is present.
  //|  lwz TMP0, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM])(DISPATCH)
  //|  checknum CARG3
  //|  cmplwi cr1, TMP0, 0
  //|   stw BASE, L->base			// Add frame since C call can throw.
  //|  crorc 4*cr0+eq, 4*cr0+gt, 4*cr1+eq
  //|   stw PC, SAVE_PC			// Redundant (but a defined value).
  //|  beq ->fff_fallback
  //|  ffgccheck
  dasm_put(Dst, 1337, DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist), LJ_TTAB, LJ_TSTR, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]), Dt1(->base));
# 1182 "buildvm_ppc.dasc"
  //|  mr CARG1, L
  //|  mr CARG2, BASE
  dasm_put(Dst, 1397, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
# 1184 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  bl extern lj_str_fromnumber	// (lua_State *L, cTValue *o)
    dasm_put(Dst, 1407);
# 1186 "buildvm_ppc.dasc"
  } else {
    //|  bl extern lj_str_fromnum		// (lua_State *L, lua_Number *np)
    dasm_put(Dst, 1410);
# 1188 "buildvm_ppc.dasc"
  }
  //|  // Returns GCstr *.
  //|  li CARG3, LJ_TSTR
  //|  b ->fff_restv
  //|
  //|//-- Base library: iterators -------------------------------------------
  //|
  //|.ffunc next
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG1, 0(BASE)
  //|    lwz TAB:CARG2, 4(BASE)
  //|  blt ->fff_fallback
  //|   stwx TISNIL, BASE, NARGS8:RC	// Set missing 2nd arg to nil.
  //|  checktab CARG1
  //|   lwz PC, FRAME_PC(BASE)
  //|  bne ->fff_fallback
  //|   stw BASE, L->base			// Add frame since C call can throw.
  //|  mr CARG1, L
  //|   stw BASE, L->top			// Dummy frame length is ok.
  //|  la CARG3, 8(BASE)
  //|   stw PC, SAVE_PC
  //|  bl extern lj_tab_next	// (lua_State *L, GCtab *t, TValue *key)
  //|  // Returns 0 at end of traversal.
  //|  cmplwi CRET1, 0
  //|   li CARG3, LJ_TNIL
  //|  beq ->fff_restv			// End of traversal: return nil.
  //|  lfd f0, 8(BASE)			// Copy key and value to results.
  //|   la RA, -8(BASE)
  //|  lfd f1, 16(BASE)
  //|  stfd f0, 0(RA)
  //|   li RD, (2+1)*8
  //|  stfd f1, 8(RA)
  //|  b ->fff_res
  //|
  //|.ffunc_1 pairs
  //|  checktab CARG3
  //|   lwz PC, FRAME_PC(BASE)
  //|  bne ->fff_fallback
  dasm_put(Dst, 1413, LJ_TSTR, LJ_TTAB, Dt1(->base), Dt1(->top), LJ_TNIL, (2+1)*8, LJ_TTAB);
# 1226 "buildvm_ppc.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|   lwz TAB:TMP2, TAB:CARG1->metatable
  //|  lfd f0, CFUNC:RB->upvalue[0]
  //|   cmplwi TAB:TMP2, 0
  //|  la RA, -8(BASE)
  //|   bne ->fff_fallback
  dasm_put(Dst, 1464, Dt6(->metatable), Dt8(->upvalue[0]));
# 1232 "buildvm_ppc.dasc"
#else
  //|  lfd f0, CFUNC:RB->upvalue[0]
  //|  la RA, -8(BASE)
  dasm_put(Dst, 1473, Dt8(->upvalue[0]));
# 1235 "buildvm_ppc.dasc"
#endif
  //|   stw TISNIL, 8(BASE)
  //|  li RD, (3+1)*8
  //|  stfd f0, 0(RA)
  //|  b ->fff_res
  //|
  //|.ffunc ipairs_aux
  //|  cmplwi NARGS8:RC, 16
  //|   lwz CARG3, 0(BASE)
  //|    lwz TAB:CARG1, 4(BASE)
  //|   lwz CARG4, 8(BASE)
  dasm_put(Dst, 1477, (3+1)*8);
# 1246 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|    lwz TMP2, 12(BASE)
    dasm_put(Dst, 1489);
# 1248 "buildvm_ppc.dasc"
  } else {
    //|    lfd FARG2, 8(BASE)
    dasm_put(Dst, 1491);
# 1250 "buildvm_ppc.dasc"
  }
  //|  blt ->fff_fallback
  //|  checktab CARG3
  //|  checknum cr1, CARG4
  //|   lwz PC, FRAME_PC(BASE)
  dasm_put(Dst, 1493, LJ_TTAB);
# 1255 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  bne ->fff_fallback
    //|  bne cr1, ->fff_fallback
    dasm_put(Dst, 1500);
# 1258 "buildvm_ppc.dasc"
  } else {
    //|    lus TMP0, 0x3ff0
    //|    stw ZERO, TMPD_LO
    //|  bne ->fff_fallback
    //|    stw TMP0, TMPD_HI
    //|  bge cr1, ->fff_fallback
    //|    lfd FARG1, TMPD
    //|  toint TMP2, FARG2, f0
    dasm_put(Dst, 1505);
# 1266 "buildvm_ppc.dasc"
  }
  //|   lwz TMP0, TAB:CARG1->asize
  //|   lwz TMP1, TAB:CARG1->array
  dasm_put(Dst, 1517, Dt6(->asize), Dt6(->array));
# 1269 "buildvm_ppc.dasc"
  if (!LJ_DUALNUM) {
    //|  fadd FARG2, FARG2, FARG1
    dasm_put(Dst, 1522);
# 1271 "buildvm_ppc.dasc"
  }
  //|  addi TMP2, TMP2, 1
  //|   la RA, -8(BASE)
  //|  cmplw TMP0, TMP2
  dasm_put(Dst, 1524);
# 1275 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  stw TISNUM, 0(RA)
    //|   slwi TMP3, TMP2, 3
    //|  stw TMP2, 4(RA)
    dasm_put(Dst, 1528, 31-3);
# 1279 "buildvm_ppc.dasc"
  } else {
    //|   slwi TMP3, TMP2, 3
    //|  stfd FARG2, 0(RA)
    dasm_put(Dst, 1533, 31-3);
# 1282 "buildvm_ppc.dasc"
  }
  //|  ble >2				// Not in array part?
  //|  lwzx TMP2, TMP1, TMP3
  //|  lfdx f0, TMP1, TMP3
  //|1:
  //|  checknil TMP2
  //|   li RD, (0+1)*8
  //|  beq ->fff_res			// End of iteration, return 0 results.
  //|   li RD, (2+1)*8
  //|  stfd f0, 8(RA)
  //|  b ->fff_res
  //|2:  // Check for empty hash part first. Otherwise call C function.
  //|  lwz TMP0, TAB:CARG1->hmask
  //|  cmplwi TMP0, 0
  //|   li RD, (0+1)*8
  //|  beq ->fff_res
  //|   mr CARG2, TMP2
  //|  bl extern lj_tab_getinth		// (GCtab *t, int32_t key)
  //|  // Returns cTValue * or NULL.
  //|  cmplwi CRET1, 0
  //|   li RD, (0+1)*8
  //|  beq ->fff_res
  //|  lwz TMP2, 0(CRET1)
  //|  lfd f0, 0(CRET1)
  //|  b <1
  //|
  //|.ffunc_1 ipairs
  //|  checktab CARG3
  //|   lwz PC, FRAME_PC(BASE)
  //|  bne ->fff_fallback
  dasm_put(Dst, 1537, LJ_TNIL, (0+1)*8, (2+1)*8, Dt6(->hmask), (0+1)*8, (0+1)*8, LJ_TTAB);
# 1312 "buildvm_ppc.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|   lwz TAB:TMP2, TAB:CARG1->metatable
  //|  lfd f0, CFUNC:RB->upvalue[0]
  //|   cmplwi TAB:TMP2, 0
  //|  la RA, -8(BASE)
  //|   bne ->fff_fallback
  dasm_put(Dst, 1585, Dt6(->metatable), Dt8(->upvalue[0]));
# 1318 "buildvm_ppc.dasc"
#else
  //|  lfd f0, CFUNC:RB->upvalue[0]
  //|  la RA, -8(BASE)
  dasm_put(Dst, 1594, Dt8(->upvalue[0]));
# 1321 "buildvm_ppc.dasc"
#endif
  if (LJ_DUALNUM) {
    //|  stw TISNUM, 8(BASE)
    dasm_put(Dst, 1598);
# 1324 "buildvm_ppc.dasc"
  } else {
    //|  stw ZERO, 8(BASE)
    dasm_put(Dst, 1600);
# 1326 "buildvm_ppc.dasc"
  }
  //|   stw ZERO, 12(BASE)
  //|  li RD, (3+1)*8
  //|  stfd f0, 0(RA)
  //|  b ->fff_res
  //|
  //|//-- Base library: catch errors ----------------------------------------
  //|
  //|.ffunc pcall
  //|  cmplwi NARGS8:RC, 8
  //|   lbz TMP3, DISPATCH_GL(hookmask)(DISPATCH)
  //|  blt ->fff_fallback
  //|   mr TMP2, BASE
  //|   la BASE, 8(BASE)
  //|  // Remember active hook before pcall.
  //|  rlwinm TMP3, TMP3, 32-HOOK_ACTIVE_SHIFT, 31, 31
  //|   subi NARGS8:RC, NARGS8:RC, 8
  //|  addi PC, TMP3, 8+FRAME_PCALL
  //|  b ->vm_call_dispatch
  //|
  //|.ffunc xpcall
  //|  cmplwi NARGS8:RC, 16
  //|   lwz CARG4, 8(BASE)
  //|    lfd FARG2, 8(BASE)
  //|    lfd FARG1, 0(BASE)
  //|  blt ->fff_fallback
  //|  lbz TMP1, DISPATCH_GL(hookmask)(DISPATCH)
  //|   mr TMP2, BASE
  //|  checkfunc CARG4; bne ->fff_fallback  // Traceback must be a function.
  //|   la BASE, 16(BASE)
  //|  // Remember active hook before pcall.
  //|  rlwinm TMP1, TMP1, 32-HOOK_ACTIVE_SHIFT, 31, 31
  //|    stfd FARG2, 0(TMP2)		// Swap function and traceback.
  //|  subi NARGS8:RC, NARGS8:RC, 16
  //|    stfd FARG1, 8(TMP2)
  //|  addi PC, TMP1, 16+FRAME_PCALL
  //|  b ->vm_call_dispatch
  //|
  //|//-- Coroutine library --------------------------------------------------
  //|
  //|.macro coroutine_resume_wrap, resume
  //|.if resume
  //|.ffunc_1 coroutine_resume
  //|  cmpwi CARG3, LJ_TTHREAD; bne ->fff_fallback
  //|.else
  //|.ffunc coroutine_wrap_aux
  //|  lwz L:CARG1, CFUNC:RB->upvalue[0].gcr
  //|.endif
  //|  lbz TMP0, L:CARG1->status
  //|   lwz TMP1, L:CARG1->cframe
  //|    lwz CARG2, L:CARG1->top
  //|  cmplwi cr0, TMP0, LUA_YIELD
  //|    lwz TMP2, L:CARG1->base
  //|   cmplwi cr1, TMP1, 0
  //|   lwz TMP0, L:CARG1->maxstack
  //|    cmplw cr7, CARG2, TMP2
  //|   lwz PC, FRAME_PC(BASE)
  //|  crorc 4*cr6+lt, 4*cr0+gt, 4*cr1+eq		// st>LUA_YIELD || cframe!=0
  //|   add TMP2, CARG2, NARGS8:RC
  //|  crandc 4*cr6+gt, 4*cr7+eq, 4*cr0+eq	// base==top && st!=LUA_YIELD
  //|   cmplw cr1, TMP2, TMP0
  //|  cror 4*cr6+lt, 4*cr6+lt, 4*cr6+gt
  //|   stw PC, SAVE_PC
  //|  cror 4*cr6+lt, 4*cr6+lt, 4*cr1+gt		// cond1 || cond2 || stackov
  //|   stw BASE, L->base
  //|  blt cr6, ->fff_fallback
  //|1:
  //|.if resume
  //|  addi BASE, BASE, 8			// Keep resumed thread in stack for GC.
  //|  subi NARGS8:RC, NARGS8:RC, 8
  //|  subi TMP2, TMP2, 8
  //|.endif
  //|  stw TMP2, L:CARG1->top
  //|  li TMP1, 0
  //|  stw BASE, L->top
  //|2:  // Move args to coroutine.
  //|  cmpw TMP1, NARGS8:RC
  //|   lfdx f0, BASE, TMP1
  //|  beq >3
  //|   stfdx f0, CARG2, TMP1
  //|  addi TMP1, TMP1, 8
  //|  b <2
  //|3:
  //|  li CARG3, 0
  //|   mr L:SAVE0, L:CARG1
  //|  li CARG4, 0
  //|  bl ->vm_resume			// (lua_State *L, TValue *base, 0, 0)
  //|  // Returns thread status.
  //|4:
  //|  lwz TMP2, L:SAVE0->base
  //|   cmplwi CRET1, LUA_YIELD
  //|  lwz TMP3, L:SAVE0->top
  //|    li_vmstate INTERP
  //|  lwz BASE, L->base
  //|    st_vmstate
  //|   bgt >8
  //|  sub RD, TMP3, TMP2
  //|   lwz TMP0, L->maxstack
  //|  cmplwi RD, 0
  //|   add TMP1, BASE, RD
  //|  beq >6				// No results?
  //|  cmplw TMP1, TMP0
  //|   li TMP1, 0
  //|  bgt >9				// Need to grow stack?
  //|
  //|  subi TMP3, RD, 8
  //|   stw TMP2, L:SAVE0->top		// Clear coroutine stack.
  //|5:  // Move results from coroutine.
  //|  cmplw TMP1, TMP3
  //|   lfdx f0, TMP2, TMP1
  //|   stfdx f0, BASE, TMP1
  //|    addi TMP1, TMP1, 8
  //|  bne <5
  //|6:
  //|  andi. TMP0, PC, FRAME_TYPE
  //|.if resume
  //|  li TMP1, LJ_TTRUE
  //|   la RA, -8(BASE)
  //|  stw TMP1, -8(BASE)			// Prepend true to results.
  //|  addi RD, RD, 16
  //|.else
  //|  mr RA, BASE
  //|  addi RD, RD, 8
  //|.endif
  //|7:
  //|    stw PC, SAVE_PC
  //|   mr MULTRES, RD
  //|  beq ->BC_RET_Z
  //|  b ->vm_return
  //|
  //|8:  // Coroutine returned with error (at co->top-1).
  //|.if resume
  //|  andi. TMP0, PC, FRAME_TYPE
  //|  la TMP3, -8(TMP3)
  //|   li TMP1, LJ_TFALSE
  //|  lfd f0, 0(TMP3)
  //|   stw TMP3, L:SAVE0->top		// Remove error from coroutine stack.
  //|    li RD, (2+1)*8
  //|   stw TMP1, -8(BASE)		// Prepend false to results.
  //|    la RA, -8(BASE)
  //|  stfd f0, 0(BASE)			// Copy error message.
  //|  b <7
  //|.else
  //|  mr CARG1, L
  //|  mr CARG2, L:SAVE0
  //|  bl extern lj_ffh_coroutine_wrap_err  // (lua_State *L, lua_State *co)
  //|.endif
  //|
  //|9:  // Handle stack expansion on return from yield.
  //|  mr CARG1, L
  //|  srwi CARG2, RD, 3
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  li CRET1, 0
  //|  b <4
  //|.endmacro
  //|
  //|  coroutine_resume_wrap 1		// coroutine.resume
  dasm_put(Dst, 1602, (3+1)*8, DISPATCH_GL(hookmask), 32-HOOK_ACTIVE_SHIFT, 8+FRAME_PCALL, DISPATCH_GL(hookmask), LJ_TFUNC, 32-HOOK_ACTIVE_SHIFT, 16+FRAME_PCALL, LJ_TTHREAD, Dt1(->status), Dt1(->cframe));
  dasm_put(Dst, 1662, Dt1(->top), LUA_YIELD, Dt1(->base), Dt1(->maxstack), Dt1(->base), Dt1(->top), Dt1(->top), Dt1(->base), LUA_YIELD, Dt1(->top), ~LJ_VMST_INTERP, Dt1(->base), DISPATCH_GL(vmstate));
# 1483 "buildvm_ppc.dasc"
  //|  coroutine_resume_wrap 0		// coroutine.wrap
  dasm_put(Dst, 1724, Dt1(->maxstack), Dt1(->top), FRAME_TYPE, LJ_TTRUE, FRAME_TYPE, LJ_TFALSE, Dt1(->top), (2+1)*8, 32-3);
  dasm_put(Dst, 1787, Dt8(->upvalue[0].gcr), Dt1(->status), Dt1(->cframe), Dt1(->top), LUA_YIELD, Dt1(->base), Dt1(->maxstack), Dt1(->base), Dt1(->top), Dt1(->top), Dt1(->base), LUA_YIELD, Dt1(->top), ~LJ_VMST_INTERP);
# 1484 "buildvm_ppc.dasc"
  //|
  //|.ffunc coroutine_yield
  //|  lwz TMP0, L->cframe
  //|   add TMP1, BASE, NARGS8:RC
  dasm_put(Dst, 1846, Dt1(->base), DISPATCH_GL(vmstate), Dt1(->maxstack), Dt1(->top), FRAME_TYPE, 32-3, Dt1(->cframe));
# 1488 "buildvm_ppc.dasc"
  //|   stw BASE, L->base
  //|  andi. TMP0, TMP0, CFRAME_RESUME
  //|   stw TMP1, L->top
  //|    li CRET1, LUA_YIELD
  //|  beq ->fff_fallback
  //|   stw ZERO, L->cframe
  //|    stb CRET1, L->status
  //|  b ->vm_leave_unw
  //|
  //|//-- Math library -------------------------------------------------------
  //|
  //|.ffunc_1 math_abs
  //|  checknum CARG3
  dasm_put(Dst, 1903, Dt1(->base), CFRAME_RESUME, Dt1(->top), LUA_YIELD, Dt1(->cframe), Dt1(->status));
# 1501 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  bne >2
    //|  srawi TMP1, CARG1, 31
    //|  xor TMP2, TMP1, CARG1
    //|  sub. CARG1, TMP2, TMP1
    //|  blt >1
    //|->fff_resi:
    //|  lwz PC, FRAME_PC(BASE)
    //|  la RA, -8(BASE)
    //|  stw TISNUM, -8(BASE)
    //|  stw CRET1, -4(BASE)
    //|  b ->fff_res1
    //|1:
    //|  lus CARG3, 0x41e0	// 2^31.
    //|  li CARG1, 0
    //|  b ->fff_restv
    //|2:
    dasm_put(Dst, 1928);
# 1518 "buildvm_ppc.dasc"
  }
  //|  bge ->fff_fallback
  //|  rlwinm CARG3, CARG3, 0, 1, 31
  //|  // Fallthrough.
  //|
  //|->fff_restv:
  //|  // CARG3/CARG1 = TValue result.
  //|  lwz PC, FRAME_PC(BASE)
  //|   stw CARG3, -8(BASE)
  //|  la RA, -8(BASE)
  //|   stw CARG1, -4(BASE)
  //|->fff_res1:
  //|  // RA = results, PC = return.
  //|  li RD, (1+1)*8
  //|->fff_res:
  //|  // RA = results, RD = (nresults+1)*8, PC = return.
  //|  andi. TMP0, PC, FRAME_TYPE
  //|   mr MULTRES, RD
  //|  bney ->vm_return
  //|  lwz INS, -4(PC)
  //|  decode_RB8 RB, INS
  //|5:
  //|  cmplw RB, RD			// More results expected?
  //|   decode_RA8 TMP0, INS
  //|  bgt >6
  //|  ins_next1
  //|  // Adjust BASE. KBASE is assumed to be set for the calling frame.
  //|   sub BASE, RA, TMP0
  //|  ins_next2
  //|
  //|6:  // Fill up results with nil.
  //|  subi TMP1, RD, 8
  //|   addi RD, RD, 8
  //|  stwx TISNIL, RA, TMP1
  //|  b <5
  //|
  //|.macro math_extern, func
  //|  .ffunc_n math_ .. func
  //|  bl extern func
  //|  b ->fff_resn
  //|.endmacro
  //|
  //|.macro math_extern2, func
  //|  .ffunc_nn math_ .. func
  //|  bl extern func
  //|  b ->fff_resn
  //|.endmacro
  //|
  //|.macro math_round, func
  //|  .ffunc_1 math_ .. func
  //|   checknum CARG3; beqy ->fff_restv
  //|  rlwinm TMP2, CARG3, 12, 21, 31
  //|   bge ->fff_fallback
  //|  addic. TMP2, TMP2, -1023		// exp = exponent(x) - 1023
  //|  cmplwi cr1, TMP2, 31		// 0 <= exp < 31?
  //|   subfic TMP0, TMP2, 31
  //|  blt >3
  //|  slwi TMP1, CARG3, 11
  //|   srwi TMP3, CARG1, 21
  //|  oris TMP1, TMP1, 0x8000
  //|   addi TMP2, TMP2, 1
  //|  or TMP1, TMP1, TMP3
  //|   slwi CARG2, CARG1, 11
  //|  bge cr1, >4
  //|   slw TMP3, TMP1, TMP2
  //|  srw CARG1, TMP1, TMP0
  //|   or TMP3, TMP3, CARG2
  //|  srawi TMP2, CARG3, 31
  //|.if "func" == "floor"
  //|  and TMP1, TMP3, TMP2
  //|  addic TMP0, TMP1, -1
  //|  subfe TMP1, TMP0, TMP1
  //|  add CARG1, CARG1, TMP1
  //|  xor CARG1, CARG1, TMP2
  //|  sub CARG1, CARG1, TMP2
  //|  b ->fff_resi
  //|.else
  //|  andc TMP1, TMP3, TMP2
  //|  addic TMP0, TMP1, -1
  //|  subfe TMP1, TMP0, TMP1
  //|  addo. CARG1, CARG1, TMP1
  //|  xor CARG1, CARG1, TMP2
  //|  sub CARG1, CARG1, TMP2
  //|  bns ->fff_resi
  //|  // Potential overflow.
  //|  mcrxr cr0; bley ->fff_resi		// Ignore unrelated overflow.
  //|  lus CARG3, 0x41e0			// 2^31.
  //|  li CARG1, 0
  //|  b ->fff_restv
  //|.endif
  //|3:  // |x| < 1
  //|  add TMP2, CARG3, CARG3
  //|   srawi TMP1, CARG3, 31
  //|  or TMP2, CARG1, TMP2		// ztest = (hi+hi) | lo
  //|.if "func" == "floor"
  //|  and TMP1, TMP2, TMP1		// (ztest & sign) == 0 ? 0 : -1
  //|  subfic TMP2, TMP1, 0
  //|  subfe CARG1, CARG1, CARG1
  //|.else
  //|  andc TMP1, TMP2, TMP1		// (ztest & ~sign) == 0 ? 0 : 1
  //|  addic TMP2, TMP1, -1
  //|  subfe CARG1, TMP2, TMP1
  //|.endif
  //|  b ->fff_resi
  //|4:  // exp >= 31. Check for -(2^31).
  //|  xoris TMP1, TMP1, 0x8000
  //|  srawi TMP2, CARG3, 31
  //|.if "func" == "floor"
  //|  or TMP1, TMP1, CARG2
  //|.endif
  //|  orc. TMP1, TMP1, TMP2
  //|  crand 4*cr0+eq, 4*cr0+eq, 4*cr1+eq
  //|  lus CARG1, 0x8000			// -(2^31).
  //|  beqy ->fff_resi
  //|5:
  //|  lfd FARG1, 0(BASE)
  //|  bl extern func
  //|  b ->fff_resn
  //|.endmacro
  //|
  dasm_put(Dst, 1949, (1+1)*8, FRAME_TYPE);
# 1638 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  math_round floor
    //|  math_round ceil
    dasm_put(Dst, 1991, 31-11, 32-21, 31-11);
    dasm_put(Dst, 2073, 31-11, 32-21, 31-11);
# 1641 "buildvm_ppc.dasc"
  } else {
    //|  // NYI: use internal implementation.
    //|  math_extern floor
    //|  math_extern ceil
    dasm_put(Dst, 2127);
# 1645 "buildvm_ppc.dasc"
  }
  //|
  //|  math_extern sqrt
  //|  math_extern log
  //|  math_extern log10
  //|  math_extern exp
  //|  math_extern sin
  dasm_put(Dst, 2154);
# 1652 "buildvm_ppc.dasc"
  //|  math_extern cos
  //|  math_extern tan
  //|  math_extern asin
  //|  math_extern acos
  dasm_put(Dst, 2213);
# 1656 "buildvm_ppc.dasc"
  //|  math_extern atan
  //|  math_extern sinh
  //|  math_extern cosh
  //|  math_extern tanh
  //|  math_extern2 pow
  dasm_put(Dst, 2271);
# 1661 "buildvm_ppc.dasc"
  //|  math_extern2 atan2
  //|  math_extern2 fmod
  //|
  //|->ff_math_deg:
  //|.ffunc_n math_rad
  //|  lfd FARG2, CFUNC:RB->upvalue[0]
  //|  fmul FARG1, FARG1, FARG2
  dasm_put(Dst, 2327, Dt8(->upvalue[0]));
# 1668 "buildvm_ppc.dasc"
  //|  b ->fff_resn
  //|
  dasm_put(Dst, 2393);
# 1670 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|.ffunc math_ldexp
    //|  cmplwi NARGS8:RC, 16
    //|   lwz CARG3, 0(BASE)
    //|    lfd FARG1, 0(BASE)
    //|   lwz CARG4, 8(BASE)
    //|    lwz CARG1, 12(BASE)
    //|  blt ->fff_fallback
    //|  checknum CARG3; bge ->fff_fallback
    //|  checknum CARG4; bne ->fff_fallback
    dasm_put(Dst, 2397);
# 1680 "buildvm_ppc.dasc"
  } else {
    //|.ffunc_nn math_ldexp
    //|  toint CARG1, FARG2
    dasm_put(Dst, 2412);
# 1683 "buildvm_ppc.dasc"
  }
  //|  bl extern ldexp
  //|  b ->fff_resn
  //|
  //|.ffunc_n math_frexp
  //|  la CARG1, DISPATCH_GL(tmptv)(DISPATCH)
  //|   lwz PC, FRAME_PC(BASE)
  //|  bl extern frexp
  //|   lwz TMP1, DISPATCH_GL(tmptv)(DISPATCH)
  //|   la RA, -8(BASE)
  dasm_put(Dst, 2430, DISPATCH_GL(tmptv), DISPATCH_GL(tmptv));
# 1693 "buildvm_ppc.dasc"
  if (!LJ_DUALNUM) {
    //|   tonum_i FARG2, TMP1
    dasm_put(Dst, 2452);
# 1695 "buildvm_ppc.dasc"
  }
  //|  stfd FARG1, 0(RA)
  //|  li RD, (2+1)*8
  dasm_put(Dst, 2457, (2+1)*8);
# 1698 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|   stw TISNUM, 8(RA)
    //|   stw TMP1, 12(RA)
    dasm_put(Dst, 2461);
# 1701 "buildvm_ppc.dasc"
  } else {
    //|   stfd FARG2, 8(RA)
    dasm_put(Dst, 2464);
# 1703 "buildvm_ppc.dasc"
  }
  //|  b ->fff_res
  //|
  //|.ffunc_n math_modf
  //|  la CARG1, -8(BASE)
  //|   lwz PC, FRAME_PC(BASE)
  //|  bl extern modf
  //|   la RA, -8(BASE)
  //|  stfd FARG1, 0(BASE)
  //|  li RD, (2+1)*8
  //|  b ->fff_res
  //|
  //|.macro math_minmax, name, ismax
  //||if (LJ_DUALNUM) {
  //|  .ffunc_1 name
  //|  checknum CARG3
  //|   addi TMP1, BASE, 8
  //|   add TMP2, BASE, NARGS8:RC
  //|  bne >4
  //|1:  // Handle integers.
  //|  lwz CARG4, 0(TMP1)
  //|   cmplw cr1, TMP1, TMP2
  //|  lwz CARG2, 4(TMP1)
  //|   bge cr1, ->fff_resi
  //|  checknum CARG4
  //|   xoris TMP0, CARG1, 0x8000
  //|   xoris TMP3, CARG2, 0x8000
  //|  bne >3
  //|  subfc TMP3, TMP3, TMP0
  //|  subfe TMP0, TMP0, TMP0
  //|.if ismax
  //|  andc TMP3, TMP3, TMP0
  //|.else
  //|  and TMP3, TMP3, TMP0
  //|.endif
  //|  add CARG1, TMP3, CARG2
  //|   addi TMP1, TMP1, 8
  //|  b <1
  //|3:
  //|  bge ->fff_fallback
  //|  // Convert intermediate result to number and continue below.
  //|  tonum_i FARG1, CARG1
  //|  lfd FARG2, 0(TMP1)
  //|  b >6
  //|4:
  //|   lfd FARG1, 0(BASE)
  //|  bge ->fff_fallback
  //|5:  // Handle numbers.
  //|  lwz CARG4, 0(TMP1)
  //|   cmplw cr1, TMP1, TMP2
  //|  lfd FARG2, 0(TMP1)
  //|   bge cr1, ->fff_resn
  //|  checknum CARG4; bge >7
  //|6:
  //|  fsub f0, FARG1, FARG2
  //|   addi TMP1, TMP1, 8
  //|.if ismax
  //|  fsel FARG1, f0, FARG1, FARG2
  //|.else
  //|  fsel FARG1, f0, FARG2, FARG1
  //|.endif
  //|  b <5
  //|7:  // Convert integer to number and continue above.
  //|   lwz CARG2, 4(TMP1)
  //|  bne ->fff_fallback
  //|  tonum_i FARG2, CARG2
  //|  b <6
  //||} else {
  //|  .ffunc_n name
  //|  li TMP1, 8
  //|1:
  //|   lwzx CARG2, BASE, TMP1
  //|   lfdx FARG2, BASE, TMP1
  //|  cmplw cr1, TMP1, NARGS8:RC
  //|   checknum CARG2
  //|  bge cr1, ->fff_resn
  //|   bge ->fff_fallback
  //|  fsub f0, FARG1, FARG2
  //|   addi TMP1, TMP1, 8
  //|.if ismax
  //|  fsel FARG1, f0, FARG1, FARG2
  //|.else
  //|  fsel FARG1, f0, FARG2, FARG1
  //|.endif
  //|  b <1
  //||}
  //|.endmacro
  //|
  //|  math_minmax math_min, 0
  dasm_put(Dst, 2466, (2+1)*8);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 2488);
  } else {
  dasm_put(Dst, 2557);
  }
# 1792 "buildvm_ppc.dasc"
  //|  math_minmax math_max, 1
  if (LJ_DUALNUM) {
  dasm_put(Dst, 2582);
  } else {
  dasm_put(Dst, 2651);
  }
# 1793 "buildvm_ppc.dasc"
  //|
  //|//-- String library -----------------------------------------------------
  //|
  //|.ffunc_1 string_len
  //|  checkstr CARG3; bne ->fff_fallback
  //|  lwz CRET1, STR:CARG1->len
  //|  b ->fff_resi
  //|
  //|.ffunc string_byte			// Only handle the 1-arg case here.
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG3, 0(BASE)
  //|    lwz STR:CARG1, 4(BASE)
  //|  bne ->fff_fallback			// Need exactly 1 argument.
  //|   checkstr CARG3
  //|   bne ->fff_fallback
  //|  lwz TMP0, STR:CARG1->len
  dasm_put(Dst, 2676, LJ_TSTR, Dt5(->len), LJ_TSTR, Dt5(->len));
# 1809 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|   lbz CARG1, STR:CARG1[1]		// Access is always ok (NUL at end).
    //|   li RD, (0+1)*8
    //|   lwz PC, FRAME_PC(BASE)
    //|  cmplwi TMP0, 0
    //|   la RA, -8(BASE)
    //|  beqy ->fff_res
    //|  b ->fff_resi
    dasm_put(Dst, 2703, Dt5([1]), (0+1)*8);
# 1817 "buildvm_ppc.dasc"
  } else {
    //|   lbz TMP1, STR:CARG1[1]		// Access is always ok (NUL at end).
    //|  addic TMP3, TMP0, -1		// RD = ((str->len != 0)+1)*8
    //|  subfe RD, TMP3, TMP0
    //|   stw TMP1, TONUM_LO		// Inlined tonum_u f0, TMP1.
    //|  addi RD, RD, 1
    //|   lfd f0, TONUM_D
    //|  la RA, -8(BASE)
    //|  lwz PC, FRAME_PC(BASE)
    //|   fsub f0, f0, TOBIT
    //|  slwi RD, RD, 3
    //|   stfd f0, 0(RA)
    //|  b ->fff_res
    dasm_put(Dst, 2715, Dt5([1]), 31-3);
# 1830 "buildvm_ppc.dasc"
  }
  //|
  //|.ffunc string_char			// Only handle the 1-arg case here.
  //|  ffgccheck
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG3, 0(BASE)
  dasm_put(Dst, 2731, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
# 1836 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|    lwz TMP0, 4(BASE)
    //|  bne ->fff_fallback		// Exactly 1 argument.
    //|  checknum CARG3; bne ->fff_fallback
    //|   la CARG2, 7(BASE)
    dasm_put(Dst, 2742);
# 1841 "buildvm_ppc.dasc"
  } else {
    //|    lfd FARG1, 0(BASE)
    //|  bne ->fff_fallback		// Exactly 1 argument.
    //|  checknum CARG3; bge ->fff_fallback
    //|  toint TMP0, FARG1
    //|   la CARG2, TMPD_BLO
    dasm_put(Dst, 2750);
# 1847 "buildvm_ppc.dasc"
  }
  //|   li CARG3, 1
  //|  cmplwi TMP0, 255; bgt ->fff_fallback
  //|->fff_newstr:
  //|  mr CARG1, L
  //|  stw BASE, L->base
  //|  stw PC, SAVE_PC
  //|  bl extern lj_str_new		// (lua_State *L, char *str, size_t l)
  //|  // Returns GCstr *.
  //|  lwz BASE, L->base
  //|  li CARG3, LJ_TSTR
  //|  b ->fff_restv
  //|
  //|.ffunc string_sub
  //|  ffgccheck
  //|  cmplwi NARGS8:RC, 16
  //|   lwz CARG3, 16(BASE)
  dasm_put(Dst, 2761, Dt1(->base), Dt1(->base), LJ_TSTR, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
# 1864 "buildvm_ppc.dasc"
  if (!LJ_DUALNUM) {
    //|    lfd f0, 16(BASE)
    dasm_put(Dst, 2789);
# 1866 "buildvm_ppc.dasc"
  }
  //|   lwz TMP0, 0(BASE)
  //|    lwz STR:CARG1, 4(BASE)
  //|  blt ->fff_fallback
  //|   lwz CARG2, 8(BASE)
  dasm_put(Dst, 2791);
# 1871 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|    lwz TMP1, 12(BASE)
    dasm_put(Dst, 2797);
# 1873 "buildvm_ppc.dasc"
  } else {
    //|    lfd f1, 8(BASE)
    dasm_put(Dst, 2799);
# 1875 "buildvm_ppc.dasc"
  }
  //|   li TMP2, -1
  //|  beq >1
  dasm_put(Dst, 2801);
# 1878 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  checknum CARG3
    //|   lwz TMP2, 20(BASE)
    //|  bne ->fff_fallback
    //|1:
    //|  checknum CARG2; bne ->fff_fallback
    dasm_put(Dst, 2805);
# 1884 "buildvm_ppc.dasc"
  } else {
    //|  checknum CARG3; bge ->fff_fallback
    //|  toint TMP2, f0
    //|1:
    //|  checknum CARG2; bge ->fff_fallback
    dasm_put(Dst, 2814);
# 1889 "buildvm_ppc.dasc"
  }
  //|  checkstr TMP0; bne ->fff_fallback
  dasm_put(Dst, 2825, LJ_TSTR);
# 1891 "buildvm_ppc.dasc"
  if (!LJ_DUALNUM) {
    //|   toint TMP1, f1
    dasm_put(Dst, 2830);
# 1893 "buildvm_ppc.dasc"
  }
  //|   lwz TMP0, STR:CARG1->len
  //|  cmplw TMP0, TMP2			// len < end? (unsigned compare)
  //|   addi TMP3, TMP2, 1
  //|  blt >5
  //|2:
  //|  cmpwi TMP1, 0			// start <= 0?
  //|   add TMP3, TMP1, TMP0
  //|  ble >7
  //|3:
  //|  sub CARG3, TMP2, TMP1
  //|    addi CARG2, STR:CARG1, #STR-1
  //|  srawi TMP0, CARG3, 31
  //|   addi CARG3, CARG3, 1
  //|    add CARG2, CARG2, TMP1
  //|  andc CARG3, CARG3, TMP0
  //|  b ->fff_newstr
  //|
  //|5:  // Negative end or overflow.
  //|  sub CARG2, TMP0, TMP2
  //|  srawi CARG2, CARG2, 31
  //|  andc TMP3, TMP3, CARG2		// end = end > len ? len : end+len+1
  //|  add TMP2, TMP0, TMP3
  //|  b <2
  //|
  //|7:  // Negative start or underflow.
  //|  addic CARG3, TMP1, -1
  //|  subfe CARG3, CARG3, CARG3
  //|   srawi CARG2, TMP3, 31		// Note: modifies carry.
  //|  andc TMP3, TMP3, CARG3
  //|   andc TMP1, TMP3, CARG2
  //|  addi TMP1, TMP1, 1			// start = 1 + (start ? start+len : 0)
  //|  b <3
  //|
  //|.ffunc string_rep			// Only handle the 1-char case inline.
  //|  ffgccheck
  //|  cmplwi NARGS8:RC, 16
  //|   lwz TMP0, 0(BASE)
  //|    lwz STR:CARG1, 4(BASE)
  //|   lwz CARG4, 8(BASE)
  dasm_put(Dst, 2834, Dt5(->len), sizeof(GCstr)-1, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
# 1933 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|    lwz CARG3, 12(BASE)
    dasm_put(Dst, 2884);
# 1935 "buildvm_ppc.dasc"
  } else {
    //|    lfd FARG2, 8(BASE)
    dasm_put(Dst, 2886);
# 1937 "buildvm_ppc.dasc"
  }
  //|  blt ->fff_fallback
  //|  checkstr TMP0; bne ->fff_fallback
  dasm_put(Dst, 2888, LJ_TSTR);
# 1940 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  checknum CARG4; bne ->fff_fallback
    dasm_put(Dst, 2895);
# 1942 "buildvm_ppc.dasc"
  } else {
    //|  checknum CARG4; bge ->fff_fallback
    //|    toint CARG3, FARG2
    dasm_put(Dst, 2899);
# 1945 "buildvm_ppc.dasc"
  }
  //|   lwz TMP0, STR:CARG1->len
  //|  cmpwi CARG3, 0
  //|   lwz TMP1, DISPATCH_GL(tmpbuf.sz)(DISPATCH)
  //|  ble >2				// Count <= 0? (or non-int)
  //|   cmplwi TMP0, 1
  //|  subi TMP2, CARG3, 1
  //|   blt >2				// Zero length string?
  //|  cmplw cr1, TMP1, CARG3
  //|   bne ->fff_fallback		// Fallback for > 1-char strings.
  //|   lbz TMP0, STR:CARG1[1]
  //|   lwz CARG2, DISPATCH_GL(tmpbuf.buf)(DISPATCH)
  //|  blt cr1, ->fff_fallback
  //|1:  // Fill buffer with char. Yes, this is suboptimal code (do you care?).
  //|  cmplwi TMP2, 0
  //|   stbx TMP0, CARG2, TMP2
  //|   subi TMP2, TMP2, 1
  //|  bne <1
  //|  b ->fff_newstr
  //|2:  // Return empty string.
  //|  la STR:CARG1, DISPATCH_GL(strempty)(DISPATCH)
  //|  li CARG3, LJ_TSTR
  //|  b ->fff_restv
  //|
  //|.ffunc string_reverse
  //|  ffgccheck
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG3, 0(BASE)
  //|    lwz STR:CARG1, 4(BASE)
  //|  blt ->fff_fallback
  //|  checkstr CARG3
  //|   lwz TMP1, DISPATCH_GL(tmpbuf.sz)(DISPATCH)
  //|  bne ->fff_fallback
  dasm_put(Dst, 2906, Dt5(->len), DISPATCH_GL(tmpbuf.sz), Dt5([1]), DISPATCH_GL(tmpbuf.buf), DISPATCH_GL(strempty), LJ_TSTR, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), LJ_TSTR, DISPATCH_GL(tmpbuf.sz));
# 1978 "buildvm_ppc.dasc"
  //|  lwz CARG3, STR:CARG1->len
  //|   la CARG1, #STR(STR:CARG1)
  //|   lwz CARG2, DISPATCH_GL(tmpbuf.buf)(DISPATCH)
  //|   li TMP2, 0
  //|  cmplw TMP1, CARG3
  //|   subi TMP3, CARG3, 1
  //|  blt ->fff_fallback
  //|1:  // Reverse string copy.
  //|  cmpwi TMP3, 0
  //|   lbzx TMP1, CARG1, TMP2
  //|  blty ->fff_newstr
  //|   stbx TMP1, CARG2, TMP3
  //|  subi TMP3, TMP3, 1
  //|  addi TMP2, TMP2, 1
  //|  b <1
  //|
  //|.macro ffstring_case, name, lo
  //|  .ffunc name
  //|  ffgccheck
  //|  cmplwi NARGS8:RC, 8
  //|   lwz CARG3, 0(BASE)
  //|    lwz STR:CARG1, 4(BASE)
  //|  blt ->fff_fallback
  //|  checkstr CARG3
  //|   lwz TMP1, DISPATCH_GL(tmpbuf.sz)(DISPATCH)
  //|  bne ->fff_fallback
  //|  lwz CARG3, STR:CARG1->len
  //|   la CARG1, #STR(STR:CARG1)
  //|   lwz CARG2, DISPATCH_GL(tmpbuf.buf)(DISPATCH)
  //|  cmplw TMP1, CARG3
  //|   li TMP2, 0
  //|  blt ->fff_fallback
  //|1:  // ASCII case conversion.
  //|  cmplw TMP2, CARG3
  //|   lbzx TMP1, CARG1, TMP2
  //|  bgey ->fff_newstr
  //|   subi TMP0, TMP1, lo
  //|    xori TMP3, TMP1, 0x20
  //|   addic TMP0, TMP0, -26
  //|   subfe TMP3, TMP3, TMP3
  //|   andi. TMP3, TMP3, 0x20
  //|   xor TMP1, TMP1, TMP3
  //|   stbx TMP1, CARG2, TMP2
  //|  addi TMP2, TMP2, 1
  //|  b <1
  //|.endmacro
  //|
  //|ffstring_case string_lower, 65
  dasm_put(Dst, 2959, Dt5(->len), sizeof(GCstr), DISPATCH_GL(tmpbuf.buf), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), LJ_TSTR, DISPATCH_GL(tmpbuf.sz), Dt5(->len), sizeof(GCstr), DISPATCH_GL(tmpbuf.buf));
# 2026 "buildvm_ppc.dasc"
  //|ffstring_case string_upper, 97
  //|
  //|//-- Table library ------------------------------------------------------
  //|
  //|.ffunc_1 table_getn
  //|  checktab CARG3; bne ->fff_fallback
  //|  bl extern lj_tab_len		// (GCtab *t)
  //|  // Returns uint32_t (but less than 2^31).
  //|  b ->fff_resi
  //|
  //|//-- Bit library --------------------------------------------------------
  //|
  //|.macro .ffunc_bit, name
  //||if (LJ_DUALNUM) {
  //|  .ffunc_1 bit_..name
  //|  checknum CARG3; bnel ->fff_tobit_fb
  //||} else {
  //|  .ffunc_n bit_..name
  //|  fadd FARG1, FARG1, TOBIT
  //|  stfd FARG1, TMPD
  //|  lwz CARG1, TMPD_LO
  //||}
  //|.endmacro
  //|
  //|.macro .ffunc_bit_op, name, ins
  //|  .ffunc_bit name
  //|  addi TMP1, BASE, 8
  //|  add TMP2, BASE, NARGS8:RC
  //|1:
  //|  lwz CARG4, 0(TMP1)
  //|   cmplw cr1, TMP1, TMP2
  //||if (LJ_DUALNUM) {
  //|  lwz CARG2, 4(TMP1)
  //||} else {
  //|  lfd FARG1, 0(TMP1)
  //||}
  //|   bgey cr1, ->fff_resi
  //|  checknum CARG4
  //||if (LJ_DUALNUM) {
  //|  bnel ->fff_bitop_fb
  //||} else {
  //|  fadd FARG1, FARG1, TOBIT
  //|  bge ->fff_fallback
  //|  stfd FARG1, TMPD
  //|  lwz CARG2, TMPD_LO
  //||}
  //|  ins CARG1, CARG1, CARG2
  //|   addi TMP1, TMP1, 8
  //|  b <1
  //|.endmacro
  //|
  //|.ffunc_bit_op band, and
  dasm_put(Dst, 3017, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), LJ_TSTR, DISPATCH_GL(tmpbuf.sz), Dt5(->len), sizeof(GCstr), DISPATCH_GL(tmpbuf.buf), LJ_TTAB);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3086);
  } else {
  dasm_put(Dst, 3096);
  }
  dasm_put(Dst, 3109);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3115);
  } else {
  dasm_put(Dst, 3117);
  }
  dasm_put(Dst, 3119);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3123);
  } else {
  dasm_put(Dst, 3126);
  }
# 2078 "buildvm_ppc.dasc"
  //|.ffunc_bit_op bor, or
  dasm_put(Dst, 3132);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3137);
  } else {
  dasm_put(Dst, 3147);
  }
  dasm_put(Dst, 3160);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3166);
  } else {
  dasm_put(Dst, 3168);
  }
  dasm_put(Dst, 3170);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3174);
  } else {
  dasm_put(Dst, 3177);
  }
# 2079 "buildvm_ppc.dasc"
  //|.ffunc_bit_op bxor, xor
  dasm_put(Dst, 3183);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3188);
  } else {
  dasm_put(Dst, 3198);
  }
  dasm_put(Dst, 3211);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3217);
  } else {
  dasm_put(Dst, 3219);
  }
  dasm_put(Dst, 3221);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3225);
  } else {
  dasm_put(Dst, 3228);
  }
# 2080 "buildvm_ppc.dasc"
  //|
  //|.ffunc_bit bswap
  dasm_put(Dst, 3234);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3239);
  } else {
  dasm_put(Dst, 3249);
  }
# 2082 "buildvm_ppc.dasc"
  //|  rotlwi TMP0, CARG1, 8
  //|  rlwimi TMP0, CARG1, 24, 0, 7
  //|  rlwimi TMP0, CARG1, 24, 16, 23
  //|  mr CRET1, TMP0
  //|  b ->fff_resi
  //|
  //|.ffunc_bit bnot
  dasm_put(Dst, 3262);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3269);
  } else {
  dasm_put(Dst, 3279);
  }
# 2089 "buildvm_ppc.dasc"
  //|  not CRET1, CARG1
  //|  b ->fff_resi
  //|
  //|.macro .ffunc_bit_sh, name, ins, shmod
  //||if (LJ_DUALNUM) {
  //|  .ffunc_2 bit_..name
  //|  checknum CARG3; bnel ->fff_tobit_fb
  //|  // Note: no inline conversion from number for 2nd argument!
  //|  checknum CARG4; bne ->fff_fallback
  //||} else {
  //|  .ffunc_nn bit_..name
  //|  fadd FARG1, FARG1, TOBIT
  //|  fadd FARG2, FARG2, TOBIT
  //|  stfd FARG1, TMPD
  //|  lwz CARG1, TMPD_LO
  //|  stfd FARG2, TMPD
  //|  lwz CARG2, TMPD_LO
  //||}
  //|.if shmod == 1
  //|  rlwinm CARG2, CARG2, 0, 27, 31
  //|.elif shmod == 2
  //|  neg CARG2, CARG2
  //|.endif
  //|  ins CRET1, CARG1, CARG2
  //|  b ->fff_resi
  //|.endmacro
  //|
  //|.ffunc_bit_sh lshift, slw, 1
  dasm_put(Dst, 3292);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3296);
  } else {
  dasm_put(Dst, 3311);
  }
# 2117 "buildvm_ppc.dasc"
  //|.ffunc_bit_sh rshift, srw, 1
  dasm_put(Dst, 3332);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3337);
  } else {
  dasm_put(Dst, 3352);
  }
# 2118 "buildvm_ppc.dasc"
  //|.ffunc_bit_sh arshift, sraw, 1
  dasm_put(Dst, 3373);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3378);
  } else {
  dasm_put(Dst, 3393);
  }
# 2119 "buildvm_ppc.dasc"
  //|.ffunc_bit_sh rol, rotlw, 0
  dasm_put(Dst, 3414);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3419);
  } else {
  dasm_put(Dst, 3434);
  }
# 2120 "buildvm_ppc.dasc"
  //|.ffunc_bit_sh ror, rotlw, 2
  dasm_put(Dst, 3455);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3459);
  } else {
  dasm_put(Dst, 3474);
  }
# 2121 "buildvm_ppc.dasc"
  //|
  //|.ffunc_bit tobit
  dasm_put(Dst, 3495);
  if (LJ_DUALNUM) {
  dasm_put(Dst, 3500);
  } else {
  dasm_put(Dst, 3510);
  }
# 2123 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  b ->fff_resi
    dasm_put(Dst, 3523);
# 2125 "buildvm_ppc.dasc"
  } else {
    //|->fff_resi:
    //|  tonum_i FARG1, CRET1
    dasm_put(Dst, 3526);
# 2128 "buildvm_ppc.dasc"
  }
  //|->fff_resn:
  //|  lwz PC, FRAME_PC(BASE)
  //|  la RA, -8(BASE)
  //|  stfd FARG1, -8(BASE)
  //|  b ->fff_res1
  //|
  //|// Fallback FP number to bit conversion.
  //|->fff_tobit_fb:
  dasm_put(Dst, 3532);
# 2137 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  lfd FARG1, 0(BASE)
    //|  bgt ->fff_fallback
    //|  fadd FARG1, FARG1, TOBIT
    //|  stfd FARG1, TMPD
    //|  lwz CARG1, TMPD_LO
    //|  blr
    dasm_put(Dst, 3540);
# 2144 "buildvm_ppc.dasc"
  }
  //|->fff_bitop_fb:
  dasm_put(Dst, 3548);
# 2146 "buildvm_ppc.dasc"
  if (LJ_DUALNUM) {
    //|  lfd FARG1, 0(TMP1)
    //|  bgt ->fff_fallback
    //|  fadd FARG1, FARG1, TOBIT
    //|  stfd FARG1, TMPD
    //|  lwz CARG2, TMPD_LO
    //|  blr
    dasm_put(Dst, 3550);
# 2153 "buildvm_ppc.dasc"
  }
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->fff_fallback:			// Call fast function fallback handler.
  //|  // BASE = new base, RB = CFUNC, RC = nargs*8
  //|  lwz TMP3, CFUNC:RB->f
  //|    add TMP1, BASE, NARGS8:RC
  //|   lwz PC, FRAME_PC(BASE)		// Fallback may overwrite PC.
  //|    addi TMP0, TMP1, 8*LUA_MINSTACK
  //|     lwz TMP2, L->maxstack
  //|   stw PC, SAVE_PC			// Redundant (but a defined value).
  //|  cmplw TMP0, TMP2
  //|     stw BASE, L->base
  //|    stw TMP1, L->top
  //|   mr CARG1, L
  //|  bgt >5				// Need to grow stack.
  //|  mtctr TMP3
  //|  bctrl				// (lua_State *L)
  //|  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
  //|  lwz BASE, L->base
  //|  cmpwi CRET1, 0
  //|   slwi RD, CRET1, 3
  //|   la RA, -8(BASE)
  //|  bgt ->fff_res			// Returned nresults+1?
  //|1:  // Returned 0 or -1: retry fast path.
  //|  lwz TMP0, L->top
  //|   lwz LFUNC:RB, FRAME_FUNC(BASE)
  //|  sub NARGS8:RC, TMP0, BASE
  //|  bne ->vm_call_tail			// Returned -1?
  //|  ins_callt				// Returned 0: retry fast path.
  //|
  //|// Reconstruct previous base for vmeta_call during tailcall.
  //|->vm_call_tail:
  //|  andi. TMP0, PC, FRAME_TYPE
  //|   rlwinm TMP1, PC, 0, 0, 28
  //|  bne >3
  //|  lwz INS, -4(PC)
  //|  decode_RA8 TMP1, INS
  //|3:
  //|  sub TMP2, BASE, TMP1
  //|  b ->vm_call_dispatch		// Resolve again for tailcall.
  //|
  //|5:  // Grow stack for fallback handler.
  //|  li CARG2, LUA_MINSTACK
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  lwz BASE, L->base
  dasm_put(Dst, 3558, Dt8(->f), 8*LUA_MINSTACK, Dt1(->maxstack), Dt1(->base), Dt1(->top), Dt1(->base), 31-3, Dt1(->top), Dt7(->pc), FRAME_TYPE, LUA_MINSTACK);
# 2200 "buildvm_ppc.dasc"
  //|  cmpw TMP0, TMP0			// Set 4*cr0+eq to force retry.
  //|  b <1
  //|
  //|->fff_gcstep:			// Call GC step function.
  //|  // BASE = new base, RC = nargs*8
  //|  mflr SAVE0
  //|   stw BASE, L->base
  //|  add TMP0, BASE, NARGS8:RC
  //|   stw PC, SAVE_PC			// Redundant (but a defined value).
  //|  stw TMP0, L->top
  //|  mr CARG1, L
  //|  bl extern lj_gc_step		// (lua_State *L)
  //|   lwz BASE, L->base
  //|  mtlr SAVE0
  //|    lwz TMP0, L->top
  //|   sub NARGS8:RC, TMP0, BASE
  //|   lwz CFUNC:RB, FRAME_FUNC(BASE)
  //|  blr
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Special dispatch targets -------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_record:				// Dispatch target for recording phase.
  dasm_put(Dst, 3621, Dt1(->base), Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top));
# 2224 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|  lbz TMP3, DISPATCH_GL(hookmask)(DISPATCH)
  //|  andi. TMP0, TMP3, HOOK_VMEVENT	// No recording while in vmevent.
  //|  bne >5
  //|  // Decrement the hookcount for consistency, but always do the call.
  //|   lwz TMP2, DISPATCH_GL(hookcount)(DISPATCH)
  //|  andi. TMP0, TMP3, HOOK_ACTIVE
  //|  bne >1
  //|   subi TMP2, TMP2, 1
  //|  andi. TMP0, TMP3, LUA_MASKLINE|LUA_MASKCOUNT
  //|  beqy >1
  //|   stw TMP2, DISPATCH_GL(hookcount)(DISPATCH)
  //|  b >1
  dasm_put(Dst, 3647, DISPATCH_GL(hookmask), HOOK_VMEVENT, DISPATCH_GL(hookcount), HOOK_ACTIVE, LUA_MASKLINE|LUA_MASKCOUNT, DISPATCH_GL(hookcount));
# 2237 "buildvm_ppc.dasc"
#endif
  //|
  //|->vm_rethook:			// Dispatch target for return hooks.
  //|  lbz TMP3, DISPATCH_GL(hookmask)(DISPATCH)
  //|  andi. TMP0, TMP3, HOOK_ACTIVE	// Hook already active?
  //|  beq >1
  //|5:  // Re-dispatch to static ins.
  //|  addi TMP1, TMP1, GG_DISP2STATIC	// Assumes decode_OP4 TMP1, INS.
  //|  lwzx TMP0, DISPATCH, TMP1
  //|  mtctr TMP0
  //|  bctr
  //|
  //|->vm_inshook:			// Dispatch target for instr/line hooks.
  //|  lbz TMP3, DISPATCH_GL(hookmask)(DISPATCH)
  //|  lwz TMP2, DISPATCH_GL(hookcount)(DISPATCH)
  //|  andi. TMP0, TMP3, HOOK_ACTIVE	// Hook already active?
  //|   rlwinm TMP0, TMP3, 31-LUA_HOOKLINE, 31, 0
  //|  bne <5
  //|
  //|   cmpwi cr1, TMP0, 0
  //|  addic. TMP2, TMP2, -1
  //|   beq cr1, <5
  //|  stw TMP2, DISPATCH_GL(hookcount)(DISPATCH)
  //|  beq >1
  //|   bge cr1, <5
  //|1:
  //|  mr CARG1, L
  //|   stw MULTRES, SAVE_MULTRES
  //|  mr CARG2, PC
  //|   stw BASE, L->base
  //|  // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
  //|  bl extern lj_dispatch_ins		// (lua_State *L, const BCIns *pc)
  //|3:
  //|  lwz BASE, L->base
  //|4:  // Re-dispatch to static ins.
  //|  lwz INS, -4(PC)
  dasm_put(Dst, 3669, DISPATCH_GL(hookmask), HOOK_ACTIVE, GG_DISP2STATIC, DISPATCH_GL(hookmask), DISPATCH_GL(hookcount), HOOK_ACTIVE, 31-LUA_HOOKLINE, DISPATCH_GL(hookcount), Dt1(->base), Dt1(->base));
# 2273 "buildvm_ppc.dasc"
  //|  decode_OP4 TMP1, INS
  //|   decode_RB8 RB, INS
  //|  addi TMP1, TMP1, GG_DISP2STATIC
  //|   decode_RD8 RD, INS
  //|  lwzx TMP0, DISPATCH, TMP1
  //|   decode_RA8 RA, INS
  //|   decode_RC8 RC, INS
  //|  mtctr TMP0
  //|  bctr
  //|
  //|->cont_hook:				// Continue from hook yield.
  //|  addi PC, PC, 4
  //|  lwz MULTRES, -20(RB)		// Restore MULTRES for *M ins.
  //|  b <4
  //|
  //|->vm_hotloop:			// Hot loop counter underflow.
  dasm_put(Dst, 3716, GG_DISP2STATIC);
# 2289 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|  lwz LFUNC:TMP1, FRAME_FUNC(BASE)
  //|   addi CARG1, DISPATCH, GG_DISP2J
  //|   stw PC, SAVE_PC
  //|  lwz TMP1, LFUNC:TMP1->pc
  //|   mr CARG2, PC
  //|   stw L, DISPATCH_J(L)(DISPATCH)
  //|  lbz TMP1, PC2PROTO(framesize)(TMP1)
  //|   stw BASE, L->base
  //|  slwi TMP1, TMP1, 3
  //|  add TMP1, BASE, TMP1
  //|  stw TMP1, L->top
  //|  bl extern lj_trace_hot		// (jit_State *J, const BCIns *pc)
  //|  b <3
  dasm_put(Dst, 3734, GG_DISP2J, Dt7(->pc), DISPATCH_J(L), PC2PROTO(framesize), Dt1(->base), 31-3, Dt1(->top));
# 2303 "buildvm_ppc.dasc"
#endif
  //|
  //|->vm_callhook:			// Dispatch target for call hooks.
  //|  mr CARG2, PC
  dasm_put(Dst, 3757);
# 2307 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|  b >1
  dasm_put(Dst, 3760);
# 2309 "buildvm_ppc.dasc"
#endif
  //|
  //|->vm_hotcall:			// Hot call counter underflow.
  dasm_put(Dst, 3763);
# 2312 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|  ori CARG2, PC, 1
  //|1:
  dasm_put(Dst, 3765);
# 2315 "buildvm_ppc.dasc"
#endif
  //|  add TMP0, BASE, RC
  //|   stw PC, SAVE_PC
  //|  mr CARG1, L
  //|   stw BASE, L->base
  //|  sub RA, RA, BASE
  //|   stw TMP0, L->top
  //|  bl extern lj_dispatch_call		// (lua_State *L, const BCIns *pc)
  //|  // Returns ASMFunction.
  //|  lwz BASE, L->base
  //|   lwz TMP0, L->top
  //|   stw ZERO, SAVE_PC			// Invalidate for subsequent line hook.
  //|  sub NARGS8:RC, TMP0, BASE
  //|  add RA, BASE, RA
  //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
  //|  lwz INS, -4(PC)
  //|  mtctr CRET1
  //|  bctr
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Trace exit handler -------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|.macro savex_, a, b, c, d
  //|  stfd f..a, 16+a*8(sp)
  //|  stfd f..b, 16+b*8(sp)
  //|  stfd f..c, 16+c*8(sp)
  //|  stfd f..d, 16+d*8(sp)
  //|.endmacro
  //|
  //|->vm_exit_handler:
  dasm_put(Dst, 3768, Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top));
# 2346 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|  addi sp, sp, -(16+32*8+32*4)
  //|  stmw r2, 16+32*8+2*4(sp)
  //|    addi DISPATCH, JGL, -GG_DISP2G-32768
  //|    li CARG2, ~LJ_VMST_EXIT
  //|   lwz CARG1, 16+32*8+32*4(sp)	// Get stack chain.
  //|    stw CARG2, DISPATCH_GL(vmstate)(DISPATCH)
  //|  savex_ 0,1,2,3
  //|   stw CARG1, 0(sp)			// Store extended stack chain.
  //|   mcrxr cr0				// Clear SO flag.
  //|  savex_ 4,5,6,7
  //|   addi CARG2, sp, 16+32*8+32*4	// Recompute original value of sp.
  //|  savex_ 8,9,10,11
  //|   stw CARG2, 16+32*8+1*4(sp)	// Store sp in RID_SP.
  //|  savex_ 12,13,14,15
  dasm_put(Dst, 3791, -(16+32*8+32*4), 16+32*8+2*4, -GG_DISP2G-32768, ~LJ_VMST_EXIT, 16+32*8+32*4, DISPATCH_GL(vmstate), 16+0*8, 16+1*8, 16+2*8, 16+3*8, 16+4*8, 16+5*8, 16+6*8, 16+7*8, 16+32*8+32*4, 16+8*8, 16+9*8, 16+10*8, 16+11*8, 16+32*8+1*4, 16+12*8, 16+13*8);
# 2361 "buildvm_ppc.dasc"
  //|   mflr CARG3
  //|   li TMP1, 0
  //|  savex_ 16,17,18,19
  //|   stw TMP1, 16+32*8+0*4(sp)		// Clear RID_TMP.
  //|  savex_ 20,21,22,23
  //|   lhz CARG4, 2(CARG3)		// Load trace number.
  //|  savex_ 24,25,26,27
  //|  lwz L, DISPATCH_GL(jit_L)(DISPATCH)
  //|  savex_ 28,29,30,31
  //|   sub CARG3, TMP0, CARG3		// Compute exit number.
  //|  lwz BASE, DISPATCH_GL(jit_base)(DISPATCH)
  //|   srwi CARG3, CARG3, 2
  //|  stw L, DISPATCH_J(L)(DISPATCH)
  dasm_put(Dst, 3838, 16+14*8, 16+15*8, 16+16*8, 16+17*8, 16+18*8, 16+19*8, 16+32*8+0*4, 16+20*8, 16+21*8, 16+22*8, 16+23*8, 16+24*8, 16+25*8, 16+26*8, 16+27*8, DISPATCH_GL(jit_L), 16+28*8, 16+29*8, 16+30*8, 16+31*8, DISPATCH_GL(jit_base), 32-2);
# 2374 "buildvm_ppc.dasc"
  //|   subi CARG3, CARG3, 2
  //|  stw TMP1, DISPATCH_GL(jit_L)(DISPATCH)
  //|   stw CARG4, DISPATCH_J(parent)(DISPATCH)
  //|  stw BASE, L->base
  //|  addi CARG1, DISPATCH, GG_DISP2J
  //|   stw CARG3, DISPATCH_J(exitno)(DISPATCH)
  //|  addi CARG2, sp, 16
  //|  bl extern lj_trace_exit		// (jit_State *J, ExitState *ex)
  //|  // Returns MULTRES (unscaled) or negated error code.
  //|  lwz TMP1, L->cframe
  //|  lwz TMP2, 0(sp)
  //|   lwz BASE, L->base
  //|  rlwinm sp, TMP1, 0, 0, 29
  //|   lwz PC, SAVE_PC			// Get SAVE_PC.
  //|  stw TMP2, 0(sp)
  //|  stw L, SAVE_L			// Set SAVE_L (on-trace resume/yield).
  //|  b >1
  dasm_put(Dst, 3887, DISPATCH_J(L), DISPATCH_GL(jit_L), DISPATCH_J(parent), Dt1(->base), GG_DISP2J, DISPATCH_J(exitno), Dt1(->cframe), Dt1(->base));
# 2391 "buildvm_ppc.dasc"
#endif
  //|->vm_exit_interp:
  dasm_put(Dst, 3915);
# 2393 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|  // CARG1 = MULTRES or negated error code, BASE, PC and JGL set.
  //|  lwz L, SAVE_L
  //|  addi DISPATCH, JGL, -GG_DISP2G-32768
  //|1:
  //|  cmpwi CARG1, 0
  //|  blt >3				// Check for error from exit.
  //|  lwz LFUNC:TMP1, FRAME_FUNC(BASE)
  //|   slwi MULTRES, CARG1, 3
  //|    li TMP2, 0
  //|   stw MULTRES, SAVE_MULTRES
  //|  lwz TMP1, LFUNC:TMP1->pc
  //|    stw TMP2, DISPATCH_GL(jit_L)(DISPATCH)
  //|  lwz KBASE, PC2PROTO(k)(TMP1)
  //|  // Setup type comparison constants.
  //|  li TISNUM, LJ_TISNUM
  //|  lus TMP3, 0x59c0			// TOBIT = 2^52 + 2^51 (float).
  //|  stw TMP3, TMPD
  //|  li ZERO, 0
  //|  ori TMP3, TMP3, 0x0004		// TONUM = 2^52 + 2^51 + 2^31 (float).
  //|  lfs TOBIT, TMPD
  //|  stw TMP3, TMPD
  //|  lus TMP0, 0x4338			// Hiword of 2^52 + 2^51 (double)
  //|    li TISNIL, LJ_TNIL
  //|  stw TMP0, TONUM_HI
  //|  lfs TONUM, TMPD
  //|  // Modified copy of ins_next which handles function header dispatch, too.
  //|  lwz INS, 0(PC)
  //|   addi PC, PC, 4
  //|    // Assumes TISNIL == ~LJ_VMST_INTERP == -1.
  //|    stw TISNIL, DISPATCH_GL(vmstate)(DISPATCH)
  //|  decode_OP4 TMP1, INS
  //|   decode_RA8 RA, INS
  //|  lwzx TMP0, DISPATCH, TMP1
  //|  mtctr TMP0
  //|  cmplwi TMP1, BC_FUNCF*4		// Function header?
  //|  bge >2
  //|   decode_RB8 RB, INS
  //|   decode_RD8 RD, INS
  //|   decode_RC8 RC, INS
  //|  bctr
  //|2:
  //|   subi RC, MULTRES, 8
  //|   add RA, RA, BASE
  //|  bctr
  //|
  //|3:  // Rethrow error from the right C frame.
  //|  neg CARG2, CARG1
  //|  mr CARG1, L
  //|  bl extern lj_err_throw		// (lua_State *L, int errcode)
  dasm_put(Dst, 3917, -GG_DISP2G-32768, 31-3, Dt7(->pc), DISPATCH_GL(jit_L), PC2PROTO(k), LJ_TISNUM, LJ_TNIL, DISPATCH_GL(vmstate), BC_FUNCF*4);
# 2443 "buildvm_ppc.dasc"
#endif
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Math helper functions ----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|  // NYI: Use internal implementation.
  //|->vm_floor:
  //|  b extern floor
  //|->vm_ceil:
  //|  b extern ceil
  //|->vm_trunc:
  dasm_put(Dst, 3974);
# 2455 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|  b extern trunc
  dasm_put(Dst, 3982);
# 2457 "buildvm_ppc.dasc"
#endif
  //|
  //|->vm_modi:
  //|  divwo. TMP0, CARG1, CARG2
  //|  bso >1
  //|   xor. CARG3, CARG1, CARG2
  //|  mullw TMP0, TMP0, CARG2
  //|  sub CARG1, CARG1, TMP0
  //|   bgelr
  //|  cmpwi CARG1, 0; beqlr
  //|  add CARG1, CARG1, CARG2
  //|  blr
  //|1:
  //|  cmpwi CARG2, 0
  //|   li CARG1, 0
  //|  beqlr
  //|  mcrxr cr0			// Clear SO for -2147483648 % -1 and return 0.
  //|  blr
  //|
  //|// Callable from C: double lj_vm_foldarith(double x, double y, int op)
  //|// Compute x op y for basic arithmetic operators (+ - * / % ^ and unary -)
  //|// and basic math functions. ORDER ARITH
  //|->vm_foldarith:
  //|  cmplwi CARG1, 1
  //|  beq >1; bgt >2
  //|  fadd FARG1, FARG1, FARG2; blr
  //|1:
  //|  fsub FARG1, FARG1, FARG2; blr
  //|2:
  //|   cmplwi CARG1, 3; beq >1; bgt >2
  //|  fmul FARG1, FARG1, FARG2; blr
  //|1:
  //|  fdiv FARG1, FARG1, FARG2; blr
  //|2:
  //|   cmplwi CARG1, 5; beq >1; bgt >2
  //|  // NYI: Use internal implementation of floor and avoid spills.
  //|  stwu sp, -32(sp); stfd f14, 16(sp); stfd f15, 24(sp)
  //|   mflr r0
  //|  fmr f14, FARG1
  //|  fdiv FARG1, FARG1, FARG2
  //|   stw r0, 36(sp)
  //|  fmr f15, FARG2
  //|  bl extern floor
  //|   lwz r0, 36(sp)
  //|  fmul FARG1, FARG1, f15
  //|   mtlr r0
  //|  fsub FARG1, f14, FARG1
  //|  lfd f14, 16(sp); lfd f15, 24(sp); addi sp, sp, 32; blr
  //|1:
  //|  b extern pow
  //|2:
  //|   cmplwi CARG1, 7; beq >1; bgt >2
  //|  fneg FARG1, FARG1; blr
  //|1:
  //|  fabs FARG1, FARG1; blr
  //|2:
  dasm_put(Dst, 3985);
# 2513 "buildvm_ppc.dasc"
#if LJ_HASJIT
  //|   cmplwi CARG1, 9; beq >9; bgt >2
  //|  b extern atan2
  //|  // No support needed for IR_LDEXP.
  //|2:
  //|   cmplwi CARG1, 11; bgt >9
  //|  fsub f0, FARG1, FARG2
  //|  beq >1
  //|  fsel FARG1, f0, FARG2, FARG1	// IR_MAX
  //|  blr
  //|1:
  //|  fsel FARG1, f0, FARG1, FARG2	// IR_MIN
  //|  blr
  //|9:
  //|  NYI  // Bad op.
  dasm_put(Dst, 4065);
# 2528 "buildvm_ppc.dasc"
#else
  //|  NYI  // Other operations only needed by JIT compiler.
  dasm_put(Dst, 4087);
# 2530 "buildvm_ppc.dasc"
#endif
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Miscellaneous functions --------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|// void lj_vm_cachesync(void *start, void *end)
  //|// Flush D-Cache and invalidate I-Cache. Assumes 32 byte cache line size.
  //|// This is a good lower bound, except for very ancient PPC models.
  //|->vm_cachesync:
  //|  // Compute start of first cache line and number of cache lines.
  //|  rlwinm CARG1, CARG1, 0, 0, 26
  //|  sub CARG2, CARG2, CARG1
  //|  addi CARG2, CARG2, 31
  //|  rlwinm. CARG2, CARG2, 27, 5, 31
  //|  beqlr
  //|  mtctr CARG2
  //|  mr CARG3, CARG1
  //|1:  // Flush D-Cache.
  //|  dcbst r0, CARG1
  //|  addi CARG1, CARG1, 32
  //|  bdnz <1
  //|  sync
  //|  mtctr CARG2
  //|1:  // Invalidate I-Cache.
  //|  icbi r0, CARG3
  //|  addi CARG3, CARG3, 32
  //|  bdnz <1
  //|  isync
  //|  blr
  //|
  //|//-----------------------------------------------------------------------
  //|//-- FFI helper functions -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|// Handler for callback functions. Callback slot number in r11, g in r12.
  //|->vm_ffi_callback:
  dasm_put(Dst, 4089);
# 2567 "buildvm_ppc.dasc"
#if LJ_HASFFI
  //|.type CTSTATE, CTState, PC
#define DtE(_V) (int)(ptrdiff_t)&(((CTState *)0)_V)
# 2569 "buildvm_ppc.dasc"
  //|  saveregs
  dasm_put(Dst, 4113, 56+(14-14)*4, 128+(14-14)*8, 56+(15-14)*4, 128+(15-14)*8, 56+(16-14)*4, 128+(16-14)*8, 56+(17-14)*4, 128+(17-14)*8, 56+(18-14)*4, 128+(18-14)*8, 56+(19-14)*4, 128+(19-14)*8, 56+(20-14)*4, 128+(20-14)*8, 56+(21-14)*4, 128+(21-14)*8, 56+(22-14)*4, 128+(22-14)*8, 56+(23-14)*4, 128+(23-14)*8, 56+(24-14)*4, 128+(24-14)*8);
# 2570 "buildvm_ppc.dasc"
  //|  lwz CTSTATE, GL:r12->ctype_state
  //|   addi DISPATCH, r12, GG_G2DISP
  //|  stw r11, CTSTATE->cb.slot
  //|  stw r3, CTSTATE->cb.gpr[0]
  //|   stfd f1, CTSTATE->cb.fpr[0]
  //|  stw r4, CTSTATE->cb.gpr[1]
  //|   stfd f2, CTSTATE->cb.fpr[1]
  //|  stw r5, CTSTATE->cb.gpr[2]
  //|   stfd f3, CTSTATE->cb.fpr[2]
  dasm_put(Dst, 4161, 56+(25-14)*4, 128+(25-14)*8, 56+(26-14)*4, 128+(26-14)*8, 56+(27-14)*4, 128+(27-14)*8, 56+(28-14)*4, 128+(28-14)*8, 56+(29-14)*4, 128+(29-14)*8, 56+(30-14)*4, 128+(30-14)*8, 56+(31-14)*4, 128+(31-14)*8, Dt2(->ctype_state), GG_G2DISP, DtE(->cb.slot), DtE(->cb.gpr[0]), DtE(->cb.fpr[0]), DtE(->cb.gpr[1]), DtE(->cb.fpr[1]), DtE(->cb.gpr[2]));
# 2579 "buildvm_ppc.dasc"
  //|  stw r6, CTSTATE->cb.gpr[3]
  //|   stfd f4, CTSTATE->cb.fpr[3]
  //|  stw r7, CTSTATE->cb.gpr[4]
  //|   stfd f5, CTSTATE->cb.fpr[4]
  //|  stw r8, CTSTATE->cb.gpr[5]
  //|   stfd f6, CTSTATE->cb.fpr[5]
  //|  stw r9, CTSTATE->cb.gpr[6]
  //|   stfd f7, CTSTATE->cb.fpr[6]
  //|  stw r10, CTSTATE->cb.gpr[7]
  //|   stfd f8, CTSTATE->cb.fpr[7]
  //|  addi TMP0, sp, CFRAME_SPACE+8
  //|  stw TMP0, CTSTATE->cb.stack
  //|   mr CARG1, CTSTATE
  //|  stw CTSTATE, SAVE_PC		// Any value outside of bytecode is ok.
  //|   mr CARG2, sp
  //|  bl extern lj_ccallback_enter	// (CTState *cts, void *cf)
  //|  // Returns lua_State *.
  //|  lwz BASE, L:CRET1->base
  //|     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
  //|  lwz RC, L:CRET1->top
  //|     lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
  //|     li ZERO, 0
  //|   mr L, CRET1
  //|     stw TMP3, TMPD
  //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
  //|     ori TMP3, TMP3, 0x0004		// TONUM = 2^52 + 2^51 + 2^31 (float).
  //|     li TISNIL, LJ_TNIL
  //|    li_vmstate INTERP
  //|     lfs TOBIT, TMPD
  //|     stw TMP3, TMPD
  //|  sub RC, RC, BASE
  //|    st_vmstate
  //|     lfs TONUM, TMPD
  //|  ins_callt
  dasm_put(Dst, 4208, DtE(->cb.fpr[2]), DtE(->cb.gpr[3]), DtE(->cb.fpr[3]), DtE(->cb.gpr[4]), DtE(->cb.fpr[4]), DtE(->cb.gpr[5]), DtE(->cb.fpr[5]), DtE(->cb.gpr[6]), DtE(->cb.fpr[6]), DtE(->cb.gpr[7]), DtE(->cb.fpr[7]), 272+8, DtE(->cb.stack), Dt1(->base), LJ_TISNUM, Dt1(->top), LJ_TNIL, ~LJ_VMST_INTERP, DISPATCH_GL(vmstate), Dt7(->pc));
# 2613 "buildvm_ppc.dasc"
#endif
  //|
  //|->cont_ffi_callback:			// Return from FFI callback.
  dasm_put(Dst, 4272);
# 2616 "buildvm_ppc.dasc"
#if LJ_HASFFI
  //|  lwz CTSTATE, DISPATCH_GL(ctype_state)(DISPATCH)
  //|   stw BASE, L->base
  //|   stw RB, L->top
  //|  stw L, CTSTATE->L
  //|  mr CARG1, CTSTATE
  //|  mr CARG2, RA
  //|  bl extern lj_ccallback_leave	// (CTState *cts, TValue *o)
  //|  lwz CRET1, CTSTATE->cb.gpr[0]
  //|  lfd FARG1, CTSTATE->cb.fpr[0]
  //|  lwz CRET2, CTSTATE->cb.gpr[1]
  //|  b ->vm_leave_unw
  dasm_put(Dst, 4274, DISPATCH_GL(ctype_state), Dt1(->base), Dt1(->top), DtE(->L), DtE(->cb.gpr[0]), DtE(->cb.fpr[0]), DtE(->cb.gpr[1]));
# 2628 "buildvm_ppc.dasc"
#endif
  //|
  //|->vm_ffi_call:			// Call C function via FFI.
  //|  // Caveat: needs special frame unwinding, see below.
  dasm_put(Dst, 4295);
# 2632 "buildvm_ppc.dasc"
#if LJ_HASFFI
  //|  .type CCSTATE, CCallState, CARG1
#define DtF(_V) (int)(ptrdiff_t)&(((CCallState *)0)_V)
# 2634 "buildvm_ppc.dasc"
  //|  lwz TMP1, CCSTATE->spadj
  //|    mflr TMP0
  //|   lbz CARG2, CCSTATE->nsp
  //|   lbz CARG3, CCSTATE->nfpr
  //|  neg TMP1, TMP1
  //|    stw TMP0, 4(sp)
  //|   cmpwi cr1, CARG3, 0
  //|  mr TMP2, sp
  //|   addic. CARG2, CARG2, -1
  //|  stwux sp, sp, TMP1
  //|   crnot 4*cr1+eq, 4*cr1+eq		// For vararg calls.
  //|  stw r14, -4(TMP2)
  //|  stw CCSTATE, -8(TMP2)
  //|  mr r14, TMP2
  //|  la TMP1, CCSTATE->stack
  //|   slwi CARG2, CARG2, 2
  //|   blty >2
  //|  la TMP2, 8(sp)
  //|1:
  //|  lwzx TMP0, TMP1, CARG2
  //|  stwx TMP0, TMP2, CARG2
  //|   addic. CARG2, CARG2, -4
  //|  bge <1
  //|2:
  //|  bney cr1, >3
  //|  lfd f1, CCSTATE->fpr[0]
  //|  lfd f2, CCSTATE->fpr[1]
  //|  lfd f3, CCSTATE->fpr[2]
  //|  lfd f4, CCSTATE->fpr[3]
  //|  lfd f5, CCSTATE->fpr[4]
  //|  lfd f6, CCSTATE->fpr[5]
  //|  lfd f7, CCSTATE->fpr[6]
  //|  lfd f8, CCSTATE->fpr[7]
  //|3:
  //|   lwz TMP0, CCSTATE->func
  //|  lwz CARG2, CCSTATE->gpr[1]
  //|  lwz CARG3, CCSTATE->gpr[2]
  //|  lwz CARG4, CCSTATE->gpr[3]
  dasm_put(Dst, 4297, DtF(->spadj), DtF(->nsp), DtF(->nfpr), DtF(->stack), 31-2, DtF(->fpr[0]), DtF(->fpr[1]), DtF(->fpr[2]), DtF(->fpr[3]), DtF(->fpr[4]), DtF(->fpr[5]), DtF(->fpr[6]), DtF(->fpr[7]), DtF(->func), DtF(->gpr[1]), DtF(->gpr[2]));
# 2672 "buildvm_ppc.dasc"
  //|  lwz CARG5, CCSTATE->gpr[4]
  //|   mtctr TMP0
  //|  lwz r8, CCSTATE->gpr[5]
  //|  lwz r9, CCSTATE->gpr[6]
  //|  lwz r10, CCSTATE->gpr[7]
  //|  lwz CARG1, CCSTATE->gpr[0]		// Do this last, since CCSTATE is CARG1.
  //|   bctrl
  //|  lwz CCSTATE:TMP1, -8(r14)
  //|  lwz TMP2, -4(r14)
  //|   lwz TMP0, 4(r14)
  //|  stw CARG1, CCSTATE:TMP1->gpr[0]
  //|  stfd FARG1, CCSTATE:TMP1->fpr[0]
  //|  stw CARG2, CCSTATE:TMP1->gpr[1]
  //|   mtlr TMP0
  //|  stw CARG3, CCSTATE:TMP1->gpr[2]
  //|   mr sp, r14
  //|  stw CARG4, CCSTATE:TMP1->gpr[3]
  //|   mr r14, TMP2
  //|  blr
  dasm_put(Dst, 4354, DtF(->gpr[3]), DtF(->gpr[4]), DtF(->gpr[5]), DtF(->gpr[6]), DtF(->gpr[7]), DtF(->gpr[0]), DtF(->gpr[0]), DtF(->fpr[0]), DtF(->gpr[1]), DtF(->gpr[2]), DtF(->gpr[3]));
# 2691 "buildvm_ppc.dasc"
#endif
  //|// Note: vm_ffi_call must be the last function in this object file!
  //|
  //|//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  //|=>defop:
  dasm_put(Dst, 4386, defop);
# 2702 "buildvm_ppc.dasc"

  switch (op) {

  /* -- Comparison ops ---------------------------------------------------- */

  /* Remember: all ops branch for a true comparison, fall through otherwise. */

  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
    //|  // RA = src1*8, RD = src2*8, JMP with RD = target
    if (LJ_DUALNUM) {
      //|  lwzux TMP0, RA, BASE
      //|    addi PC, PC, 4
      //|   lwz CARG2, 4(RA)
      //|  lwzux TMP1, RD, BASE
      //|    lwz TMP2, -4(PC)
      //|  checknum cr0, TMP0
      //|   lwz CARG3, 4(RD)
      //|    decode_RD4 TMP2, TMP2
      //|  checknum cr1, TMP1
      //|    addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
      //|  bne cr0, >7
      //|  bne cr1, >8
      //|   cmpw CARG2, CARG3
      dasm_put(Dst, 4388, -(BCBIAS_J*4 >> 16));
# 2725 "buildvm_ppc.dasc"
      if (op == BC_ISLT) {
	//|  bge >2
	dasm_put(Dst, 4405);
# 2727 "buildvm_ppc.dasc"
      } else if (op == BC_ISGE) {
	//|  blt >2
	dasm_put(Dst, 4408);
# 2729 "buildvm_ppc.dasc"
      } else if (op == BC_ISLE) {
	//|  bgt >2
	dasm_put(Dst, 4411);
# 2731 "buildvm_ppc.dasc"
      } else {
	//|  ble >2
	dasm_put(Dst, 4414);
# 2733 "buildvm_ppc.dasc"
      }
      //|1:
      //|  add PC, PC, TMP2
      //|2:
      //|  ins_next
      //|
      //|7:  // RA is not an integer.
      //|  bgt cr0, ->vmeta_comp
      //|  // RA is a number.
      //|   lfd f0, 0(RA)
      //|  bgt cr1, ->vmeta_comp
      //|  blt cr1, >4
      //|  // RA is a number, RD is an integer.
      //|  tonum_i f1, CARG3
      //|  b >5
      //|
      //|8: // RA is an integer, RD is not an integer.
      //|  bgt cr1, ->vmeta_comp
      //|  // RA is an integer, RD is a number.
      //|  tonum_i f0, CARG2
      //|4:
      //|  lfd f1, 0(RD)
      //|5:
      //|  fcmpu cr0, f0, f1
      dasm_put(Dst, 4417);
# 2757 "buildvm_ppc.dasc"
      if (op == BC_ISLT) {
	//|  bge <2
	dasm_put(Dst, 4456);
# 2759 "buildvm_ppc.dasc"
      } else if (op == BC_ISGE) {
	//|  blt <2
	dasm_put(Dst, 4459);
# 2761 "buildvm_ppc.dasc"
      } else if (op == BC_ISLE) {
	//|  cror 4*cr0+lt, 4*cr0+lt, 4*cr0+eq
	//|  bge <2
	dasm_put(Dst, 4462);
# 2764 "buildvm_ppc.dasc"
      } else {
	//|  cror 4*cr0+lt, 4*cr0+lt, 4*cr0+eq
	//|  blt <2
	dasm_put(Dst, 4466);
# 2767 "buildvm_ppc.dasc"
      }
      //|  b <1
      dasm_put(Dst, 4470);
# 2769 "buildvm_ppc.dasc"
    } else {
      //|  lwzx TMP0, BASE, RA
      //|    addi PC, PC, 4
      //|   lfdx f0, BASE, RA
      //|  lwzx TMP1, BASE, RD
      //|  checknum cr0, TMP0
      //|    lwz TMP2, -4(PC)
      //|   lfdx f1, BASE, RD
      //|  checknum cr1, TMP1
      //|    decode_RD4 TMP2, TMP2
      //|  bge cr0, ->vmeta_comp
      //|    addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
      //|  bge cr1, ->vmeta_comp
      //|  fcmpu cr0, f0, f1
      dasm_put(Dst, 4473, -(BCBIAS_J*4 >> 16));
# 2783 "buildvm_ppc.dasc"
      if (op == BC_ISLT) {
	//|  bge >1
	dasm_put(Dst, 4490);
# 2785 "buildvm_ppc.dasc"
      } else if (op == BC_ISGE) {
	//|  blt >1
	dasm_put(Dst, 4493);
# 2787 "buildvm_ppc.dasc"
      } else if (op == BC_ISLE) {
	//|  cror 4*cr0+lt, 4*cr0+lt, 4*cr0+eq
	//|  bge >1
	dasm_put(Dst, 4496);
# 2790 "buildvm_ppc.dasc"
      } else {
	//|  cror 4*cr0+lt, 4*cr0+lt, 4*cr0+eq
	//|  blt >1
	dasm_put(Dst, 4500);
# 2793 "buildvm_ppc.dasc"
      }
      //|  add PC, PC, TMP2
      //|1:
      //|  ins_next
      dasm_put(Dst, 4504);
# 2797 "buildvm_ppc.dasc"
    }
    break;

  case BC_ISEQV: case BC_ISNEV:
    vk = op == BC_ISEQV;
    //|  // RA = src1*8, RD = src2*8, JMP with RD = target
    if (LJ_DUALNUM) {
      //|  lwzux TMP0, RA, BASE
      //|    addi PC, PC, 4
      //|   lwz CARG2, 4(RA)
      //|  lwzux TMP1, RD, BASE
      //|  checknum cr0, TMP0
      //|    lwz TMP2, -4(PC)
      //|  checknum cr1, TMP1
      //|    decode_RD4 TMP2, TMP2
      //|   lwz CARG3, 4(RD)
      //|  cror 4*cr7+gt, 4*cr0+gt, 4*cr1+gt
      //|    addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
      dasm_put(Dst, 4517, -(BCBIAS_J*4 >> 16));
# 2815 "buildvm_ppc.dasc"
      if (vk) {
	//|  ble cr7, ->BC_ISEQN_Z
	dasm_put(Dst, 4530);
# 2817 "buildvm_ppc.dasc"
      } else {
	//|  ble cr7, ->BC_ISNEN_Z
	dasm_put(Dst, 4533);
# 2819 "buildvm_ppc.dasc"
      }
    } else {
      //|  lwzux TMP0, RA, BASE
      //|   lwz TMP2, 0(PC)
      //|    lfd f0, 0(RA)
      //|   addi PC, PC, 4
      //|  lwzux TMP1, RD, BASE
      //|  checknum cr0, TMP0
      //|   decode_RD4 TMP2, TMP2
      //|    lfd f1, 0(RD)
      //|  checknum cr1, TMP1
      //|   addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
      //|  bge cr0, >5
      //|  bge cr1, >5
      //|  fcmpu cr0, f0, f1
      dasm_put(Dst, 4536, -(BCBIAS_J*4 >> 16));
# 2834 "buildvm_ppc.dasc"
      if (vk) {
	//|  bne >1
	//|  add PC, PC, TMP2
	dasm_put(Dst, 4553);
# 2837 "buildvm_ppc.dasc"
      } else {
	//|  beq >1
	//|  add PC, PC, TMP2
	dasm_put(Dst, 4557);
# 2840 "buildvm_ppc.dasc"
      }
      //|1:
      //|  ins_next
      dasm_put(Dst, 4561);
# 2843 "buildvm_ppc.dasc"
    }
    //|5:  // Either or both types are not numbers.
    dasm_put(Dst, 4573);
# 2845 "buildvm_ppc.dasc"
    if (!LJ_DUALNUM) {
      //|    lwz CARG2, 4(RA)
      //|    lwz CARG3, 4(RD)
      dasm_put(Dst, 4575);
# 2848 "buildvm_ppc.dasc"
    }
    if (LJ_HASFFI) {
      //|  cmpwi cr7, TMP0, LJ_TCDATA
      //|  cmpwi cr5, TMP1, LJ_TCDATA
      dasm_put(Dst, 4578, LJ_TCDATA, LJ_TCDATA);
# 2852 "buildvm_ppc.dasc"
    }
    //|   not TMP3, TMP0
    //|  cmplw TMP0, TMP1
    //|   cmplwi cr1, TMP3, ~LJ_TISPRI		// Primitive?
    dasm_put(Dst, 4583, ~LJ_TISPRI);
# 2856 "buildvm_ppc.dasc"
    if (LJ_HASFFI) {
      //|  cror 4*cr7+eq, 4*cr7+eq, 4*cr5+eq
      dasm_put(Dst, 4588);
# 2858 "buildvm_ppc.dasc"
    }
    //|   cmplwi cr6, TMP3, ~LJ_TISTABUD		// Table or userdata?
    dasm_put(Dst, 4590, ~LJ_TISTABUD);
# 2860 "buildvm_ppc.dasc"
    if (LJ_HASFFI) {
      //|  beq cr7, ->vmeta_equal_cd
      dasm_put(Dst, 4593);
# 2862 "buildvm_ppc.dasc"
    }
    //|    cmplw cr5, CARG2, CARG3
    //|  crandc 4*cr0+gt, 4*cr0+eq, 4*cr1+gt	// 2: Same type and primitive.
    //|  crorc 4*cr0+lt, 4*cr5+eq, 4*cr0+eq	// 1: Same tv or different type.
    //|  crand 4*cr0+eq, 4*cr0+eq, 4*cr5+eq	// 0: Same type and same tv.
    //|   mr SAVE0, PC
    //|  cror 4*cr0+eq, 4*cr0+eq, 4*cr0+gt	// 0 or 2.
    //|  cror 4*cr0+lt, 4*cr0+lt, 4*cr0+gt	// 1 or 2.
    dasm_put(Dst, 4596);
# 2870 "buildvm_ppc.dasc"
    if (vk) {
      //|  bne cr0, >6
      //|  add PC, PC, TMP2
      //|6:
      dasm_put(Dst, 4604);
# 2874 "buildvm_ppc.dasc"
    } else {
      //|  beq cr0, >6
      //|  add PC, PC, TMP2
      //|6:
      dasm_put(Dst, 4609);
# 2878 "buildvm_ppc.dasc"
    }
    if (LJ_DUALNUM) {
      //|  bge cr0, >2			// Done if 1 or 2.
      //|1:
      //|  ins_next
      //|2:
      dasm_put(Dst, 4614);
# 2884 "buildvm_ppc.dasc"
    } else {
      //|  blt cr0, <1			// Done if 1 or 2.
      dasm_put(Dst, 4629);
# 2886 "buildvm_ppc.dasc"
    }
    //|  blt cr6, <1			// Done if not tab/ud.
    //|
    //|  // Different tables or userdatas. Need to check __eq metamethod.
    //|  // Field metatable must be at same offset for GCtab and GCudata!
    //|  lwz TAB:TMP2, TAB:CARG2->metatable
    //|   li CARG4, 1-vk			// ne = 0 or 1.
    //|  cmplwi TAB:TMP2, 0
    //|  beq <1				// No metatable?
    //|  lbz TMP2, TAB:TMP2->nomm
    //|  andi. TMP2, TMP2, 1<<MM_eq
    //|  bne <1				// Or 'no __eq' flag set?
    //|  mr PC, SAVE0			// Restore old PC.
    //|  b ->vmeta_equal			// Handle __eq metamethod.
    dasm_put(Dst, 4632, Dt6(->metatable), 1-vk, Dt6(->nomm), 1<<MM_eq);
# 2900 "buildvm_ppc.dasc"
    break;

  case BC_ISEQS: case BC_ISNES:
    vk = op == BC_ISEQS;
    //|  // RA = src*8, RD = str_const*8 (~), JMP with RD = target
    //|  lwzux TMP0, RA, BASE
    //|   srwi RD, RD, 1
    //|  lwz STR:TMP3, 4(RA)
    //|    lwz TMP2, 0(PC)
    //|   subfic RD, RD, -4
    //|    addi PC, PC, 4
    dasm_put(Dst, 4651, 32-1);
# 2911 "buildvm_ppc.dasc"
    if (LJ_HASFFI) {
      //|  cmpwi TMP0, LJ_TCDATA
      dasm_put(Dst, 4659, LJ_TCDATA);
# 2913 "buildvm_ppc.dasc"
    }
    //|   lwzx STR:TMP1, KBASE, RD	// KBASE-4-str_const*4
    //|  subfic TMP0, TMP0, LJ_TSTR
    dasm_put(Dst, 4662, LJ_TSTR);
# 2916 "buildvm_ppc.dasc"
    if (LJ_HASFFI) {
      //|  beq ->vmeta_equal_cd
      dasm_put(Dst, 4666);
# 2918 "buildvm_ppc.dasc"
    }
    //|  sub TMP1, STR:TMP1, STR:TMP3
    //|  or TMP0, TMP0, TMP1
    //|    decode_RD4 TMP2, TMP2
    //|  subfic TMP0, TMP0, 0
    //|    addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
    //|  subfe TMP1, TMP1, TMP1
    dasm_put(Dst, 4669, -(BCBIAS_J*4 >> 16));
# 2925 "buildvm_ppc.dasc"
    if (vk) {
      //|  andc TMP2, TMP2, TMP1
      dasm_put(Dst, 4677);
# 2927 "buildvm_ppc.dasc"
    } else {
      //|  and TMP2, TMP2, TMP1
      dasm_put(Dst, 4679);
# 2929 "buildvm_ppc.dasc"
    }
    //|  add PC, PC, TMP2
    //|  ins_next
    dasm_put(Dst, 4681);
# 2932 "buildvm_ppc.dasc"
    break;

  case BC_ISEQN: case BC_ISNEN:
    vk = op == BC_ISEQN;
    //|  // RA = src*8, RD = num_const*8, JMP with RD = target
    if (LJ_DUALNUM) {
      //|  lwzux TMP0, RA, BASE
      //|    addi PC, PC, 4
      //|   lwz CARG2, 4(RA)
      //|  lwzux TMP1, RD, KBASE
      //|  checknum cr0, TMP0
      //|    lwz TMP2, -4(PC)
      //|  checknum cr1, TMP1
      //|    decode_RD4 TMP2, TMP2
      //|   lwz CARG3, 4(RD)
      //|    addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
      dasm_put(Dst, 4693, -(BCBIAS_J*4 >> 16));
# 2948 "buildvm_ppc.dasc"
      if (vk) {
	//|->BC_ISEQN_Z:
	dasm_put(Dst, 4705);
# 2950 "buildvm_ppc.dasc"
      } else {
	//|->BC_ISNEN_Z:
	dasm_put(Dst, 4707);
# 2952 "buildvm_ppc.dasc"
      }
      //|  bne cr0, >7
      //|  bne cr1, >8
      //|   cmpw CARG2, CARG3
      //|4:
      dasm_put(Dst, 4709);
# 2957 "buildvm_ppc.dasc"
    } else {
      if (vk) {
	//|->BC_ISEQN_Z:  // Dummy label.
	dasm_put(Dst, 4716);
# 2960 "buildvm_ppc.dasc"
      } else {
	//|->BC_ISNEN_Z:  // Dummy label.
	dasm_put(Dst, 4718);
# 2962 "buildvm_ppc.dasc"
      }
      //|  lwzx TMP0, BASE, RA
      //|    addi PC, PC, 4
      //|   lfdx f0, BASE, RA
      //|    lwz TMP2, -4(PC)
      //|  lfdx f1, KBASE, RD
      //|    decode_RD4 TMP2, TMP2
      //|  checknum TMP0
      //|    addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
      //|  bge >3
      //|  fcmpu cr0, f0, f1
      dasm_put(Dst, 4720, -(BCBIAS_J*4 >> 16));
# 2973 "buildvm_ppc.dasc"
    }
    if (vk) {
      //|  bne >1
      //|  add PC, PC, TMP2
      //|1:
      dasm_put(Dst, 4733);
# 2978 "buildvm_ppc.dasc"
      if (!LJ_HASFFI) {
	//|3:
	dasm_put(Dst, 4738);
# 2980 "buildvm_ppc.dasc"
      }
    } else {
      //|  beq >2
      //|1:
      dasm_put(Dst, 4740);
# 2984 "buildvm_ppc.dasc"
      if (!LJ_HASFFI) {
	//|3:
	dasm_put(Dst, 4744);
# 2986 "buildvm_ppc.dasc"
      }
      //|  add PC, PC, TMP2
      //|2:
      dasm_put(Dst, 4746);
# 2989 "buildvm_ppc.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 4749);
# 2991 "buildvm_ppc.dasc"
    if (LJ_HASFFI) {
      //|3:
      //|  cmpwi TMP0, LJ_TCDATA
      //|  beq ->vmeta_equal_cd
      //|  b <1
      dasm_put(Dst, 4760, LJ_TCDATA);
# 2996 "buildvm_ppc.dasc"
    }
    if (LJ_DUALNUM) {
      //|7:  // RA is not an integer.
      //|  bge cr0, <3
      //|  // RA is a number.
      //|   lfd f0, 0(RA)
      //|  blt cr1, >1
      //|  // RA is a number, RD is an integer.
      //|  tonum_i f1, CARG3
      //|  b >2
      //|
      //|8: // RA is an integer, RD is a number.
      //|  tonum_i f0, CARG2
      //|1:
      //|  lfd f1, 0(RD)
      //|2:
      //|  fcmpu cr0, f0, f1
      //|  b <4
      dasm_put(Dst, 4768);
# 3014 "buildvm_ppc.dasc"
    }
    break;

  case BC_ISEQP: case BC_ISNEP:
    vk = op == BC_ISEQP;
    //|  // RA = src*8, RD = primitive_type*8 (~), JMP with RD = target
    //|  lwzx TMP0, BASE, RA
    //|   srwi TMP1, RD, 3
    //|    lwz TMP2, 0(PC)
    //|   not TMP1, TMP1
    //|    addi PC, PC, 4
    dasm_put(Dst, 4792, 32-3);
# 3025 "buildvm_ppc.dasc"
    if (LJ_HASFFI) {
      //|  cmpwi TMP0, LJ_TCDATA
      dasm_put(Dst, 4799, LJ_TCDATA);
# 3027 "buildvm_ppc.dasc"
    }
    //|  sub TMP0, TMP0, TMP1
    dasm_put(Dst, 4802);
# 3029 "buildvm_ppc.dasc"
    if (LJ_HASFFI) {
      //|  beq ->vmeta_equal_cd
      dasm_put(Dst, 4804);
# 3031 "buildvm_ppc.dasc"
    }
    //|    decode_RD4 TMP2, TMP2
    //|  addic TMP0, TMP0, -1
    //|    addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
    //|  subfe TMP1, TMP1, TMP1
    dasm_put(Dst, 4807, -(BCBIAS_J*4 >> 16));
# 3036 "buildvm_ppc.dasc"
    if (vk) {
      //|  and TMP2, TMP2, TMP1
      dasm_put(Dst, 4813);
# 3038 "buildvm_ppc.dasc"
    } else {
      //|  andc TMP2, TMP2, TMP1
      dasm_put(Dst, 4815);
# 3040 "buildvm_ppc.dasc"
    }
    //|  add PC, PC, TMP2
    //|  ins_next
    dasm_put(Dst, 4817);
# 3043 "buildvm_ppc.dasc"
    break;

  /* -- Unary test and copy ops ------------------------------------------- */

  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
    //|  // RA = dst*8 or unused, RD = src*8, JMP with RD = target
    //|  lwzx TMP0, BASE, RD
    //|   lwz INS, 0(PC)
    //|   addi PC, PC, 4
    dasm_put(Dst, 4829);
# 3052 "buildvm_ppc.dasc"
    if (op == BC_IST || op == BC_ISF) {
      //|  subfic TMP0, TMP0, LJ_TTRUE
      //|   decode_RD4 TMP2, INS
      //|  subfe TMP1, TMP1, TMP1
      //|   addis TMP2, TMP2, -(BCBIAS_J*4 >> 16)
      dasm_put(Dst, 4833, LJ_TTRUE, -(BCBIAS_J*4 >> 16));
# 3057 "buildvm_ppc.dasc"
      if (op == BC_IST) {
	//|  andc TMP2, TMP2, TMP1
	dasm_put(Dst, 4840);
# 3059 "buildvm_ppc.dasc"
      } else {
	//|  and TMP2, TMP2, TMP1
	dasm_put(Dst, 4842);
# 3061 "buildvm_ppc.dasc"
      }
      //|  add PC, PC, TMP2
      dasm_put(Dst, 4844);
# 3063 "buildvm_ppc.dasc"
    } else {
      //|  li TMP1, LJ_TFALSE
      //|   lfdx f0, BASE, RD
      //|  cmplw TMP0, TMP1
      dasm_put(Dst, 4846, LJ_TFALSE);
# 3067 "buildvm_ppc.dasc"
      if (op == BC_ISTC) {
	//|  bge >1
	dasm_put(Dst, 4851);
# 3069 "buildvm_ppc.dasc"
      } else {
	//|  blt >1
	dasm_put(Dst, 4854);
# 3071 "buildvm_ppc.dasc"
      }
      //|  addis PC, PC, -(BCBIAS_J*4 >> 16)
      //|  decode_RD4 TMP2, INS
      //|   stfdx f0, BASE, RA
      //|  add PC, PC, TMP2
      //|1:
      dasm_put(Dst, 4857, -(BCBIAS_J*4 >> 16));
# 3077 "buildvm_ppc.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 4864);
# 3079 "buildvm_ppc.dasc"
    break;

  /* -- Unary ops --------------------------------------------------------- */

  case BC_MOV:
    //|  // RA = dst*8, RD = src*8
    //|  ins_next1
    //|  lfdx f0, BASE, RD
    //|  stfdx f0, BASE, RA
    //|  ins_next2
    dasm_put(Dst, 4875);
# 3089 "buildvm_ppc.dasc"
    break;
  case BC_NOT:
    //|  // RA = dst*8, RD = src*8
    //|  ins_next1
    //|  lwzx TMP0, BASE, RD
    //|  subfic TMP1, TMP0, LJ_TTRUE
    //|  adde TMP0, TMP0, TMP1
    //|  stwx TMP0, BASE, RA
    //|  ins_next2
    dasm_put(Dst, 4888, LJ_TTRUE);
# 3098 "buildvm_ppc.dasc"
    break;
  case BC_UNM:
    //|  // RA = dst*8, RD = src*8
    //|  lwzux TMP1, RD, BASE
    //|   lwz TMP0, 4(RD)
    //|  checknum TMP1
    dasm_put(Dst, 4904);
# 3104 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|  bne >5
      //|  nego. TMP0, TMP0
      //|  bso >4
      //|1:
      //|  ins_next1
      //|  stwux TISNUM, RA, BASE
      //|   stw TMP0, 4(RA)
      //|3:
      //|  ins_next2
      //|4:  // Potential overflow.
      //|  mcrxr cr0; bley <1		// Ignore unrelated overflow.
      //|  lus TMP1, 0x41e0		// 2^31.
      //|  li TMP0, 0
      //|  b >7
      dasm_put(Dst, 4908);
# 3119 "buildvm_ppc.dasc"
    }
    //|5:
    //|  bge ->vmeta_unm
    //|  xoris TMP1, TMP1, 0x8000
    //|7:
    //|  ins_next1
    //|  stwux TMP1, RA, BASE
    //|   stw TMP0, 4(RA)
    dasm_put(Dst, 4936);
# 3127 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|  b <3
      dasm_put(Dst, 4946);
# 3129 "buildvm_ppc.dasc"
    } else {
      //|  ins_next2
      dasm_put(Dst, 4949);
# 3131 "buildvm_ppc.dasc"
    }
    break;
  case BC_LEN:
    //|  // RA = dst*8, RD = src*8
    //|  lwzux TMP0, RD, BASE
    //|   lwz CARG1, 4(RD)
    //|  checkstr TMP0; bne >2
    //|  lwz CRET1, STR:CARG1->len
    //|1:
    dasm_put(Dst, 4958, LJ_TSTR, Dt5(->len));
# 3140 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|  ins_next1
      //|  stwux TISNUM, RA, BASE
      //|   stw CRET1, 4(RA)
      dasm_put(Dst, 4968);
# 3144 "buildvm_ppc.dasc"
    } else {
      //|  tonum_u f0, CRET1		// Result is a non-negative integer.
      //|  ins_next1
      //|  stfdx f0, BASE, RA
      dasm_put(Dst, 4973);
# 3148 "buildvm_ppc.dasc"
    }
    //|  ins_next2
    //|2:
    //|  checktab TMP0; bne ->vmeta_len
    dasm_put(Dst, 4980, LJ_TTAB);
# 3152 "buildvm_ppc.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
    //|  lwz TAB:TMP2, TAB:CARG1->metatable
    //|  cmplwi TAB:TMP2, 0
    //|  bne >9
    //|3:
    dasm_put(Dst, 4994, Dt6(->metatable));
# 3157 "buildvm_ppc.dasc"
#endif
    //|->BC_LEN_Z:
    //|  bl extern lj_tab_len		// (GCtab *t)
    //|  // Returns uint32_t (but less than 2^31).
    //|  b <1
    dasm_put(Dst, 5001);
# 3162 "buildvm_ppc.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
    //|9:
    //|  lbz TMP0, TAB:TMP2->nomm
    //|  andi. TMP0, TMP0, 1<<MM_len
    //|  bne <3				// 'no __len' flag set: done.
    //|  b ->vmeta_len
    dasm_put(Dst, 5007, Dt6(->nomm), 1<<MM_len);
# 3168 "buildvm_ppc.dasc"
#endif
    break;

  /* -- Binary ops -------------------------------------------------------- */

    //|.macro ins_arithpre
    //|  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    //||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    //||switch (vk) {
    //||case 0:
    //|   lwzx TMP1, BASE, RB
    //||if (LJ_DUALNUM) {
    //|   lwzx TMP2, KBASE, RC
    //||}
    //|    lfdx f14, BASE, RB
    //|    lfdx f15, KBASE, RC
    //||if (LJ_DUALNUM) {
    //|   checknum cr0, TMP1
    //|   checknum cr1, TMP2
    //|   crand 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
    //|   bge ->vmeta_arith_vn
    //||} else {
    //|   checknum TMP1; bge ->vmeta_arith_vn
    //||}
    //||  break;
    //||case 1:
    //|   lwzx TMP1, BASE, RB
    //||if (LJ_DUALNUM) {
    //|   lwzx TMP2, KBASE, RC
    //||}
    //|    lfdx f15, BASE, RB
    //|    lfdx f14, KBASE, RC
    //||if (LJ_DUALNUM) {
    //|   checknum cr0, TMP1
    //|   checknum cr1, TMP2
    //|   crand 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
    //|   bge ->vmeta_arith_nv
    //||} else {
    //|   checknum TMP1; bge ->vmeta_arith_nv
    //||}
    //||  break;
    //||default:
    //|   lwzx TMP1, BASE, RB
    //|   lwzx TMP2, BASE, RC
    //|    lfdx f14, BASE, RB
    //|    lfdx f15, BASE, RC
    //|   checknum cr0, TMP1
    //|   checknum cr1, TMP2
    //|   crand 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
    //|   bge ->vmeta_arith_vv
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithfallback, ins
    //||switch (vk) {
    //||case 0:
    //|   ins ->vmeta_arith_vn2
    //||  break;
    //||case 1:
    //|   ins ->vmeta_arith_nv2
    //||  break;
    //||default:
    //|   ins ->vmeta_arith_vv2
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro intmod, a, b, c
    //|  bl ->vm_modi
    //|.endmacro
    //|
    //|.macro fpmod, a, b, c
    //|->BC_MODVN_Z:
    //|  fdiv FARG1, b, c
    //|  // NYI: Use internal implementation of floor.
    //|  bl extern floor			// floor(b/c)
    //|  fmul a, FARG1, c
    //|  fsub a, b, a			// b - floor(b/c)*c
    //|.endmacro
    //|
    //|.macro ins_arithfp, fpins
    //|  ins_arithpre
    //|.if "fpins" == "fpmod_"
    //|  b ->BC_MODVN_Z			// Avoid 3 copies. It's slow anyway.
    //|.else
    //|  fpins f0, f14, f15
    //|  ins_next1
    //|  stfdx f0, BASE, RA
    //|  ins_next2
    //|.endif
    //|.endmacro
    //|
    //|.macro ins_arithdn, intins, fpins
    //|  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    //||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    //||switch (vk) {
    //||case 0:
    //|   lwzux TMP1, RB, BASE
    //|   lwzux TMP2, RC, KBASE
    //|    lwz CARG1, 4(RB)
    //|   checknum cr0, TMP1
    //|    lwz CARG2, 4(RC)
    //||  break;
    //||case 1:
    //|   lwzux TMP1, RB, BASE
    //|   lwzux TMP2, RC, KBASE
    //|    lwz CARG2, 4(RB)
    //|   checknum cr0, TMP1
    //|    lwz CARG1, 4(RC)
    //||  break;
    //||default:
    //|   lwzux TMP1, RB, BASE
    //|   lwzux TMP2, RC, BASE
    //|    lwz CARG1, 4(RB)
    //|   checknum cr0, TMP1
    //|    lwz CARG2, 4(RC)
    //||  break;
    //||}
    //|  checknum cr1, TMP2
    //|  bne >5
    //|  bne cr1, >5
    //|  intins CARG1, CARG1, CARG2
    //|  bso >4
    //|1:
    //|  ins_next1
    //|  stwux TISNUM, RA, BASE
    //|  stw CARG1, 4(RA)
    //|2:
    //|  ins_next2
    //|4:  // Overflow.
    //|  mcrxr cr0; bley <1		// Ignore unrelated overflow.
    //|  ins_arithfallback b
    //|5:  // FP variant.
    //||if (vk == 1) {
    //|  lfd f15, 0(RB)
    //|   crand 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
    //|  lfd f14, 0(RC)
    //||} else {
    //|  lfd f14, 0(RB)
    //|   crand 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
    //|  lfd f15, 0(RC)
    //||}
    //|   ins_arithfallback bge
    //|.if "fpins" == "fpmod_"
    //|  b ->BC_MODVN_Z			// Avoid 3 copies. It's slow anyway.
    //|.else
    //|  fpins f0, f14, f15
    //|  ins_next1
    //|  stfdx f0, BASE, RA
    //|  b <2
    //|.endif
    //|.endmacro
    //|
    //|.macro ins_arith, intins, fpins
    //||if (LJ_DUALNUM) {
    //|  ins_arithdn intins, fpins
    //||} else {
    //|  ins_arithfp fpins
    //||}
    //|.endmacro

  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
    //|  ins_arith addo., fadd
    if (LJ_DUALNUM) {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5017);
      break;
    case 1:
    dasm_put(Dst, 5023);
      break;
    default:
    dasm_put(Dst, 5029);
      break;
    }
    dasm_put(Dst, 5035);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5062);
      break;
    case 1:
    dasm_put(Dst, 5065);
      break;
    default:
    dasm_put(Dst, 5068);
      break;
    }
    dasm_put(Dst, 5071);
    if (vk == 1) {
    dasm_put(Dst, 5073);
    } else {
    dasm_put(Dst, 5077);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 5081);
      break;
    case 1:
    dasm_put(Dst, 5084);
      break;
    default:
    dasm_put(Dst, 5087);
      break;
    }
    dasm_put(Dst, 5090);
    } else {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5097);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5099);
    }
    dasm_put(Dst, 5101);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5104);
    } else {
    dasm_put(Dst, 5110);
    }
      break;
    case 1:
    dasm_put(Dst, 5114);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5116);
    }
    dasm_put(Dst, 5118);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5121);
    } else {
    dasm_put(Dst, 5127);
    }
      break;
    default:
    dasm_put(Dst, 5131);
      break;
    }
    dasm_put(Dst, 5141);
    }
# 3332 "buildvm_ppc.dasc"
    break;
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
    //|  ins_arith subo., fsub
    if (LJ_DUALNUM) {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5154);
      break;
    case 1:
    dasm_put(Dst, 5160);
      break;
    default:
    dasm_put(Dst, 5166);
      break;
    }
    dasm_put(Dst, 5172);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5199);
      break;
    case 1:
    dasm_put(Dst, 5202);
      break;
    default:
    dasm_put(Dst, 5205);
      break;
    }
    dasm_put(Dst, 5208);
    if (vk == 1) {
    dasm_put(Dst, 5210);
    } else {
    dasm_put(Dst, 5214);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 5218);
      break;
    case 1:
    dasm_put(Dst, 5221);
      break;
    default:
    dasm_put(Dst, 5224);
      break;
    }
    dasm_put(Dst, 5227);
    } else {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5234);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5236);
    }
    dasm_put(Dst, 5238);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5241);
    } else {
    dasm_put(Dst, 5247);
    }
      break;
    case 1:
    dasm_put(Dst, 5251);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5253);
    }
    dasm_put(Dst, 5255);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5258);
    } else {
    dasm_put(Dst, 5264);
    }
      break;
    default:
    dasm_put(Dst, 5268);
      break;
    }
    dasm_put(Dst, 5278);
    }
# 3335 "buildvm_ppc.dasc"
    break;
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
    //|  ins_arith mullwo., fmul
    if (LJ_DUALNUM) {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5291);
      break;
    case 1:
    dasm_put(Dst, 5297);
      break;
    default:
    dasm_put(Dst, 5303);
      break;
    }
    dasm_put(Dst, 5309);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5336);
      break;
    case 1:
    dasm_put(Dst, 5339);
      break;
    default:
    dasm_put(Dst, 5342);
      break;
    }
    dasm_put(Dst, 5345);
    if (vk == 1) {
    dasm_put(Dst, 5347);
    } else {
    dasm_put(Dst, 5351);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 5355);
      break;
    case 1:
    dasm_put(Dst, 5358);
      break;
    default:
    dasm_put(Dst, 5361);
      break;
    }
    dasm_put(Dst, 5364);
    } else {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5371);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5373);
    }
    dasm_put(Dst, 5375);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5378);
    } else {
    dasm_put(Dst, 5384);
    }
      break;
    case 1:
    dasm_put(Dst, 5388);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5390);
    }
    dasm_put(Dst, 5392);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5395);
    } else {
    dasm_put(Dst, 5401);
    }
      break;
    default:
    dasm_put(Dst, 5405);
      break;
    }
    dasm_put(Dst, 5415);
    }
# 3338 "buildvm_ppc.dasc"
    break;
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
    //|  ins_arithfp fdiv
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5428);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5430);
    }
    dasm_put(Dst, 5432);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5435);
    } else {
    dasm_put(Dst, 5441);
    }
      break;
    case 1:
    dasm_put(Dst, 5445);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5447);
    }
    dasm_put(Dst, 5449);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5452);
    } else {
    dasm_put(Dst, 5458);
    }
      break;
    default:
    dasm_put(Dst, 5462);
      break;
    }
    dasm_put(Dst, 5472);
# 3341 "buildvm_ppc.dasc"
    break;
  case BC_MODVN:
    //|  ins_arith intmod, fpmod
    if (LJ_DUALNUM) {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5485);
      break;
    case 1:
    dasm_put(Dst, 5491);
      break;
    default:
    dasm_put(Dst, 5497);
      break;
    }
    dasm_put(Dst, 5503);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5531);
      break;
    case 1:
    dasm_put(Dst, 5534);
      break;
    default:
    dasm_put(Dst, 5537);
      break;
    }
    dasm_put(Dst, 5540);
    if (vk == 1) {
    dasm_put(Dst, 5542);
    } else {
    dasm_put(Dst, 5546);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 5550);
      break;
    case 1:
    dasm_put(Dst, 5553);
      break;
    default:
    dasm_put(Dst, 5556);
      break;
    }
    dasm_put(Dst, 5559);
    } else {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5571);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5573);
    }
    dasm_put(Dst, 5575);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5578);
    } else {
    dasm_put(Dst, 5584);
    }
      break;
    case 1:
    dasm_put(Dst, 5588);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5590);
    }
    dasm_put(Dst, 5592);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5595);
    } else {
    dasm_put(Dst, 5601);
    }
      break;
    default:
    dasm_put(Dst, 5605);
      break;
    }
    dasm_put(Dst, 5615);
    }
# 3344 "buildvm_ppc.dasc"
    break;
  case BC_MODNV: case BC_MODVV:
    //|  ins_arith intmod, fpmod_
    if (LJ_DUALNUM) {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5633);
      break;
    case 1:
    dasm_put(Dst, 5639);
      break;
    default:
    dasm_put(Dst, 5645);
      break;
    }
    dasm_put(Dst, 5651);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5679);
      break;
    case 1:
    dasm_put(Dst, 5682);
      break;
    default:
    dasm_put(Dst, 5685);
      break;
    }
    dasm_put(Dst, 5688);
    if (vk == 1) {
    dasm_put(Dst, 5690);
    } else {
    dasm_put(Dst, 5694);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 5698);
      break;
    case 1:
    dasm_put(Dst, 5701);
      break;
    default:
    dasm_put(Dst, 5704);
      break;
    }
    dasm_put(Dst, 5707);
    } else {
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 5710);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5712);
    }
    dasm_put(Dst, 5714);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5717);
    } else {
    dasm_put(Dst, 5723);
    }
      break;
    case 1:
    dasm_put(Dst, 5727);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5729);
    }
    dasm_put(Dst, 5731);
    if (LJ_DUALNUM) {
    dasm_put(Dst, 5734);
    } else {
    dasm_put(Dst, 5740);
    }
      break;
    default:
    dasm_put(Dst, 5744);
      break;
    }
    dasm_put(Dst, 5754);
    }
# 3347 "buildvm_ppc.dasc"
    break;
  case BC_POW:
    //|  // NYI: (partial) integer arithmetic.
    //|  lwzx TMP1, BASE, RB
    //|   lfdx FARG1, BASE, RB
    //|  lwzx TMP2, BASE, RC
    //|   lfdx FARG2, BASE, RC
    //|  checknum cr0, TMP1
    //|  checknum cr1, TMP2
    //|  crand 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
    //|  bge ->vmeta_arith_vv
    //|  bl extern pow
    //|  ins_next1
    //|  stfdx FARG1, BASE, RA
    //|  ins_next2
    dasm_put(Dst, 5757);
# 3362 "buildvm_ppc.dasc"
    break;

  case BC_CAT:
    //|  // RA = dst*8, RB = src_start*8, RC = src_end*8
    //|  sub CARG3, RC, RB
    //|   stw BASE, L->base
    //|  add CARG2, BASE, RC
    //|  mr SAVE0, RB
    //|->BC_CAT_Z:
    //|   stw PC, SAVE_PC
    //|  mr CARG1, L
    //|  srwi CARG3, CARG3, 3
    //|  bl extern lj_meta_cat		// (lua_State *L, TValue *top, int left)
    //|  // Returns NULL (finished) or TValue * (metamethod).
    //|  cmplwi CRET1, 0
    //|   lwz BASE, L->base
    //|  bne ->vmeta_binop
    //|  ins_next1
    //|  lfdx f0, BASE, SAVE0		// Copy result from RB to RA.
    //|  stfdx f0, BASE, RA
    //|  ins_next2
    dasm_put(Dst, 5780, Dt1(->base), 32-3, Dt1(->base));
# 3383 "buildvm_ppc.dasc"
    break;

  /* -- Constant ops ------------------------------------------------------ */

  case BC_KSTR:
    //|  // RA = dst*8, RD = str_const*8 (~)
    //|  srwi TMP1, RD, 1
    //|  subfic TMP1, TMP1, -4
    //|  ins_next1
    //|  lwzx TMP0, KBASE, TMP1		// KBASE-4-str_const*4
    //|  li TMP2, LJ_TSTR
    //|  stwux TMP2, RA, BASE
    //|  stw TMP0, 4(RA)
    //|  ins_next2
    dasm_put(Dst, 5810, 32-1, LJ_TSTR);
# 3397 "buildvm_ppc.dasc"
    break;
  case BC_KCDATA:
#if LJ_HASFFI
    //|  // RA = dst*8, RD = cdata_const*8 (~)
    //|  srwi TMP1, RD, 1
    //|  subfic TMP1, TMP1, -4
    //|  ins_next1
    //|  lwzx TMP0, KBASE, TMP1		// KBASE-4-cdata_const*4
    //|  li TMP2, LJ_TCDATA
    //|  stwux TMP2, RA, BASE
    //|  stw TMP0, 4(RA)
    //|  ins_next2
    dasm_put(Dst, 5829, 32-1, LJ_TCDATA);
# 3409 "buildvm_ppc.dasc"
#endif
    break;
  case BC_KSHORT:
    //|  // RA = dst*8, RD = int16_literal*8
    if (LJ_DUALNUM) {
      //|  slwi RD, RD, 13
      //|  srawi RD, RD, 16
      //|  ins_next1
      //|   stwux TISNUM, RA, BASE
      //|   stw RD, 4(RA)
      //|  ins_next2
      dasm_put(Dst, 5848, 31-13);
# 3420 "buildvm_ppc.dasc"
    } else {
      //|  // The soft-float approach is faster.
      //|  slwi RD, RD, 13
      //|  srawi TMP1, RD, 31
      //|  xor TMP2, TMP1, RD
      //|  sub TMP2, TMP2, TMP1		// TMP2 = abs(x)
      //|  cntlzw TMP3, TMP2
      //|  subfic TMP1, TMP3, 0x40d	// TMP1 = exponent-1
      //|   slw TMP2, TMP2, TMP3		// TMP2 = left aligned mantissa
      //|    subfic TMP3, RD, 0
      //|  slwi TMP1, TMP1, 20
      //|   rlwimi RD, TMP2, 21, 1, 31	// hi = sign(x) | (mantissa>>11)
      //|    subfe TMP0, TMP0, TMP0
      //|   add RD, RD, TMP1		// hi = hi + exponent-1
      //|    and RD, RD, TMP0		// hi = x == 0 ? 0 : hi
      //|  ins_next1
      //|    stwux RD, RA, BASE
      //|    stw ZERO, 4(RA)
      //|  ins_next2
      dasm_put(Dst, 5864, 31-13, 31-20);
# 3439 "buildvm_ppc.dasc"
    }
    break;
  case BC_KNUM:
    //|  // RA = dst*8, RD = num_const*8
    //|  ins_next1
    //|  lfdx f0, KBASE, RD
    //|  stfdx f0, BASE, RA
    //|  ins_next2
    dasm_put(Dst, 5892);
# 3447 "buildvm_ppc.dasc"
    break;
  case BC_KPRI:
    //|  // RA = dst*8, RD = primitive_type*8 (~)
    //|  srwi TMP1, RD, 3
    //|  not TMP0, TMP1
    //|  ins_next1
    //|  stwx TMP0, BASE, RA
    //|  ins_next2
    dasm_put(Dst, 5905, 32-3);
# 3455 "buildvm_ppc.dasc"
    break;
  case BC_KNIL:
    //|  // RA = base*8, RD = end*8
    //|  stwx TISNIL, BASE, RA
    //|   addi RA, RA, 8
    //|1:
    //|  stwx TISNIL, BASE, RA
    //|  cmpw RA, RD
    //|   addi RA, RA, 8
    //|  blt <1
    //|  ins_next_
    dasm_put(Dst, 5920);
# 3466 "buildvm_ppc.dasc"
    break;

  /* -- Upvalue and function ops ------------------------------------------ */

  case BC_UGET:
    //|  // RA = dst*8, RD = uvnum*8
    //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
    //|   srwi RD, RD, 1
    //|   addi RD, RD, offsetof(GCfuncL, uvptr)
    //|  lwzx UPVAL:RB, LFUNC:RB, RD
    //|  ins_next1
    //|  lwz TMP1, UPVAL:RB->v
    //|  lfd f0, 0(TMP1)
    //|  stfdx f0, BASE, RA
    //|  ins_next2
    dasm_put(Dst, 5939, 32-1, offsetof(GCfuncL, uvptr), DtA(->v));
# 3481 "buildvm_ppc.dasc"
    break;
  case BC_USETV:
    //|  // RA = uvnum*8, RD = src*8
    //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
    //|    srwi RA, RA, 1
    //|    addi RA, RA, offsetof(GCfuncL, uvptr)
    //|   lfdux f0, RD, BASE
    //|  lwzx UPVAL:RB, LFUNC:RB, RA
    //|  lbz TMP3, UPVAL:RB->marked
    //|   lwz CARG2, UPVAL:RB->v
    //|  andi. TMP3, TMP3, LJ_GC_BLACK	// isblack(uv)
    //|    lbz TMP0, UPVAL:RB->closed
    //|   lwz TMP2, 0(RD)
    //|   stfd f0, 0(CARG2)
    //|    cmplwi cr1, TMP0, 0
    //|   lwz TMP1, 4(RD)
    //|  cror 4*cr0+eq, 4*cr0+eq, 4*cr1+eq
    //|   subi TMP2, TMP2, (LJ_TISNUM+1)
    //|  bne >2				// Upvalue is closed and black?
    //|1:
    //|  ins_next
    //|
    //|2:  // Check if new value is collectable.
    //|  cmplwi TMP2, LJ_TISGCV - (LJ_TISNUM+1)
    //|  bge <1				// tvisgcv(v)
    //|  lbz TMP3, GCOBJ:TMP1->gch.marked
    //|  andi. TMP3, TMP3, LJ_GC_WHITES	// iswhite(v)
    //|   la CARG1, GG_DISP2G(DISPATCH)
    //|  // Crossed a write barrier. Move the barrier forward.
    //|  beq <1
    //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|  b <1
    dasm_put(Dst, 5960, 32-1, offsetof(GCfuncL, uvptr), DtA(->marked), DtA(->v), LJ_GC_BLACK, DtA(->closed), -(LJ_TISNUM+1), LJ_TISGCV - (LJ_TISNUM+1), Dt4(->gch.marked), LJ_GC_WHITES, GG_DISP2G);
# 3513 "buildvm_ppc.dasc"
    break;
  case BC_USETS:
    //|  // RA = uvnum*8, RD = str_const*8 (~)
    //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
    //|   srwi TMP1, RD, 1
    //|    srwi RA, RA, 1
    //|   subfic TMP1, TMP1, -4
    //|    addi RA, RA, offsetof(GCfuncL, uvptr)
    //|   lwzx STR:TMP1, KBASE, TMP1	// KBASE-4-str_const*4
    //|  lwzx UPVAL:RB, LFUNC:RB, RA
    //|  lbz TMP3, UPVAL:RB->marked
    //|   lwz CARG2, UPVAL:RB->v
    //|  andi. TMP3, TMP3, LJ_GC_BLACK	// isblack(uv)
    //|   lbz TMP3, STR:TMP1->marked
    //|   lbz TMP2, UPVAL:RB->closed
    //|   li TMP0, LJ_TSTR
    //|   stw STR:TMP1, 4(CARG2)
    //|   stw TMP0, 0(CARG2)
    //|  bne >2
    //|1:
    //|  ins_next
    //|
    //|2:  // Check if string is white and ensure upvalue is closed.
    //|  andi. TMP3, TMP3, LJ_GC_WHITES	// iswhite(str)
    //|   cmplwi cr1, TMP2, 0
    //|  cror 4*cr0+eq, 4*cr0+eq, 4*cr1+eq
    //|   la CARG1, GG_DISP2G(DISPATCH)
    //|  // Crossed a write barrier. Move the barrier forward.
    //|  beq <1
    //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|  b <1
    dasm_put(Dst, 6013, 32-1, 32-1, offsetof(GCfuncL, uvptr), DtA(->marked), DtA(->v), LJ_GC_BLACK, Dt5(->marked), DtA(->closed), LJ_TSTR, LJ_GC_WHITES, GG_DISP2G);
# 3544 "buildvm_ppc.dasc"
    break;
  case BC_USETN:
    //|  // RA = uvnum*8, RD = num_const*8
    //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
    //|   srwi RA, RA, 1
    //|   addi RA, RA, offsetof(GCfuncL, uvptr)
    //|    lfdx f0, KBASE, RD
    //|  lwzx UPVAL:RB, LFUNC:RB, RA
    //|  ins_next1
    //|  lwz TMP1, UPVAL:RB->v
    //|  stfd f0, 0(TMP1)
    //|  ins_next2
    dasm_put(Dst, 6064, 32-1, offsetof(GCfuncL, uvptr), DtA(->v));
# 3556 "buildvm_ppc.dasc"
    break;
  case BC_USETP:
    //|  // RA = uvnum*8, RD = primitive_type*8 (~)
    //|  lwz LFUNC:RB, FRAME_FUNC(BASE)
    //|   srwi RA, RA, 1
    //|    srwi TMP0, RD, 3
    //|   addi RA, RA, offsetof(GCfuncL, uvptr)
    //|    not TMP0, TMP0
    //|  lwzx UPVAL:RB, LFUNC:RB, RA
    //|  ins_next1
    //|  lwz TMP1, UPVAL:RB->v
    //|  stw TMP0, 0(TMP1)
    //|  ins_next2
    dasm_put(Dst, 6085, 32-1, 32-3, offsetof(GCfuncL, uvptr), DtA(->v));
# 3569 "buildvm_ppc.dasc"
    break;

  case BC_UCLO:
    //|  // RA = level*8, RD = target
    //|  lwz TMP1, L->openupval
    //|  branch_RD			// Do this first since RD is not saved.
    //|   stw BASE, L->base
    //|  cmplwi TMP1, 0
    //|   mr CARG1, L
    //|  beq >1
    //|   add CARG2, BASE, RA
    //|  bl extern lj_func_closeuv	// (lua_State *L, TValue *level)
    //|  lwz BASE, L->base
    //|1:
    //|  ins_next
    dasm_put(Dst, 6108, Dt1(->openupval), 32-1, -(BCBIAS_J*4 >> 16), Dt1(->base), Dt1(->base));
# 3584 "buildvm_ppc.dasc"
    break;

  case BC_FNEW:
    //|  // RA = dst*8, RD = proto_const*8 (~) (holding function prototype)
    //|  srwi TMP1, RD, 1
    //|   stw BASE, L->base
    //|  subfic TMP1, TMP1, -4
    //|   stw PC, SAVE_PC
    //|  lwzx CARG2, KBASE, TMP1		// KBASE-4-tab_const*4
    //|   mr CARG1, L
    //|  lwz CARG3, FRAME_FUNC(BASE)
    //|  // (lua_State *L, GCproto *pt, GCfuncL *parent)
    //|  bl extern lj_func_newL_gc
    //|  // Returns GCfuncL *.
    //|  lwz BASE, L->base
    //|   li TMP0, LJ_TFUNC
    //|  stwux TMP0, RA, BASE
    //|  stw LFUNC:CRET1, 4(RA)
    //|  ins_next
    dasm_put(Dst, 6138, 32-1, Dt1(->base), Dt1(->base), LJ_TFUNC);
# 3603 "buildvm_ppc.dasc"
    break;

  /* -- Table ops --------------------------------------------------------- */

  case BC_TNEW:
  case BC_TDUP:
    //|  // RA = dst*8, RD = (hbits|asize)*8 | tab_const*8 (~)
    //|  lwz TMP0, DISPATCH_GL(gc.total)(DISPATCH)
    //|   mr CARG1, L
    //|  lwz TMP1, DISPATCH_GL(gc.threshold)(DISPATCH)
    //|   stw BASE, L->base
    //|  cmplw TMP0, TMP1
    //|   stw PC, SAVE_PC
    //|  bge >5
    //|1:
    dasm_put(Dst, 6166, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base));
# 3618 "buildvm_ppc.dasc"
    if (op == BC_TNEW) {
      //|  rlwinm CARG2, RD, 29, 21, 31
      //|  rlwinm CARG3, RD, 18, 27, 31
      //|  cmpwi CARG2, 0x7ff; beq >3
      //|2:
      //|  bl extern lj_tab_new  // (lua_State *L, int32_t asize, uint32_t hbits)
      //|  // Returns Table *.
      dasm_put(Dst, 6179);
# 3625 "buildvm_ppc.dasc"
    } else {
      //|  srwi TMP1, RD, 1
      //|  subfic TMP1, TMP1, -4
      //|  lwzx CARG2, KBASE, TMP1		// KBASE-4-tab_const*4
      //|  bl extern lj_tab_dup  // (lua_State *L, Table *kt)
      //|  // Returns Table *.
      dasm_put(Dst, 6188, 32-1);
# 3631 "buildvm_ppc.dasc"
    }
    //|  lwz BASE, L->base
    //|   li TMP0, LJ_TTAB
    //|  stwux TMP0, RA, BASE
    //|  stw TAB:CRET1, 4(RA)
    //|  ins_next
    dasm_put(Dst, 6195, Dt1(->base), LJ_TTAB);
# 3637 "buildvm_ppc.dasc"
    if (op == BC_TNEW) {
      //|3:
      //|  li CARG2, 0x801
      //|  b <2
      dasm_put(Dst, 6212);
# 3641 "buildvm_ppc.dasc"
    }
    //|5:
    //|  mr SAVE0, RD
    //|  bl extern lj_gc_step_fixtop  // (lua_State *L)
    //|  mr RD, SAVE0
    //|  mr CARG1, L
    //|  b <1
    dasm_put(Dst, 6217);
# 3648 "buildvm_ppc.dasc"
    break;

  case BC_GGET:
    //|  // RA = dst*8, RD = str_const*8 (~)
  case BC_GSET:
    //|  // RA = src*8, RD = str_const*8 (~)
    //|  lwz LFUNC:TMP2, FRAME_FUNC(BASE)
    //|   srwi TMP1, RD, 1
    //|  lwz TAB:RB, LFUNC:TMP2->env
    //|   subfic TMP1, TMP1, -4
    //|   lwzx STR:RC, KBASE, TMP1	// KBASE-4-str_const*4
    dasm_put(Dst, 6226, 32-1, Dt7(->env));
# 3659 "buildvm_ppc.dasc"
    if (op == BC_GGET) {
      //|  b ->BC_TGETS_Z
      dasm_put(Dst, 6234);
# 3661 "buildvm_ppc.dasc"
    } else {
      //|  b ->BC_TSETS_Z
      dasm_put(Dst, 6237);
# 3663 "buildvm_ppc.dasc"
    }
    break;

  case BC_TGETV:
    //|  // RA = dst*8, RB = table*8, RC = key*8
    //|  lwzux CARG1, RB, BASE
    //|  lwzux CARG2, RC, BASE
    //|   lwz TAB:RB, 4(RB)
    dasm_put(Dst, 6240);
# 3671 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|   lwz RC, 4(RC)
      dasm_put(Dst, 6244);
# 3673 "buildvm_ppc.dasc"
    } else {
      //|   lfd f0, 0(RC)
      dasm_put(Dst, 6246);
# 3675 "buildvm_ppc.dasc"
    }
    //|  checktab CARG1
    //|   checknum cr1, CARG2
    //|  bne ->vmeta_tgetv
    dasm_put(Dst, 6248, LJ_TTAB);
# 3679 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|  lwz TMP0, TAB:RB->asize
      //|   bne cr1, >5
      //|   lwz TMP1, TAB:RB->array
      //|  cmplw TMP0, RC
      //|   slwi TMP2, RC, 3
      dasm_put(Dst, 6254, Dt6(->asize), Dt6(->array), 31-3);
# 3685 "buildvm_ppc.dasc"
    } else {
      //|   bge cr1, >5
      //|  // Convert number key to integer, check for integerness and range.
      //|  fctiwz f1, f0
      //|    fadd f2, f0, TOBIT
      //|  stfd f1, TMPD
      //|   lwz TMP0, TAB:RB->asize
      //|    fsub f2, f2, TOBIT
      //|  lwz TMP2, TMPD_LO
      //|   lwz TMP1, TAB:RB->array
      //|    fcmpu cr1, f0, f2
      //|  cmplw cr0, TMP0, TMP2
      //|  crand 4*cr0+gt, 4*cr0+gt, 4*cr1+eq
      //|   slwi TMP2, TMP2, 3
      dasm_put(Dst, 6264, Dt6(->asize), Dt6(->array), 31-3);
# 3699 "buildvm_ppc.dasc"
    }
    //|  ble ->vmeta_tgetv		// Integer key and in array part?
    //|  lwzx TMP0, TMP1, TMP2
    //|   lfdx f14, TMP1, TMP2
    //|  checknil TMP0; beq >2
    //|1:
    //|  ins_next1
    //|   stfdx f14, BASE, RA
    //|  ins_next2
    //|
    //|2:  // Check for __index if table value is nil.
    //|  lwz TAB:TMP2, TAB:RB->metatable
    //|  cmplwi TAB:TMP2, 0
    //|  beq <1				// No metatable: done.
    //|  lbz TMP0, TAB:TMP2->nomm
    //|  andi. TMP0, TMP0, 1<<MM_index
    //|  bne <1				// 'no __index' flag set: done.
    //|  b ->vmeta_tgetv
    //|
    //|5:
    //|  checkstr CARG2; bne ->vmeta_tgetv
    dasm_put(Dst, 6281, LJ_TNIL, Dt6(->metatable), Dt6(->nomm), 1<<MM_index, LJ_TSTR);
# 3720 "buildvm_ppc.dasc"
    if (!LJ_DUALNUM) {
      //|  lwz STR:RC, 4(RC)
      dasm_put(Dst, 6321);
# 3722 "buildvm_ppc.dasc"
    }
    //|  b ->BC_TGETS_Z			// String key?
    dasm_put(Dst, 6323);
# 3724 "buildvm_ppc.dasc"
    break;
  case BC_TGETS:
    //|  // RA = dst*8, RB = table*8, RC = str_const*8 (~)
    //|  lwzux CARG1, RB, BASE
    //|   srwi TMP1, RC, 1
    //|    lwz TAB:RB, 4(RB)
    //|   subfic TMP1, TMP1, -4
    //|  checktab CARG1
    //|   lwzx STR:RC, KBASE, TMP1	// KBASE-4-str_const*4
    //|  bne ->vmeta_tgets1
    //|->BC_TGETS_Z:
    //|  // TAB:RB = GCtab *, STR:RC = GCstr *, RA = dst*8
    //|  lwz TMP0, TAB:RB->hmask
    //|  lwz TMP1, STR:RC->hash
    //|  lwz NODE:TMP2, TAB:RB->node
    //|  and TMP1, TMP1, TMP0		// idx = str->hash & tab->hmask
    //|  slwi TMP0, TMP1, 5
    //|  slwi TMP1, TMP1, 3
    //|  sub TMP1, TMP0, TMP1
    //|  add NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
    //|1:
    //|  lwz CARG1, NODE:TMP2->key
    //|   lwz TMP0, 4+offsetof(Node, key)(NODE:TMP2)
    //|    lwz CARG2, NODE:TMP2->val
    //|     lwz TMP1, 4+offsetof(Node, val)(NODE:TMP2)
    //|  checkstr CARG1; bne >4
    //|   cmpw TMP0, STR:RC; bne >4
    //|    checknil CARG2; beq >5		// Key found, but nil value?
    //|3:
    //|    stwux CARG2, RA, BASE
    //|     stw TMP1, 4(RA)
    //|  ins_next
    //|
    //|4:  // Follow hash chain.
    //|  lwz NODE:TMP2, NODE:TMP2->next
    //|  cmplwi NODE:TMP2, 0
    dasm_put(Dst, 6326, 32-1, LJ_TTAB, Dt6(->hmask), Dt5(->hash), Dt6(->node), 31-5, 31-3, DtB(->key), 4+offsetof(Node, key), DtB(->val), 4+offsetof(Node, val), LJ_TSTR, LJ_TNIL, DtB(->next));
# 3760 "buildvm_ppc.dasc"
    //|  bne <1
    //|  // End of hash chain: key not found, nil result.
    //|   li CARG2, LJ_TNIL
    //|
    //|5:  // Check for __index if table value is nil.
    //|  lwz TAB:TMP2, TAB:RB->metatable
    //|  cmplwi TAB:TMP2, 0
    //|  beq <3				// No metatable: done.
    //|  lbz TMP0, TAB:TMP2->nomm
    //|  andi. TMP0, TMP0, 1<<MM_index
    //|  bne <3				// 'no __index' flag set: done.
    //|  b ->vmeta_tgets
    dasm_put(Dst, 6387, LJ_TNIL, Dt6(->metatable), Dt6(->nomm), 1<<MM_index);
# 3772 "buildvm_ppc.dasc"
    break;
  case BC_TGETB:
    //|  // RA = dst*8, RB = table*8, RC = index*8
    //|  lwzux CARG1, RB, BASE
    //|   srwi TMP0, RC, 3
    //|   lwz TAB:RB, 4(RB)
    //|  checktab CARG1; bne ->vmeta_tgetb
    //|  lwz TMP1, TAB:RB->asize
    //|   lwz TMP2, TAB:RB->array
    //|  cmplw TMP0, TMP1; bge ->vmeta_tgetb
    //|  lwzx TMP1, TMP2, RC
    //|   lfdx f0, TMP2, RC
    //|  checknil TMP1; beq >5
    //|1:
    //|  ins_next1
    //|   stfdx f0, BASE, RA
    //|  ins_next2
    //|
    //|5:  // Check for __index if table value is nil.
    //|  lwz TAB:TMP2, TAB:RB->metatable
    //|  cmplwi TAB:TMP2, 0
    //|  beq <1				// No metatable: done.
    //|  lbz TMP2, TAB:TMP2->nomm
    //|  andi. TMP2, TMP2, 1<<MM_index
    //|  bne <1				// 'no __index' flag set: done.
    //|  b ->vmeta_tgetb			// Caveat: preserve TMP0!
    dasm_put(Dst, 6407, 32-3, LJ_TTAB, Dt6(->asize), Dt6(->array), LJ_TNIL, Dt6(->metatable), Dt6(->nomm), 1<<MM_index);
# 3798 "buildvm_ppc.dasc"
    break;

  case BC_TSETV:
    //|  // RA = src*8, RB = table*8, RC = key*8
    //|  lwzux CARG1, RB, BASE
    //|  lwzux CARG2, RC, BASE
    //|   lwz TAB:RB, 4(RB)
    dasm_put(Dst, 6455);
# 3805 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|   lwz RC, 4(RC)
      dasm_put(Dst, 6459);
# 3807 "buildvm_ppc.dasc"
    } else {
      //|   lfd f0, 0(RC)
      dasm_put(Dst, 6461);
# 3809 "buildvm_ppc.dasc"
    }
    //|  checktab CARG1
    //|   checknum cr1, CARG2
    //|  bne ->vmeta_tsetv
    dasm_put(Dst, 6463, LJ_TTAB);
# 3813 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|  lwz TMP0, TAB:RB->asize
      //|   bne cr1, >5
      //|   lwz TMP1, TAB:RB->array
      //|  cmplw TMP0, RC
      //|   slwi TMP0, RC, 3
      dasm_put(Dst, 6469, Dt6(->asize), Dt6(->array), 31-3);
# 3819 "buildvm_ppc.dasc"
    } else {
      //|   bge cr1, >5
      //|  // Convert number key to integer, check for integerness and range.
      //|  fctiwz f1, f0
      //|    fadd f2, f0, TOBIT
      //|  stfd f1, TMPD
      //|   lwz TMP0, TAB:RB->asize
      //|    fsub f2, f2, TOBIT
      //|  lwz TMP2, TMPD_LO
      //|   lwz TMP1, TAB:RB->array
      //|    fcmpu cr1, f0, f2
      //|  cmplw cr0, TMP0, TMP2
      //|  crand 4*cr0+gt, 4*cr0+gt, 4*cr1+eq
      //|   slwi TMP0, TMP2, 3
      dasm_put(Dst, 6479, Dt6(->asize), Dt6(->array), 31-3);
# 3833 "buildvm_ppc.dasc"
    }
    //|  ble ->vmeta_tsetv		// Integer key and in array part?
    //|   lwzx TMP2, TMP1, TMP0
    //|  lbz TMP3, TAB:RB->marked
    //|    lfdx f14, BASE, RA
    //|   checknil TMP2; beq >3
    //|1:
    //|  andi. TMP2, TMP3, LJ_GC_BLACK	// isblack(table)
    //|    stfdx f14, TMP1, TMP0
    //|  bne >7
    //|2:
    //|  ins_next
    //|
    //|3:  // Check for __newindex if previous value is nil.
    //|  lwz TAB:TMP2, TAB:RB->metatable
    //|  cmplwi TAB:TMP2, 0
    //|  beq <1				// No metatable: done.
    //|  lbz TMP2, TAB:TMP2->nomm
    //|  andi. TMP2, TMP2, 1<<MM_newindex
    //|  bne <1				// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsetv
    //|
    //|5:
    //|  checkstr CARG2; bne ->vmeta_tsetv
    dasm_put(Dst, 6496, Dt6(->marked), LJ_TNIL, LJ_GC_BLACK, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, LJ_TSTR);
# 3857 "buildvm_ppc.dasc"
    if (!LJ_DUALNUM) {
      //|  lwz STR:RC, 4(RC)
      dasm_put(Dst, 6543);
# 3859 "buildvm_ppc.dasc"
    }
    //|  b ->BC_TSETS_Z			// String key?
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:RB, TMP3, TMP0
    //|  b <2
    dasm_put(Dst, 6545, DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3865 "buildvm_ppc.dasc"
    break;
  case BC_TSETS:
    //|  // RA = src*8, RB = table*8, RC = str_const*8 (~)
    //|  lwzux CARG1, RB, BASE
    //|   srwi TMP1, RC, 1
    //|    lwz TAB:RB, 4(RB)
    //|   subfic TMP1, TMP1, -4
    //|  checktab CARG1
    //|   lwzx STR:RC, KBASE, TMP1	// KBASE-4-str_const*4
    //|  bne ->vmeta_tsets1
    //|->BC_TSETS_Z:
    //|  // TAB:RB = GCtab *, STR:RC = GCstr *, RA = src*8
    //|  lwz TMP0, TAB:RB->hmask
    //|  lwz TMP1, STR:RC->hash
    //|  lwz NODE:TMP2, TAB:RB->node
    //|    stb ZERO, TAB:RB->nomm		// Clear metamethod cache.
    //|  and TMP1, TMP1, TMP0		// idx = str->hash & tab->hmask
    //|    lfdx f14, BASE, RA
    //|  slwi TMP0, TMP1, 5
    //|  slwi TMP1, TMP1, 3
    //|  sub TMP1, TMP0, TMP1
    //|    lbz TMP3, TAB:RB->marked
    //|  add NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
    //|1:
    //|  lwz CARG1, NODE:TMP2->key
    //|   lwz TMP0, 4+offsetof(Node, key)(NODE:TMP2)
    //|    lwz CARG2, NODE:TMP2->val
    //|     lwz NODE:TMP1, NODE:TMP2->next
    //|  checkstr CARG1; bne >5
    //|   cmpw TMP0, STR:RC; bne >5
    //|    checknil CARG2; beq >4		// Key found, but nil value?
    //|2:
    //|  andi. TMP0, TMP3, LJ_GC_BLACK	// isblack(table)
    dasm_put(Dst, 6560, 32-1, LJ_TTAB, Dt6(->hmask), Dt5(->hash), Dt6(->node), Dt6(->nomm), 31-5, 31-3, Dt6(->marked), DtB(->key), 4+offsetof(Node, key), DtB(->val), DtB(->next), LJ_TSTR, LJ_TNIL);
# 3898 "buildvm_ppc.dasc"
    //|    stfd f14, NODE:TMP2->val
    //|  bne >7
    //|3:
    //|  ins_next
    //|
    //|4:  // Check for __newindex if previous value is nil.
    //|  lwz TAB:TMP1, TAB:RB->metatable
    //|  cmplwi TAB:TMP1, 0
    //|  beq <2				// No metatable: done.
    //|  lbz TMP0, TAB:TMP1->nomm
    //|  andi. TMP0, TMP0, 1<<MM_newindex
    //|  bne <2				// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsets
    //|
    //|5:  // Follow hash chain.
    //|  cmplwi NODE:TMP1, 0
    //|   mr NODE:TMP2, NODE:TMP1
    //|  bne <1
    //|  // End of hash chain: key not found, add a new one.
    //|
    //|  // But check for __newindex first.
    //|  lwz TAB:TMP1, TAB:RB->metatable
    //|   la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
    //|   stw PC, SAVE_PC
    //|   mr CARG1, L
    //|  cmplwi TAB:TMP1, 0
    //|   stw BASE, L->base
    //|  beq >6				// No metatable: continue.
    //|  lbz TMP0, TAB:TMP1->nomm
    //|  andi. TMP0, TMP0, 1<<MM_newindex
    //|  beq ->vmeta_tsets		// 'no __newindex' flag NOT set: check.
    //|6:
    //|  li TMP0, LJ_TSTR
    //|   stw STR:RC, 4(CARG3)
    dasm_put(Dst, 6611, LJ_GC_BLACK, DtB(->val), Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, Dt6(->metatable), DISPATCH_GL(tmptv), Dt1(->base), Dt6(->nomm), 1<<MM_newindex, LJ_TSTR);
# 3932 "buildvm_ppc.dasc"
    //|   mr CARG2, TAB:RB
    //|  stw TMP0, 0(CARG3)
    //|  bl extern lj_tab_newkey		// (lua_State *L, GCtab *t, TValue *k)
    //|  // Returns TValue *.
    //|  lwz BASE, L->base
    //|  stfd f14, 0(CRET1)
    //|  b <3				// No 2nd write barrier needed.
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:RB, TMP3, TMP0
    //|  b <3
    dasm_put(Dst, 6668, Dt1(->base), DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3943 "buildvm_ppc.dasc"
    break;
  case BC_TSETB:
    //|  // RA = src*8, RB = table*8, RC = index*8
    //|  lwzux CARG1, RB, BASE
    //|   srwi TMP0, RC, 3
    //|   lwz TAB:RB, 4(RB)
    //|  checktab CARG1; bne ->vmeta_tsetb
    //|  lwz TMP1, TAB:RB->asize
    //|   lwz TMP2, TAB:RB->array
    //|    lbz TMP3, TAB:RB->marked
    //|  cmplw TMP0, TMP1
    //|   lfdx f14, BASE, RA
    //|  bge ->vmeta_tsetb
    //|  lwzx TMP1, TMP2, RC
    //|  checknil TMP1; beq >5
    //|1:
    //|  andi. TMP0, TMP3, LJ_GC_BLACK	// isblack(table)
    //|   stfdx f14, TMP2, RC
    //|  bne >7
    //|2:
    //|  ins_next
    //|
    //|5:  // Check for __newindex if previous value is nil.
    //|  lwz TAB:TMP1, TAB:RB->metatable
    //|  cmplwi TAB:TMP1, 0
    //|  beq <1				// No metatable: done.
    //|  lbz TMP1, TAB:TMP1->nomm
    //|  andi. TMP1, TMP1, 1<<MM_newindex
    //|  bne <1				// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsetb			// Caveat: preserve TMP0!
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:RB, TMP3, TMP0
    dasm_put(Dst, 6691, 32-3, LJ_TTAB, Dt6(->asize), Dt6(->array), Dt6(->marked), LJ_TNIL, LJ_GC_BLACK, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, DISPATCH_GL(gc.grayagain));
# 3976 "buildvm_ppc.dasc"
    //|  b <2
    dasm_put(Dst, 6749, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3977 "buildvm_ppc.dasc"
    break;

  case BC_TSETM:
    //|  // RA = base*8 (table at base-1), RD = num_const*8 (start index)
    //|  add RA, BASE, RA
    //|1:
    //|   add TMP3, KBASE, RD
    //|  lwz TAB:CARG2, -4(RA)		// Guaranteed to be a table.
    //|    addic. TMP0, MULTRES, -8
    //|   lwz TMP3, 4(TMP3)		// Integer constant is in lo-word.
    //|    srwi CARG3, TMP0, 3
    //|    beq >4				// Nothing to copy?
    //|  add CARG3, CARG3, TMP3
    //|  lwz TMP2, TAB:CARG2->asize
    //|   slwi TMP1, TMP3, 3
    //|    lbz TMP3, TAB:CARG2->marked
    //|  cmplw CARG3, TMP2
    //|   add TMP2, RA, TMP0
    //|   lwz TMP0, TAB:CARG2->array
    //|  bgt >5
    //|   add TMP1, TMP1, TMP0
    //|    andi. TMP0, TMP3, LJ_GC_BLACK	// isblack(table)
    //|3:  // Copy result slots to table.
    //|   lfd f0, 0(RA)
    //|  addi RA, RA, 8
    //|  cmpw cr1, RA, TMP2
    //|   stfd f0, 0(TMP1)
    //|    addi TMP1, TMP1, 8
    //|  blt cr1, <3
    //|  bne >7
    //|4:
    //|  ins_next
    //|
    //|5:  // Need to resize array part.
    //|   stw BASE, L->base
    //|  mr CARG1, L
    //|   stw PC, SAVE_PC
    //|  mr SAVE0, RD
    //|  bl extern lj_tab_reasize		// (lua_State *L, GCtab *t, int nasize)
    //|  // Must not reallocate the stack.
    //|  mr RD, SAVE0
    //|  b <1
    //|
    //|7:  // Possible table write barrier for any value. Skip valiswhite check.
    //|  barrierback TAB:CARG2, TMP3, TMP0
    //|  b <4
    dasm_put(Dst, 6759, 32-3, Dt6(->asize), 31-3, Dt6(->marked), Dt6(->array), LJ_GC_BLACK, Dt1(->base), DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
    dasm_put(Dst, 6828);
# 4023 "buildvm_ppc.dasc"
    break;

  /* -- Calls and vararg handling ----------------------------------------- */

  case BC_CALLM:
    //|  // RA = base*8, (RB = (nresults+1)*8,) RC = extra_nargs*8
    //|  add NARGS8:RC, NARGS8:RC, MULTRES
    //|  // Fall through. Assumes BC_CALL follows.
    dasm_put(Dst, 6831);
# 4031 "buildvm_ppc.dasc"
    break;
  case BC_CALL:
    //|  // RA = base*8, (RB = (nresults+1)*8,) RC = (nargs+1)*8
    //|  mr TMP2, BASE
    //|  lwzux TMP0, BASE, RA
    //|   lwz LFUNC:RB, 4(BASE)
    //|    subi NARGS8:RC, NARGS8:RC, 8
    //|   addi BASE, BASE, 8
    //|  checkfunc TMP0; bne ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 6833, LJ_TFUNC, Dt7(->pc));
# 4041 "buildvm_ppc.dasc"
    break;

  case BC_CALLMT:
    //|  // RA = base*8, (RB = 0,) RC = extra_nargs*8
    //|  add NARGS8:RC, NARGS8:RC, MULTRES
    //|  // Fall through. Assumes BC_CALLT follows.
    dasm_put(Dst, 6854);
# 4047 "buildvm_ppc.dasc"
    break;
  case BC_CALLT:
    //|  // RA = base*8, (RB = 0,) RC = (nargs+1)*8
    //|  lwzux TMP0, RA, BASE
    //|   lwz LFUNC:RB, 4(RA)
    //|    subi NARGS8:RC, NARGS8:RC, 8
    //|    lwz TMP1, FRAME_PC(BASE)
    //|  checkfunc TMP0
    //|   addi RA, RA, 8
    //|  bne ->vmeta_callt
    //|->BC_CALLT_Z:
    //|  andi. TMP0, TMP1, FRAME_TYPE	// Caveat: preserve cr0 until the crand.
    //|   lbz TMP3, LFUNC:RB->ffid
    //|    xori TMP2, TMP1, FRAME_VARG
    //|    cmplwi cr1, NARGS8:RC, 0
    //|  bne >7
    //|1:
    //|  stw LFUNC:RB, FRAME_FUNC(BASE)	// Copy function down, but keep PC.
    //|  li TMP2, 0
    //|   cmplwi cr7, TMP3, 1		// (> FF_C) Calling a fast function?
    //|    beq cr1, >3
    //|2:
    //|  addi TMP3, TMP2, 8
    //|   lfdx f0, RA, TMP2
    //|  cmplw cr1, TMP3, NARGS8:RC
    //|   stfdx f0, BASE, TMP2
    //|  mr TMP2, TMP3
    //|  bne cr1, <2
    //|3:
    //|  crand 4*cr0+eq, 4*cr0+eq, 4*cr7+gt
    //|  beq >5
    //|4:
    //|  ins_callt
    //|
    //|5:  // Tailcall to a fast function with a Lua frame below.
    //|  lwz INS, -4(TMP1)
    //|  decode_RA8 RA, INS
    //|  sub TMP1, BASE, RA
    //|  lwz LFUNC:TMP1, FRAME_FUNC-8(TMP1)
    //|  lwz TMP1, LFUNC:TMP1->pc
    //|  lwz KBASE, PC2PROTO(k)(TMP1)	// Need to prepare KBASE.
    //|  b <4
    //|
    //|7:  // Tailcall from a vararg function.
    //|  andi. TMP0, TMP2, FRAME_TYPEP
    //|  bne <1				// Vararg frame below?
    dasm_put(Dst, 6856, LJ_TFUNC, FRAME_TYPE, Dt7(->ffid), FRAME_VARG, Dt7(->pc), -4-8, Dt7(->pc), PC2PROTO(k), FRAME_TYPEP);
# 4093 "buildvm_ppc.dasc"
    //|  sub BASE, BASE, TMP2		// Relocate BASE down.
    //|  lwz TMP1, FRAME_PC(BASE)
    //|  andi. TMP0, TMP1, FRAME_TYPE
    //|  b <1
    dasm_put(Dst, 6920, FRAME_TYPE);
# 4097 "buildvm_ppc.dasc"
    break;

  case BC_ITERC:
    //|  // RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 ((2+1)*8))
    //|  mr TMP2, BASE
    //|  add BASE, BASE, RA
    //|  lwz TMP1, -24(BASE)
    //|   lwz LFUNC:RB, -20(BASE)
    //|    lfd f1, -8(BASE)
    //|    lfd f0, -16(BASE)
    //|  stw TMP1, 0(BASE)		// Copy callable.
    //|   stw LFUNC:RB, 4(BASE)
    //|  checkfunc TMP1
    //|    stfd f1, 16(BASE)		// Copy control var.
    //|     li NARGS8:RC, 16		// Iterators get 2 arguments.
    //|    stfdu f0, 8(BASE)		// Copy state.
    //|  bne ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 6929, LJ_TFUNC, Dt7(->pc));
# 4115 "buildvm_ppc.dasc"
    break;

  case BC_ITERN:
    //|  // RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 (2+1)*8)
#if LJ_HASJIT
    //|  // NYI: add hotloop, record BC_ITERN.
#endif
    //|  add RA, BASE, RA
    //|  lwz TAB:RB, -12(RA)
    //|  lwz RC, -4(RA)			// Get index from control var.
    //|  lwz TMP0, TAB:RB->asize
    //|  lwz TMP1, TAB:RB->array
    //|   addi PC, PC, 4
    //|1:  // Traverse array part.
    //|  cmplw RC, TMP0
    //|   slwi TMP3, RC, 3
    //|  bge >5				// Index points after array part?
    //|  lwzx TMP2, TMP1, TMP3
    //|   lfdx f0, TMP1, TMP3
    //|  checknil TMP2
    //|     lwz INS, -4(PC)
    //|  beq >4
    dasm_put(Dst, 6956, Dt6(->asize), Dt6(->array), 31-3, LJ_TNIL);
# 4137 "buildvm_ppc.dasc"
    if (LJ_DUALNUM) {
      //|   stw RC, 4(RA)
      //|   stw TISNUM, 0(RA)
      dasm_put(Dst, 6978);
# 4140 "buildvm_ppc.dasc"
    } else {
      //|   tonum_u f1, RC
      dasm_put(Dst, 6981);
# 4142 "buildvm_ppc.dasc"
    }
    //|    addi RC, RC, 1
    //|     addis TMP3, PC, -(BCBIAS_J*4 >> 16)
    //|  stfd f0, 8(RA)
    //|     decode_RD4 TMP1, INS
    //|    stw RC, -4(RA)			// Update control var.
    //|     add PC, TMP1, TMP3
    dasm_put(Dst, 6985, -(BCBIAS_J*4 >> 16));
# 4149 "buildvm_ppc.dasc"
    if (!LJ_DUALNUM) {
      //|   stfd f1, 0(RA)
      dasm_put(Dst, 6993);
# 4151 "buildvm_ppc.dasc"
    }
    //|3:
    //|  ins_next
    //|
    //|4:  // Skip holes in array part.
    //|  addi RC, RC, 1
    //|  b <1
    //|
    //|5:  // Traverse hash part.
    //|  lwz TMP1, TAB:RB->hmask
    //|  sub RC, RC, TMP0
    //|   lwz TMP2, TAB:RB->node
    //|6:
    //|  cmplw RC, TMP1			// End of iteration? Branch to ITERL+1.
    //|   slwi TMP3, RC, 5
    //|  bgty <3
    //|   slwi RB, RC, 3
    //|   sub TMP3, TMP3, RB
    //|  lwzx RB, TMP2, TMP3
    //|  lfdx f0, TMP2, TMP3
    //|   add NODE:TMP3, TMP2, TMP3
    //|  checknil RB
    //|     lwz INS, -4(PC)
    //|  beq >7
    //|   lfd f1, NODE:TMP3->key
    //|     addis TMP2, PC, -(BCBIAS_J*4 >> 16)
    //|  stfd f0, 8(RA)
    //|    add RC, RC, TMP0
    //|     decode_RD4 TMP1, INS
    //|   stfd f1, 0(RA)
    //|    addi RC, RC, 1
    //|     add PC, TMP1, TMP2
    //|    stw RC, -4(RA)			// Update control var.
    //|  b <3
    //|
    //|7:  // Skip holes in hash part.
    //|  addi RC, RC, 1
    //|  b <6
    dasm_put(Dst, 6995, Dt6(->hmask), Dt6(->node), 31-5, 31-3, LJ_TNIL, DtB(->key), -(BCBIAS_J*4 >> 16));
# 4189 "buildvm_ppc.dasc"
    break;

  case BC_ISNEXT:
    //|  // RA = base*8, RD = target (points to ITERN)
    //|  add RA, BASE, RA
    //|  lwz TMP0, -24(RA)
    //|  lwz CFUNC:TMP1, -20(RA)
    //|   lwz TMP2, -16(RA)
    //|    lwz TMP3, -8(RA)
    //|   cmpwi cr0, TMP2, LJ_TTAB
    //|  cmpwi cr1, TMP0, LJ_TFUNC
    //|    cmpwi cr6, TMP3, LJ_TNIL
    //|  bne cr1, >5
    //|  lbz TMP1, CFUNC:TMP1->ffid
    //|   crand 4*cr0+eq, 4*cr0+eq, 4*cr6+eq
    //|  cmpwi cr7, TMP1, FF_next_N
    //|    srwi TMP0, RD, 1
    //|  crand 4*cr0+eq, 4*cr0+eq, 4*cr7+eq
    //|    add TMP3, PC, TMP0
    //|  bne cr0, >5
    //|  stw ZERO, -4(RA)			// Initialize control var.
    //|    addis PC, TMP3, -(BCBIAS_J*4 >> 16)
    //|1:
    //|  ins_next
    //|5:  // Despecialize bytecode if any of the checks fail.
    //|  li TMP0, BC_JMP
    //|   li TMP1, BC_ITERC
    //|  stb TMP0, -1(PC)
    //|    addis PC, TMP3, -(BCBIAS_J*4 >> 16)
    //|   stb TMP1, 3(PC)
    //|  b <1
    dasm_put(Dst, 7051, LJ_TTAB, LJ_TFUNC, LJ_TNIL, Dt8(->ffid), FF_next_N, 32-1, -(BCBIAS_J*4 >> 16), BC_JMP, BC_ITERC, -(BCBIAS_J*4 >> 16));
# 4220 "buildvm_ppc.dasc"
    break;

  case BC_VARG:
    //|  // RA = base*8, RB = (nresults+1)*8, RC = numparams*8
    //|  lwz TMP0, FRAME_PC(BASE)
    //|  add RC, BASE, RC
    //|   add RA, BASE, RA
    //|  addi RC, RC, FRAME_VARG
    //|   add TMP2, RA, RB
    //|  subi TMP3, BASE, 8		// TMP3 = vtop
    //|  sub RC, RC, TMP0			// RC = vbase
    //|  // Note: RC may now be even _above_ BASE if nargs was < numparams.
    //|  cmplwi cr1, RB, 0
    //|   sub. TMP1, TMP3, RC
    //|  beq cr1, >5			// Copy all varargs?
    //|   subi TMP2, TMP2, 16
    //|   ble >2				// No vararg slots?
    //|1:  // Copy vararg slots to destination slots.
    //|  lfd f0, 0(RC)
    //|   addi RC, RC, 8
    //|  stfd f0, 0(RA)
    //|  cmplw RA, TMP2
    //|   cmplw cr1, RC, TMP3
    //|  bge >3				// All destination slots filled?
    //|    addi RA, RA, 8
    //|   blt cr1, <1			// More vararg slots?
    //|2:  // Fill up remainder with nil.
    //|  stw TISNIL, 0(RA)
    //|  cmplw RA, TMP2
    //|   addi RA, RA, 8
    //|  blt <2
    //|3:
    //|  ins_next
    //|
    //|5:  // Copy all varargs.
    //|  lwz TMP0, L->maxstack
    //|   li MULTRES, 8			// MULTRES = (0+1)*8
    //|  bley <3				// No vararg slots?
    //|  add TMP2, RA, TMP1
    //|  cmplw TMP2, TMP0
    //|   addi MULTRES, TMP1, 8
    //|  bgt >7
    //|6:
    //|  lfd f0, 0(RC)
    //|   addi RC, RC, 8
    //|  stfd f0, 0(RA)
    //|  cmplw RC, TMP3
    //|   addi RA, RA, 8
    //|  blt <6				// More vararg slots?
    //|  b <3
    //|
    //|7:  // Grow stack for varargs.
    //|  mr CARG1, L
    //|   stw RA, L->top
    //|  sub SAVE0, RC, BASE		// Need delta, because BASE may change.
    //|   stw BASE, L->base
    //|  sub RA, RA, BASE
    //|   stw PC, SAVE_PC
    //|  srwi CARG2, TMP1, 3
    //|  bl extern lj_state_growstack	// (lua_State *L, int n)
    //|  lwz BASE, L->base
    //|  add RA, BASE, RA
    dasm_put(Dst, 7101, FRAME_VARG, Dt1(->maxstack), Dt1(->top), Dt1(->base), 32-3, Dt1(->base));
# 4282 "buildvm_ppc.dasc"
    //|  add RC, BASE, SAVE0
    //|  subi TMP3, BASE, 8
    //|  b <6
    dasm_put(Dst, 7181);
# 4285 "buildvm_ppc.dasc"
    break;

  /* -- Returns ----------------------------------------------------------- */

  case BC_RETM:
    //|  // RA = results*8, RD = extra_nresults*8
    //|  add RD, RD, MULTRES		// MULTRES >= 8, so RD >= 8.
    //|  // Fall through. Assumes BC_RET follows.
    dasm_put(Dst, 7187);
# 4293 "buildvm_ppc.dasc"
    break;

  case BC_RET:
    //|  // RA = results*8, RD = (nresults+1)*8
    //|  lwz PC, FRAME_PC(BASE)
    //|   add RA, BASE, RA
    //|    mr MULTRES, RD
    //|1:
    //|  andi. TMP0, PC, FRAME_TYPE
    //|   xori TMP1, PC, FRAME_VARG
    //|  bne ->BC_RETV_Z
    //|
    //|->BC_RET_Z:
    //|  // BASE = base, RA = resultptr, RD = (nresults+1)*8, PC = return
    //|   lwz INS, -4(PC)
    //|  cmpwi RD, 8
    //|   subi TMP2, BASE, 8
    //|   subi RC, RD, 8
    //|   decode_RB8 RB, INS
    //|  beq >3
    //|   li TMP1, 0
    //|2:
    //|  addi TMP3, TMP1, 8
    //|   lfdx f0, RA, TMP1
    //|  cmpw TMP3, RC
    //|   stfdx f0, TMP2, TMP1
    //|  beq >3
    //|  addi TMP1, TMP3, 8
    //|   lfdx f1, RA, TMP3
    //|  cmpw TMP1, RC
    //|   stfdx f1, TMP2, TMP3
    //|  bne <2
    //|3:
    //|5:
    //|  cmplw RB, RD
    //|   decode_RA8 RA, INS
    //|  bgt >6
    //|   sub BASE, TMP2, RA
    //|  lwz LFUNC:TMP1, FRAME_FUNC(BASE)
    //|  ins_next1
    //|  lwz TMP1, LFUNC:TMP1->pc
    //|  lwz KBASE, PC2PROTO(k)(TMP1)
    //|  ins_next2
    //|
    //|6:  // Fill up results with nil.
    //|  subi TMP1, RD, 8
    //|   addi RD, RD, 8
    //|  stwx TISNIL, TMP2, TMP1
    //|  b <5
    //|
    //|->BC_RETV_Z:  // Non-standard return case.
    //|  andi. TMP2, TMP1, FRAME_TYPEP
    //|  bne ->vm_return
    //|  // Return from vararg function: relocate BASE down.
    //|  sub BASE, BASE, TMP1
    //|  lwz PC, FRAME_PC(BASE)
    //|  b <1
    dasm_put(Dst, 7189, FRAME_TYPE, FRAME_VARG, Dt7(->pc), PC2PROTO(k), FRAME_TYPEP);
# 4350 "buildvm_ppc.dasc"
    break;

  case BC_RET0: case BC_RET1:
    //|  // RA = results*8, RD = (nresults+1)*8
    //|  lwz PC, FRAME_PC(BASE)
    //|   add RA, BASE, RA
    //|    mr MULTRES, RD
    //|  andi. TMP0, PC, FRAME_TYPE
    //|   xori TMP1, PC, FRAME_VARG
    //|  bney ->BC_RETV_Z
    //|
    //|  lwz INS, -4(PC)
    //|   subi TMP2, BASE, 8
    //|  decode_RB8 RB, INS
    dasm_put(Dst, 7259, FRAME_TYPE, FRAME_VARG);
# 4364 "buildvm_ppc.dasc"
    if (op == BC_RET1) {
      //|  lfd f0, 0(RA)
      //|  stfd f0, 0(TMP2)
      dasm_put(Dst, 7272);
# 4367 "buildvm_ppc.dasc"
    }
    //|5:
    //|  cmplw RB, RD
    //|   decode_RA8 RA, INS
    //|  bgt >6
    //|   sub BASE, TMP2, RA
    //|  lwz LFUNC:TMP1, FRAME_FUNC(BASE)
    //|  ins_next1
    //|  lwz TMP1, LFUNC:TMP1->pc
    //|  lwz KBASE, PC2PROTO(k)(TMP1)
    //|  ins_next2
    //|
    //|6:  // Fill up results with nil.
    //|  subi TMP1, RD, 8
    //|   addi RD, RD, 8
    //|  stwx TISNIL, TMP2, TMP1
    //|  b <5
    dasm_put(Dst, 7275, Dt7(->pc), PC2PROTO(k));
# 4384 "buildvm_ppc.dasc"
    break;

  /* -- Loops and branches ------------------------------------------------ */

  case BC_FORL:
#if LJ_HASJIT
    //|  hotloop
    dasm_put(Dst, 7303, GG_DISP2HOT, -HOTCOUNT_LOOP);
# 4391 "buildvm_ppc.dasc"
#endif
    //|  // Fall through. Assumes BC_IFORL follows.
    break;

  case BC_JFORI:
  case BC_JFORL:
#if !LJ_HASJIT
    break;
#endif
  case BC_FORI:
  case BC_IFORL:
    //|  // RA = base*8, RD = target (after end of loop or start of loop)
    vk = (op == BC_IFORL || op == BC_JFORL);
    if (LJ_DUALNUM) {
      //|  // Integer loop.
      //|  lwzux TMP1, RA, BASE
      //|   lwz CARG1, FORL_IDX*8+4(RA)
      //|  cmplw cr0, TMP1, TISNUM
      dasm_put(Dst, 7313, FORL_IDX*8+4);
# 4409 "buildvm_ppc.dasc"
      if (vk) {
	//|   lwz CARG3, FORL_STEP*8+4(RA)
	//|  bne >9
	//|  addo. CARG1, CARG1, CARG3
	//|    cmpwi cr6, CARG3, 0
	//|   lwz CARG2, FORL_STOP*8+4(RA)
	//|  bso >6
	//|4:
	//|  stw CARG1, FORL_IDX*8+4(RA)
	dasm_put(Dst, 7318, FORL_STEP*8+4, FORL_STOP*8+4, FORL_IDX*8+4);
# 4418 "buildvm_ppc.dasc"
      } else {
	//|  lwz TMP3, FORL_STEP*8(RA)
	//|   lwz CARG3, FORL_STEP*8+4(RA)
	//|  lwz TMP2, FORL_STOP*8(RA)
	//|   lwz CARG2, FORL_STOP*8+4(RA)
	//|  cmplw cr7, TMP3, TISNUM
	//|  cmplw cr1, TMP2, TISNUM
	//|  crand 4*cr0+eq, 4*cr0+eq, 4*cr7+eq
	//|  crand 4*cr0+eq, 4*cr0+eq, 4*cr1+eq
	//|    cmpwi cr6, CARG3, 0
	//|  bne >9
	dasm_put(Dst, 7332, FORL_STEP*8, FORL_STEP*8+4, FORL_STOP*8, FORL_STOP*8+4);
# 4429 "buildvm_ppc.dasc"
      }
      //|    blt cr6, >5
      //|  cmpw CARG1, CARG2
      //|1:
      //|   stw TISNUM, FORL_EXT*8(RA)
      dasm_put(Dst, 7348, FORL_EXT*8);
# 4434 "buildvm_ppc.dasc"
      if (op != BC_JFORL) {
	//|  srwi RD, RD, 1
	dasm_put(Dst, 7355, 32-1);
# 4436 "buildvm_ppc.dasc"
      }
      //|   stw CARG1, FORL_EXT*8+4(RA)
      dasm_put(Dst, 7358, FORL_EXT*8+4);
# 4438 "buildvm_ppc.dasc"
      if (op != BC_JFORL) {
	//|  add RD, PC, RD
	dasm_put(Dst, 7361);
# 4440 "buildvm_ppc.dasc"
      }
      if (op == BC_FORI) {
	//|  bgt >3  // See FP loop below.
	dasm_put(Dst, 7363);
# 4443 "buildvm_ppc.dasc"
      } else if (op == BC_JFORI) {
	//|  addis PC, RD, -(BCBIAS_J*4 >> 16)
	//|  bley >7
	dasm_put(Dst, 7366, -(BCBIAS_J*4 >> 16));
# 4446 "buildvm_ppc.dasc"
      } else if (op == BC_IFORL) {
	//|  bgt >2
	//|  addis PC, RD, -(BCBIAS_J*4 >> 16)
	dasm_put(Dst, 7371, -(BCBIAS_J*4 >> 16));
# 4449 "buildvm_ppc.dasc"
      } else {
	//|  bley =>BC_JLOOP
	dasm_put(Dst, 7376, BC_JLOOP);
# 4451 "buildvm_ppc.dasc"
      }
      //|2:
      //|  ins_next
      //|5:  // Invert check for negative step.
      //|  cmpw CARG2, CARG1
      //|  b <1
      dasm_put(Dst, 7379);
# 4457 "buildvm_ppc.dasc"
      if (vk) {
	//|6:  // Potential overflow.
	//|  mcrxr cr0; bley <4		// Ignore unrelated overflow.
	//|  b <2
	dasm_put(Dst, 7395);
# 4461 "buildvm_ppc.dasc"
      }
    }
    if (vk) {
      if (LJ_DUALNUM) {
	//|9:  // FP loop.
	//|  lfd f1, FORL_IDX*8(RA)
	dasm_put(Dst, 7402, FORL_IDX*8);
# 4467 "buildvm_ppc.dasc"
      } else {
	//|  lfdux f1, RA, BASE
	dasm_put(Dst, 7406);
# 4469 "buildvm_ppc.dasc"
      }
      //|  lfd f3, FORL_STEP*8(RA)
      //|  lfd f2, FORL_STOP*8(RA)
      //|   lwz TMP3, FORL_STEP*8(RA)
      //|  fadd f1, f1, f3
      //|  stfd f1, FORL_IDX*8(RA)
      dasm_put(Dst, 7408, FORL_STEP*8, FORL_STOP*8, FORL_STEP*8, FORL_IDX*8);
# 4475 "buildvm_ppc.dasc"
    } else {
      if (LJ_DUALNUM) {
	//|9:  // FP loop.
	dasm_put(Dst, 7418);
# 4478 "buildvm_ppc.dasc"
      } else {
	//|  lwzux TMP1, RA, BASE
	//|  lwz TMP3, FORL_STEP*8(RA)
	//|  lwz TMP2, FORL_STOP*8(RA)
	//|  cmplw cr0, TMP1, TISNUM
	//|  cmplw cr7, TMP3, TISNUM
	//|  cmplw cr1, TMP2, TISNUM
	dasm_put(Dst, 7420, FORL_STEP*8, FORL_STOP*8);
# 4485 "buildvm_ppc.dasc"
      }
      //|   lfd f1, FORL_IDX*8(RA)
      //|  crand 4*cr0+lt, 4*cr0+lt, 4*cr7+lt
      //|  crand 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
      //|   lfd f2, FORL_STOP*8(RA)
      //|  bge ->vmeta_for
      dasm_put(Dst, 7429, FORL_IDX*8, FORL_STOP*8);
# 4491 "buildvm_ppc.dasc"
    }
    //|  cmpwi cr6, TMP3, 0
    dasm_put(Dst, 7438);
# 4493 "buildvm_ppc.dasc"
    if (op != BC_JFORL) {
      //|  srwi RD, RD, 1
      dasm_put(Dst, 7440, 32-1);
# 4495 "buildvm_ppc.dasc"
    }
    //|   stfd f1, FORL_EXT*8(RA)
    dasm_put(Dst, 7443, FORL_EXT*8);
# 4497 "buildvm_ppc.dasc"
    if (op != BC_JFORL) {
      //|  add RD, PC, RD
      dasm_put(Dst, 7446);
# 4499 "buildvm_ppc.dasc"
    }
    //|  fcmpu cr0, f1, f2
    dasm_put(Dst, 7448);
# 4501 "buildvm_ppc.dasc"
    if (op == BC_JFORI) {
      //|  addis PC, RD, -(BCBIAS_J*4 >> 16)
      dasm_put(Dst, 7450, -(BCBIAS_J*4 >> 16));
# 4503 "buildvm_ppc.dasc"
    }
    //|  blt cr6, >5
    dasm_put(Dst, 7453);
# 4505 "buildvm_ppc.dasc"
    if (op == BC_FORI) {
      //|  bgt >3
      dasm_put(Dst, 7456);
# 4507 "buildvm_ppc.dasc"
    } else if (op == BC_IFORL) {
      if (LJ_DUALNUM) {
	//|  bgty <2
	dasm_put(Dst, 7459);
# 4510 "buildvm_ppc.dasc"
      } else {
	//|  bgt >2
	dasm_put(Dst, 7462);
# 4512 "buildvm_ppc.dasc"
      }
      //|1:
      //|  addis PC, RD, -(BCBIAS_J*4 >> 16)
      dasm_put(Dst, 7465, -(BCBIAS_J*4 >> 16));
# 4515 "buildvm_ppc.dasc"
    } else if (op == BC_JFORI) {
      //|  bley >7
      dasm_put(Dst, 7469);
# 4517 "buildvm_ppc.dasc"
    } else {
      //|  bley =>BC_JLOOP
      dasm_put(Dst, 7472, BC_JLOOP);
# 4519 "buildvm_ppc.dasc"
    }
    if (LJ_DUALNUM) {
      //|  b <2
      dasm_put(Dst, 7475);
# 4522 "buildvm_ppc.dasc"
    } else {
      //|2:
      //|  ins_next
      dasm_put(Dst, 7478);
# 4525 "buildvm_ppc.dasc"
    }
    //|5:  // Negative step.
    dasm_put(Dst, 7490);
# 4527 "buildvm_ppc.dasc"
    if (op == BC_FORI) {
      //|  bge <2
      //|3:  // Used by integer loop, too.
      //|  addis PC, RD, -(BCBIAS_J*4 >> 16)
      dasm_put(Dst, 7492, -(BCBIAS_J*4 >> 16));
# 4531 "buildvm_ppc.dasc"
    } else if (op == BC_IFORL) {
      //|  bgey <1
      dasm_put(Dst, 7498);
# 4533 "buildvm_ppc.dasc"
    } else if (op == BC_JFORI) {
      //|  bgey >7
      dasm_put(Dst, 7501);
# 4535 "buildvm_ppc.dasc"
    } else {
      //|  bgey =>BC_JLOOP
      dasm_put(Dst, 7504, BC_JLOOP);
# 4537 "buildvm_ppc.dasc"
    }
    //|  b <2
    dasm_put(Dst, 7507);
# 4539 "buildvm_ppc.dasc"
    if (op == BC_JFORI) {
      //|7:
      //|  lwz INS, -4(PC)
      //|  decode_RD8 RD, INS
      //|  b =>BC_JLOOP
      dasm_put(Dst, 7510, BC_JLOOP);
# 4544 "buildvm_ppc.dasc"
    }
    break;

  case BC_ITERL:
#if LJ_HASJIT
    //|  hotloop
    dasm_put(Dst, 7516, GG_DISP2HOT, -HOTCOUNT_LOOP);
# 4550 "buildvm_ppc.dasc"
#endif
    //|  // Fall through. Assumes BC_IITERL follows.
    break;

  case BC_JITERL:
#if !LJ_HASJIT
    break;
#endif
  case BC_IITERL:
    //|  // RA = base*8, RD = target
    //|  lwzux TMP1, RA, BASE
    //|   lwz TMP2, 4(RA)
    //|  checknil TMP1; beq >1		// Stop if iterator returned nil.
    dasm_put(Dst, 7526, LJ_TNIL);
# 4563 "buildvm_ppc.dasc"
    if (op == BC_JITERL) {
      //|  stw TMP1, -8(RA)
      //|   stw TMP2, -4(RA)
      //|  b =>BC_JLOOP
      dasm_put(Dst, 7533, BC_JLOOP);
# 4567 "buildvm_ppc.dasc"
    } else {
      //|  branch_RD			// Otherwise save control var + branch.
      //|  stw TMP1, -8(RA)
      //|   stw TMP2, -4(RA)
      dasm_put(Dst, 7538, 32-1, -(BCBIAS_J*4 >> 16));
# 4571 "buildvm_ppc.dasc"
    }
    //|1:
    //|  ins_next
    dasm_put(Dst, 7546);
# 4574 "buildvm_ppc.dasc"
    break;

  case BC_LOOP:
    //|  // RA = base*8, RD = target (loop extent)
    //|  // Note: RA/RD is only used by trace recorder to determine scope/extent
    //|  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
#if LJ_HASJIT
    //|  hotloop
    dasm_put(Dst, 7558, GG_DISP2HOT, -HOTCOUNT_LOOP);
# 4582 "buildvm_ppc.dasc"
#endif
    //|  // Fall through. Assumes BC_ILOOP follows.
    break;

  case BC_ILOOP:
    //|  // RA = base*8, RD = target (loop extent)
    //|  ins_next
    dasm_put(Dst, 7568);
# 4589 "buildvm_ppc.dasc"
    break;

  case BC_JLOOP:
#if LJ_HASJIT
    //|  // RA = base*8 (ignored), RD = traceno*8
    //|  lwz TMP1, DISPATCH_J(trace)(DISPATCH)
    //|  srwi RD, RD, 1
    //|  // Traces on PPC don't store the trace number, so use 0.
    //|   stw ZERO, DISPATCH_GL(vmstate)(DISPATCH)
    //|  lwzx TRACE:TMP2, TMP1, RD
    //|  mcrxr cr0			// Clear SO flag.
    //|  lwz TMP2, TRACE:TMP2->mcode
    //|   stw BASE, DISPATCH_GL(jit_base)(DISPATCH)
    //|  mtctr TMP2
    //|   stw L, DISPATCH_GL(jit_L)(DISPATCH)
    //|   addi JGL, DISPATCH, GG_DISP2G+32768
    //|  bctr
    dasm_put(Dst, 7579, DISPATCH_J(trace), 32-1, DISPATCH_GL(vmstate), DtD(->mcode), DISPATCH_GL(jit_base), DISPATCH_GL(jit_L), GG_DISP2G+32768);
# 4606 "buildvm_ppc.dasc"
#endif
    break;

  case BC_JMP:
    //|  // RA = base*8 (only used by trace recorder), RD = target
    //|  branch_RD
    //|  ins_next
    dasm_put(Dst, 7598, 32-1, -(BCBIAS_J*4 >> 16));
# 4613 "buildvm_ppc.dasc"
    break;

  /* -- Function headers -------------------------------------------------- */

  case BC_FUNCF:
#if LJ_HASJIT
    //|  hotcall
    dasm_put(Dst, 7614, GG_DISP2HOT, -HOTCOUNT_CALL);
# 4620 "buildvm_ppc.dasc"
#endif
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
    //|  // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow.
    break;

  case BC_JFUNCF:
#if !LJ_HASJIT
    break;
#endif
  case BC_IFUNCF:
    //|  // BASE = new base, RA = BASE+framesize*8, RB = LFUNC, RC = nargs*8
    //|  lwz TMP2, L->maxstack
    //|   lbz TMP1, -4+PC2PROTO(numparams)(PC)
    //|    lwz KBASE, -4+PC2PROTO(k)(PC)
    //|  cmplw RA, TMP2
    //|   slwi TMP1, TMP1, 3
    //|  bgt ->vm_growstack_l
    dasm_put(Dst, 7624, Dt1(->maxstack), -4+PC2PROTO(numparams), -4+PC2PROTO(k), 31-3);
# 4637 "buildvm_ppc.dasc"
    if (op != BC_JFUNCF) {
      //|  ins_next1
      dasm_put(Dst, 7636);
# 4639 "buildvm_ppc.dasc"
    }
    //|2:
    //|  cmplw NARGS8:RC, TMP1		// Check for missing parameters.
    //|  blt >3
    dasm_put(Dst, 7639);
# 4643 "buildvm_ppc.dasc"
    if (op == BC_JFUNCF) {
      //|  decode_RD8 RD, INS
      //|  b =>BC_JLOOP
      dasm_put(Dst, 7644, BC_JLOOP);
# 4646 "buildvm_ppc.dasc"
    } else {
      //|  ins_next2
      dasm_put(Dst, 7648);
# 4648 "buildvm_ppc.dasc"
    }
    //|
    //|3:  // Clear missing parameters.
    //|  stwx TISNIL, BASE, NARGS8:RC
    //|  addi NARGS8:RC, NARGS8:RC, 8
    //|  b <2
    dasm_put(Dst, 7657);
# 4654 "buildvm_ppc.dasc"
    break;

  case BC_JFUNCV:
#if !LJ_HASJIT
    break;
#endif
    //|  NYI  // NYI: compiled vararg functions
    dasm_put(Dst, 7663);
# 4661 "buildvm_ppc.dasc"
    break;  /* NYI: compiled vararg functions. */

  case BC_IFUNCV:
    //|  // BASE = new base, RA = BASE+framesize*8, RB = LFUNC, RC = nargs*8
    //|  lwz TMP2, L->maxstack
    //|   add TMP1, BASE, RC
    //|  add TMP0, RA, RC
    //|   stw LFUNC:RB, 4(TMP1)		// Store copy of LFUNC.
    //|   addi TMP3, RC, 8+FRAME_VARG
    //|    lwz KBASE, -4+PC2PROTO(k)(PC)
    //|  cmplw TMP0, TMP2
    //|   stw TMP3, 0(TMP1)		// Store delta + FRAME_VARG.
    //|  bge ->vm_growstack_l
    //|  lbz TMP2, -4+PC2PROTO(numparams)(PC)
    //|   mr RA, BASE
    //|   mr RC, TMP1
    //|  ins_next1
    //|  cmpwi TMP2, 0
    //|   addi BASE, TMP1, 8
    //|  beq >3
    //|1:
    //|  cmplw RA, RC			// Less args than parameters?
    //|   lwz TMP0, 0(RA)
    //|   lwz TMP3, 4(RA)
    //|  bge >4
    //|    stw TISNIL, 0(RA)		// Clear old fixarg slot (help the GC).
    //|    addi RA, RA, 8
    //|2:
    //|  addic. TMP2, TMP2, -1
    //|   stw TMP0, 8(TMP1)
    //|   stw TMP3, 12(TMP1)
    //|    addi TMP1, TMP1, 8
    //|  bne <1
    //|3:
    //|  ins_next2
    //|
    //|4:  // Clear missing parameters.
    //|  li TMP0, LJ_TNIL
    //|  b <2
    dasm_put(Dst, 7665, Dt1(->maxstack), 8+FRAME_VARG, -4+PC2PROTO(k), -4+PC2PROTO(numparams), LJ_TNIL);
# 4700 "buildvm_ppc.dasc"
    break;

  case BC_FUNCC:
  case BC_FUNCCW:
    //|  // BASE = new base, RA = BASE+framesize*8, RB = CFUNC, RC = nargs*8
    if (op == BC_FUNCC) {
      //|  lwz TMP3, CFUNC:RB->f
      dasm_put(Dst, 7718, Dt8(->f));
# 4707 "buildvm_ppc.dasc"
    } else {
      //|  lwz TMP3, DISPATCH_GL(wrapf)(DISPATCH)
      dasm_put(Dst, 7721, DISPATCH_GL(wrapf));
# 4709 "buildvm_ppc.dasc"
    }
    //|   add TMP1, RA, NARGS8:RC
    //|   lwz TMP2, L->maxstack
    //|    add RC, BASE, NARGS8:RC
    //|   stw BASE, L->base
    //|   cmplw TMP1, TMP2
    //|    stw RC, L->top
    //|     li_vmstate C
    //|  mtctr TMP3
    dasm_put(Dst, 7724, Dt1(->maxstack), Dt1(->base), Dt1(->top), ~LJ_VMST_C);
# 4718 "buildvm_ppc.dasc"
    if (op == BC_FUNCCW) {
      //|  lwz CARG2, CFUNC:RB->f
      dasm_put(Dst, 7737, Dt8(->f));
# 4720 "buildvm_ppc.dasc"
    }
    //|  mr CARG1, L
    //|   bgt ->vm_growstack_c		// Need to grow stack.
    //|     st_vmstate
    //|  bctrl				// (lua_State *L [, lua_CFunction f])
    //|  // Returns nresults.
    //|  lwz BASE, L->base
    //|   slwi RD, CRET1, 3
    //|  lwz TMP1, L->top
    //|    li_vmstate INTERP
    //|  lwz PC, FRAME_PC(BASE)		// Fetch PC of caller.
    //|   sub RA, TMP1, RD		// RA = L->top - nresults*8
    //|    st_vmstate
    //|  b ->vm_returnc
    dasm_put(Dst, 7740, DISPATCH_GL(vmstate), Dt1(->base), 31-3, Dt1(->top), ~LJ_VMST_INTERP, DISPATCH_GL(vmstate));
# 4734 "buildvm_ppc.dasc"
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;

  dasm_growpc(Dst, BC__MAX);

  build_subroutines(ctx);

  //|.code_op
  dasm_put(Dst, 7761);
# 4754 "buildvm_ppc.dasc"
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);

  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
  int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
  int i;
  switch (ctx->mode) {
  case BUILD_elfasm:
    fprintf(ctx->fp, "\t.section .debug_frame,\"\",@progbits\n");
    fprintf(ctx->fp,
	".Lframe0:\n"
	"\t.long .LECIE0-.LSCIE0\n"
	".LSCIE0:\n"
	"\t.long 0xffffffff\n"
	"\t.byte 0x1\n"
	"\t.string \"\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -4\n"
	"\t.byte 65\n"
	"\t.byte 0xc\n\t.uleb128 1\n\t.uleb128 0\n"
	"\t.align 2\n"
	".LECIE0:\n\n");
    fprintf(ctx->fp,
	".LSFDE0:\n"
	"\t.long .LEFDE0-.LASFDE0\n"
	".LASFDE0:\n"
	"\t.long .Lframe0\n"
	"\t.long .Lbegin\n"
	"\t.long %d\n"
	"\t.byte 0xe\n\t.uleb128 %d\n"
	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
	"\t.byte 0x5\n\t.uleb128 70\n\t.uleb128 55\n",
	fcofs, CFRAME_SIZE);
    for (i = 14; i <= 31; i++)
      fprintf(ctx->fp,
	"\t.byte %d\n\t.uleb128 %d\n"
	"\t.byte %d\n\t.uleb128 %d\n",
	0x80+i, 37+(31-i), 0x80+32+i, 2+2*(31-i));
    fprintf(ctx->fp,
	"\t.align 2\n"
	".LEFDE0:\n\n");
#if LJ_HASFFI
    fprintf(ctx->fp,
	".LSFDE1:\n"
	"\t.long .LEFDE1-.LASFDE1\n"
	".LASFDE1:\n"
	"\t.long .Lframe0\n"
	"\t.long lj_vm_ffi_call\n"
	"\t.long %d\n"
	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
	"\t.byte 0x8e\n\t.uleb128 2\n"
	"\t.byte 0xd\n\t.uleb128 0xe\n"
	"\t.align 2\n"
	".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
#endif
    fprintf(ctx->fp, "\t.section .eh_frame,\"a\",@progbits\n");
    fprintf(ctx->fp,
	".Lframe1:\n"
	"\t.long .LECIE1-.LSCIE1\n"
	".LSCIE1:\n"
	"\t.long 0\n"
	"\t.byte 0x1\n"
	"\t.string \"zPR\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -4\n"
	"\t.byte 65\n"
	"\t.uleb128 6\n"			/* augmentation length */
	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
	"\t.long lj_err_unwind_dwarf-.\n"
	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
	"\t.byte 0xc\n\t.uleb128 1\n\t.uleb128 0\n"
	"\t.align 2\n"
	".LECIE1:\n\n");
    fprintf(ctx->fp,
	".LSFDE2:\n"
	"\t.long .LEFDE2-.LASFDE2\n"
	".LASFDE2:\n"
	"\t.long .LASFDE2-.Lframe1\n"
	"\t.long .Lbegin-.\n"
	"\t.long %d\n"
	"\t.uleb128 0\n"			/* augmentation length */
	"\t.byte 0xe\n\t.uleb128 %d\n"
	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
	"\t.byte 0x5\n\t.uleb128 70\n\t.uleb128 55\n",
	fcofs, CFRAME_SIZE);
    for (i = 14; i <= 31; i++)
      fprintf(ctx->fp,
	"\t.byte %d\n\t.uleb128 %d\n"
	"\t.byte %d\n\t.uleb128 %d\n",
	0x80+i, 37+(31-i), 0x80+32+i, 2+2*(31-i));
    fprintf(ctx->fp,
	"\t.align 2\n"
	".LEFDE2:\n\n");
#if LJ_HASFFI
    fprintf(ctx->fp,
	".Lframe2:\n"
	"\t.long .LECIE2-.LSCIE2\n"
	".LSCIE2:\n"
	"\t.long 0\n"
	"\t.byte 0x1\n"
	"\t.string \"zR\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -4\n"
	"\t.byte 65\n"
	"\t.uleb128 1\n"			/* augmentation length */
	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
	"\t.byte 0xc\n\t.uleb128 1\n\t.uleb128 0\n"
	"\t.align 2\n"
	".LECIE2:\n\n");
    fprintf(ctx->fp,
	".LSFDE3:\n"
	"\t.long .LEFDE3-.LASFDE3\n"
	".LASFDE3:\n"
	"\t.long .LASFDE3-.Lframe2\n"
	"\t.long lj_vm_ffi_call-.\n"
	"\t.long %d\n"
	"\t.uleb128 0\n"			/* augmentation length */
	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
	"\t.byte 0x8e\n\t.uleb128 2\n"
	"\t.byte 0xd\n\t.uleb128 0xe\n"
	"\t.align 2\n"
	".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
#endif
    break;
  default:
    break;
  }
}

